import classNames$1 from 'classnames';
import get from 'dlv';
import * as React from 'react';
import React__default from 'react';
import { c as createElementWithChildren, m as mergeProps, e as ensureNotArray, N as NONE, a as mergePropVals, i as isReactNode, b as isBrowser, u as useIsomorphicLayoutEffect } from './react-utils-35cb2a4e.js';
import { _ as __rest, a as __assign, b as __spreadArray, c as __read, o as omit, p as pick, d as __values, i as isSubset, e as chainSingleArgFuncs, n as notNil } from './common-182a0b0c.js';
export { o as omit, p as pick } from './common-182a0b0c.js';
export { PlasmicHead, plasmicHeadMeta } from './render/PlasmicHead/index.js';
export { PlasmicImg } from './render/PlasmicImg/index.js';
import { T as Trans } from './ssr-d3321868.js';
export { P as PlasmicRootProvider, T as Trans, g as genTranslatableString, u as useIsSSR } from './ssr-d3321868.js';
import ReactDOM__default from 'react-dom';
import { useFocusRing } from '@react-aria/focus';
import '@plasmicapp/data-sources-context';
import '@react-aria/ssr';

function renderStack(as, props, hasGap, ref) {
    var children = props.children, rest = __rest(props, ["children"]);
    var wrappedChildren = wrapFlexContainerChildren(children, hasGap !== null && hasGap !== void 0 ? hasGap : false);
    return createElementWithChildren(as, __assign({ ref: ref }, rest), wrappedChildren);
}
function FlexStack_(props, outerRef) {
    var as = props.as, hasGap = props.hasGap, rest = __rest(props, ["as", "hasGap"]);
    return renderStack(as !== null && as !== void 0 ? as : "div", rest, hasGap, outerRef);
}
var FlexStack = React.forwardRef(FlexStack_);
var makeStackImpl = function (as) {
    return React.forwardRef(function (props, ref) {
        var hasGap = props.hasGap, rest = __rest(props, ["hasGap"]);
        return renderStack(as, rest, hasGap, ref);
    });
};
var Stack = Object.assign(FlexStack, {
    div: makeStackImpl("div"),
    a: makeStackImpl("a"),
    button: makeStackImpl("button"),
    h1: makeStackImpl("h1"),
    h2: makeStackImpl("h2"),
    h3: makeStackImpl("h3"),
    h4: makeStackImpl("h4"),
    h5: makeStackImpl("h5"),
    h6: makeStackImpl("h6"),
    label: makeStackImpl("label"),
    form: makeStackImpl("form"),
    section: makeStackImpl("section"),
    head: makeStackImpl("head"),
    main: makeStackImpl("main"),
    nav: makeStackImpl("nav"),
});

function hasVariant(variants, groupName, variant) {
    if (variants == null) {
        return false;
    }
    var groupVariants = variants[groupName];
    if (groupVariants == null) {
        return false;
    }
    else if (groupVariants === true) {
        return variant === groupName;
    }
    else if (groupVariants === false) {
        return false;
    }
    else if (Array.isArray(groupVariants)) {
        return groupVariants.includes(variant);
    }
    else if (typeof groupVariants === "string") {
        return groupVariants === variant;
    }
    else {
        return (groupVariants[variant] !== undefined && groupVariants[variant] !== false);
    }
}
function wrapFlexContainerChildren(children, hasGap) {
    // We need to always wrap the children, even if there are no gaps, because
    // otherwise if we toggle between with and without gap, React reconciliation
    // will blow away the children tree and all state if we switch from having
    // a wrapper and not.
    var className = hasGap ? "__wab_flex-container" : "__wab_passthrough";
    if (!children) {
        return null;
    }
    else if (Array.isArray(children)) {
        return React.createElement.apply(React, __spreadArray(["div", { className: className }], __read(children)));
    }
    else {
        return React.createElement("div", { className: className }, children);
    }
}
function createPlasmicElement(override, defaultRoot, defaultProps, wrapChildrenInFlex) {
    if (!override || Object.keys(override).length === 0) {
        return createElementWithChildren(defaultRoot, defaultProps, defaultProps.children);
    }
    var override2 = deriveOverride(override);
    var props = mergeOverrideProps(defaultProps, override2.props);
    if (override2.type === "render") {
        return override2.render(props, defaultRoot);
    }
    var root = defaultRoot;
    if (override2.type === "as" && override2.as) {
        if (defaultRoot === Stack) {
            // If there was an "as" override specified, but the default type is
            // a Stack, then we don't want to switch to using "as" as the root,
            // because then we'd lose the flex wrapper that Stack provides.
            // Instead, we specify the "as" as the "as" prop to Stack.
            props.as = override2.as;
        }
        else {
            root = override2.as;
        }
    }
    var children = props.children;
    if (override2.wrapChildren) {
        children = override2.wrapChildren(ensureNotArray(children));
    }
    if (wrapChildrenInFlex) {
        // For legacy, we still support data-plasmic-wrap-flex-children
        children = wrapFlexContainerChildren(children, true);
    }
    var result = createElementWithChildren(root, props, children);
    if (override2.wrap) {
        result = override2.wrap(result);
    }
    return result;
}
// We use data-plasmic-XXX attributes for custom properties since Typescript doesn't
// support type check on jsx pragma. See https://github.com/microsoft/TypeScript/issues/21699
// for more info.
var seenElements = new Map();
function createPlasmicElementProxy(defaultElement, props) {
    // We use seenElements to keep track of elements that has been rendered by
    // createPlasmicElementProxy().  When a JSX tree is evaluated, the JSX factory
    // is invoked from the leaf to the root as the last call.  So we can store
    // all the elements we've created until we encounter the leaf, at which point
    // we will clear this map.  We are guaranteed that this map will only contain
    // elements from one Plasmic* component at a time, because we're just creating
    // elements and not "rendering" at this point; even if this JSX tree references
    // other Plasmic* elements, we'll just create an element referencing that component,
    // rather than following into the content of that component.
    //
    // TODO: is this ConcurrentMode friendly?
    var _a;
    var children = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        children[_i - 2] = arguments[_i];
    }
    if (props == null) {
        props = {};
    }
    var name = props["data-plasmic-name"];
    var isRoot = props["data-plasmic-root"];
    var forNodeName = props["data-plasmic-for-node"];
    delete props["data-plasmic-name"];
    delete props["data-plasmic-root"];
    delete props["data-plasmic-for-node"];
    var element = createPlasmicElementFromJsx.apply(void 0, __spreadArray([defaultElement,
        props], __read(children)));
    if (name) {
        seenElements.set(name, element);
    }
    if (isRoot) {
        // If this is the root, and we requested a specific node by specifying data-plasmic-for-node,
        // then return that node instead
        var forNode = forNodeName
            ? (_a = seenElements.get(forNodeName)) !== null && _a !== void 0 ? _a : null
            : element;
        // Clear out the seenElements map, as we're done rendering this Plasmic* component.
        seenElements.clear();
        return forNode;
    }
    return element;
}
function createPlasmicElementFromJsx(defaultElement, props) {
    var _a;
    var children = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        children[_i - 2] = arguments[_i];
    }
    var override = props["data-plasmic-override"];
    var wrapFlexChild = props["data-plasmic-wrap-flex-child"];
    var triggerProps = ((_a = props["data-plasmic-trigger-props"]) !== null && _a !== void 0 ? _a : []);
    delete props["data-plasmic-override"];
    delete props["data-plasmic-wrap-flex-child"];
    delete props["data-plasmic-trigger-props"];
    return createPlasmicElement(override, defaultElement, mergeProps.apply(void 0, __spreadArray([props,
        children.length === 0
            ? {}
            : { children: children.length === 1 ? children[0] : children }], __read(triggerProps))), wrapFlexChild);
}
function makeFragment() {
    var children = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        children[_i] = arguments[_i];
    }
    return React.createElement.apply(React, __spreadArray([React.Fragment, {}], __read(children)));
}
var UNSET = Symbol("UNSET");
function mergeOverrideProps(defaults, overrides) {
    var e_1, _a;
    if (!overrides) {
        return defaults;
    }
    var result = __assign({}, defaults);
    try {
        for (var _b = __values(Object.keys(overrides)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var key = _c.value;
            var defaultVal = defaults[key];
            var overrideVal = overrides[key];
            if (overrideVal === UNSET) {
                delete result[key];
            }
            else {
                // We use the NONE sentinel if the overrideVal is nil, and is not one of the
                // props that we merge by default -- which are className, style, and
                // event handlers.  This means for all other "normal" props -- like children,
                // title, etc -- a nil value will unset the default.
                if (overrideVal == null &&
                    key !== "className" &&
                    key !== "style" &&
                    !(key.startsWith("on") && typeof defaultVal === "function")) {
                    overrideVal = NONE;
                }
                result[key] = mergePropVals(key, defaultVal, overrideVal);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return result;
}
function wrapWithClassName(element, className) {
    var key = React.isValidElement(element)
        ? element.key || undefined
        : undefined;
    return React.createElement("div", {
        key: key,
        className: className,
        style: {
            display: "grid",
        },
    }, element);
}
function deriveOverride(x) {
    if (!x) {
        // undefined Binding is an empty Binding
        return {
            type: "default",
            props: {},
        };
    }
    else if (isReactNode(x)) {
        // If ReactNode, then assume this is the children
        return {
            type: "default",
            props: {
                children: x,
            },
        };
    }
    else if (typeof x === "object") {
        // If any of the overrideKeys is a key of this object, then assume
        // this is a full Override
        if ("as" in x) {
            return __assign(__assign({}, x), { props: x.props || {}, type: "as" });
        }
        else if ("render" in x) {
            return __assign(__assign({}, x), { type: "render" });
        }
        else if ("props" in x) {
            return __assign(__assign({}, x), { props: x.props || {}, type: "default" });
        }
        else if (isSubset(Object.keys(x), ["wrap", "wrapChildren"])) {
            // Only twiddling functions present, so assume no props overrides
            // (otherwise we'd assume these were props).
            return __assign(__assign({}, x), { props: {}, type: "default" });
        }
        // Else, assume this is just a props object.
        return {
            type: "default",
            props: x,
        };
    }
    else if (typeof x === "function") {
        return {
            type: "render",
            render: x,
        };
    }
    throw new Error("Unexpected override: " + x);
}
function mergeVariants(v1, v2) {
    if (!v1 || !v2) {
        return v1 || v2 || {};
    }
    return __assign(__assign({}, v1), v2);
}
function mergeVariantsWithStates(variants, $state, linkedStates) {
    return __assign(__assign({}, variants), Object.fromEntries(linkedStates.map(function (_a) {
        var variantGroup = _a.variantGroup, statePath = _a.statePath;
        return [
            variantGroup,
            get($state, statePath),
        ];
    })));
}
function mergeArgs(a1, a2) {
    if (!a1 || !a2) {
        return a1 || a2 || {};
    }
    return __assign(__assign({}, a1), a2);
}
function mergeFlexOverrides(o1, o2) {
    var e_2, _a;
    if (!o2) {
        return o1;
    }
    var keys = Array.from(new Set(__spreadArray(__spreadArray([], __read(Object.keys(o1))), __read(Object.keys(o2)))));
    var merged = {};
    try {
        for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
            var key = keys_1_1.value;
            merged[key] = mergeFlexOverride(o1[key], o2[key]);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (keys_1_1 && !keys_1_1.done && (_a = keys_1["return"])) _a.call(keys_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return merged;
}
function mergeFlexOverride(fo1, fo2) {
    var _a, _b;
    if (!fo1) {
        return fo2;
    }
    if (!fo2) {
        return fo1;
    }
    var o1 = deriveOverride(fo1);
    var o2 = deriveOverride(fo2);
    var wrap = chainSingleArgFuncs.apply(void 0, __spreadArray([], __read([o1.wrap, o2.wrap].filter(notNil))));
    var wrapChildren = chainSingleArgFuncs.apply(void 0, __spreadArray([], __read([o1.wrapChildren, o2.wrapChildren].filter(notNil))));
    // "render" type always takes precedence, but we still merge the props
    var props = mergeOverrideProps((_a = o1.props) !== null && _a !== void 0 ? _a : {}, o2.props);
    if (o2.type === "render") {
        return {
            render: o2.render,
            props: props,
            wrap: wrap,
            wrapChildren: wrapChildren,
        };
    }
    if (o1.type === "render") {
        return {
            render: o1.render,
            props: props,
            wrap: wrap,
            wrapChildren: wrapChildren,
        };
    }
    // "as" will take precedence
    var as = (_b = (o2.type === "as" ? o2.as : undefined)) !== null && _b !== void 0 ? _b : (o1.type === "as" ? o1.as : undefined);
    return __assign({ props: props,
        wrap: wrap,
        wrapChildren: wrapChildren }, (as ? { as: as } : {}));
}
function deriveRenderOpts(props, config) {
    var _a;
    var name = config.name, descendantNames = config.descendantNames, internalVariantPropNames = config.internalVariantPropNames, internalArgPropNames = config.internalArgPropNames;
    var reservedPropNames = ["variants", "args", "overrides"];
    var variants = mergeVariants(omit.apply(void 0, __spreadArray([pick.apply(void 0, __spreadArray([props], __read(internalVariantPropNames)))], __read(reservedPropNames))), props.variants);
    var args = mergeArgs(omit.apply(void 0, __spreadArray([pick.apply(void 0, __spreadArray([props], __read(internalArgPropNames)))], __read(reservedPropNames))), props.args);
    var overrides = mergeFlexOverrides(omit.apply(void 0, __spreadArray(__spreadArray(__spreadArray([pick.apply(void 0, __spreadArray([props], __read(descendantNames)))], __read(internalArgPropNames)), __read(internalVariantPropNames)), __read(reservedPropNames))), props.overrides);
    var leftoverProps = omit.apply(void 0, __spreadArray(__spreadArray(__spreadArray([props,
        "variants",
        "args",
        "overrides"], __read(descendantNames)), __read(internalVariantPropNames)), __read(internalArgPropNames)));
    if (Object.keys(leftoverProps).length > 0) {
        overrides = mergeFlexOverrides(overrides, (_a = {},
            _a[name] = {
                props: leftoverProps,
            },
            _a));
    }
    return { variants: variants, args: args, overrides: overrides };
}

var isDefaultValue = function (val) { return val === "PLEASE_RENDER_INSIDE_PROVIDER"; };
var seenDefaultVariants = {};
function ensureGlobalVariants(globalVariantValues) {
    Object.entries(globalVariantValues)
        .filter(function (_a) {
        var _b = __read(_a, 2); _b[0]; var value = _b[1];
        return isDefaultValue(value);
    })
        .forEach(function (_a) {
        var _b = __read(_a, 2), key = _b[0]; _b[1];
        globalVariantValues[key] = undefined;
        if (!seenDefaultVariants[key] && process.env.NODE_ENV === "development") {
            seenDefaultVariants[key] = true;
            var providerName = "" + key[0].toUpperCase() + key.substring(1) + "Context.Provider";
            console.warn("Plasmic context value for global variant \"" + key + "\" was not provided; please use " + providerName + " at the root of your React app. Learn More: https://www.plasmic.app/learn/other-assets/#global-variants");
        }
    });
    return globalVariantValues;
}

function PlasmicIcon(props) {
    var PlasmicIconType = props.PlasmicIconType, rest = __rest(props, ["PlasmicIconType"]);
    return React.createElement(PlasmicIconType, __assign({}, rest));
}

var PlasmicLink = React__default.forwardRef(function PlasmicLink(props, ref) {
    // props.href is required for nextjs; if no props.href,
    // then we just render the default anchor element
    if (props.platform === "nextjs" && props.href) {
        var nextjsProps = [
            "href",
            "replace",
            "scroll",
            "shallow",
            "passHref",
            "prefetch",
            "locale",
        ];
        return React__default.createElement(props.component, pick.apply(void 0, __spreadArray([props], __read(nextjsProps))), React__default.createElement("a", __assign({}, omit.apply(void 0, __spreadArray([props, "component", "platform"], __read(nextjsProps))), { ref: ref })));
    }
    if (props.platform === "gatsby" && isInternalHref(props.href)) {
        return React__default.createElement(props.component, __assign(__assign({}, omit(props, "component", "platform", "href")), { to: props.href, ref: ref }));
    }
    return React__default.createElement("a", __assign({}, omit(props, "component", "platform"), { ref: ref }));
});
function isInternalHref(href) {
    return /^\/(?!\/)/.test(href);
}

function PlasmicSlot(props) {
    return renderPlasmicSlot(props);
}
function renderPlasmicSlot(opts) {
    var as = opts.as, defaultContents = opts.defaultContents, value = opts.value, rest = __rest(opts, ["as", "defaultContents", "value"]);
    var content = value === undefined ? defaultContents : value;
    if (!content || (Array.isArray(content) && content.length === 0)) {
        return null;
    }
    // If the content is a raw string, then we need to wrap the raw string
    // into an element, in case the slot is inside a flex-gap
    // container (you cannot apply margin to just a text node).
    var maybeString = maybeAsString(content);
    if (maybeString) {
        content = React.createElement("div", { className: "__wab_slot-string-wrapper" }, maybeString);
    }
    var nonEmptyProps = Object.keys(rest).filter(function (p) { return !!rest[p]; });
    if (nonEmptyProps.length === 0) {
        // No attrs to apply to the slot (which means the slot is unstyled), then
        // just render the content directly; no need for style wrapper.
        return React.createElement(React.Fragment, null, content);
    }
    return React.createElement(as || "div", mergeProps({ className: "__wab_slot" }, rest), content);
}
function maybeAsString(node) {
    // Unwrap fragments
    if (React.isValidElement(node) &&
        // Fragment and Trans don't render DOM elements
        (node.type === React.Fragment || node.type === Trans)) {
        return maybeAsString(node.props.children);
    }
    if (typeof node === "string") {
        return node;
    }
    if (Array.isArray(node) && node.length === 1 && typeof node[0] === "string") {
        return node[0];
    }
    return undefined;
}

var listeners = [];
var queries = {};
function matchScreenVariants() {
    if (!isBrowser) {
        return [];
    }
    return Object.entries(queries)
        .filter(function (_a) {
        var _b = __read(_a, 2), query = _b[1];
        return window.matchMedia(query).matches;
    })
        .map(function (_a) {
        var _b = __read(_a, 1), name = _b[0];
        return name;
    });
}
// undefined if screen variants have never been calculated
var curScreenVariants = undefined;
function recalculateScreenVariants() {
    var screenVariant = matchScreenVariants();
    if (!curScreenVariants ||
        screenVariant.join("") !== curScreenVariants.join("")) {
        curScreenVariants = screenVariant;
        ReactDOM__default.unstable_batchedUpdates(function () {
            return listeners.forEach(function (listener) { return listener(); });
        });
    }
}
function ensureInitCurScreenVariants() {
    // Initializes curScreenVariants if it hadn't been before. Note that this must
    // be called from within an effect.
    if (curScreenVariants === undefined) {
        curScreenVariants = matchScreenVariants();
    }
}
if (isBrowser) {
    window.addEventListener("resize", recalculateScreenVariants);
}
function createUseScreenVariants(isMulti, screenQueries) {
    Object.assign(queries, screenQueries);
    curScreenVariants = undefined;
    return function () {
        // It is important that upon first render, we return [] or undefined, because
        // that is what SSR will use, and the client must match.  In an effect (which
        // only happens on the client), we then actually ask for the real screen variant
        // and, if different from [] or undefined, forces a re-render.
        var _a = __read(React.useState(), 2), updateState = _a[1];
        var lastScreenVariantsRef = React.useRef(curScreenVariants || []);
        // We do useLayoutEffect instead of useEffect to immediately
        // register our forceUpdate. This ensures that if there was
        // a window resize event between render and effects, that the
        // listener will be registered in time
        useIsomorphicLayoutEffect(function () {
            var updateIfChanged = function () {
                if (curScreenVariants &&
                    lastScreenVariantsRef.current.join("") !== curScreenVariants.join("")) {
                    lastScreenVariantsRef.current = curScreenVariants;
                    // Force update
                    updateState({});
                }
            };
            // Listeners are invoked whenever the window is resized
            listeners.push(updateIfChanged);
            // Initialize the curScreenVariants for the first time.  We don't need
            // to invoke the listeners here because all components will already
            // have this effect running and will re-render if the real screen
            // variant is non-empty.
            ensureInitCurScreenVariants();
            // Now, if the curScreenVariants differs from what we returned last,
            // then force a re-render.
            updateIfChanged();
            return function () {
                // Remove our listener on unmount
                listeners.splice(listeners.indexOf(updateIfChanged), 1);
            };
        }, []);
        if (isMulti) {
            return curScreenVariants || [];
        }
        else if (curScreenVariants) {
            return curScreenVariants[curScreenVariants.length - 1];
        }
        else {
            return undefined;
        }
    };
}

function useFocused(opts) {
    var _a = useFocusRing({
        within: false,
        isTextInput: opts.isTextInput,
    }), isFocused = _a.isFocused, focusProps = _a.focusProps;
    return [isFocused, focusProps];
}
function useFocusVisible(opts) {
    var _a = useFocusRing({
        within: false,
        isTextInput: opts.isTextInput,
    }), isFocusVisible = _a.isFocusVisible, focusProps = _a.focusProps;
    return [isFocusVisible, focusProps];
}
function useFocusedWithin(opts) {
    var _a = useFocusRing({
        within: true,
        isTextInput: opts.isTextInput,
    }), isFocused = _a.isFocused, focusProps = _a.focusProps;
    return [isFocused, focusProps];
}
function useFocusVisibleWithin(opts) {
    var _a = useFocusRing({
        within: true,
        isTextInput: opts.isTextInput,
    }), isFocusVisible = _a.isFocusVisible, focusProps = _a.focusProps;
    return [isFocusVisible, focusProps];
}
function useHover() {
    var _a = __read(React.useState(false), 2), isHover = _a[0], setHover = _a[1];
    return [
        isHover,
        {
            onMouseEnter: function () { return setHover(true); },
            onMouseLeave: function () { return setHover(false); },
        },
    ];
}
function usePressed() {
    var _a = __read(React.useState(false), 2), isPressed = _a[0], setPressed = _a[1];
    return [
        isPressed,
        {
            onMouseDown: function () { return setPressed(true); },
            onMouseUp: function () { return setPressed(false); },
        },
    ];
}
var TRIGGER_TO_HOOK = {
    useHover: useHover,
    useFocused: useFocused,
    useFocusVisible: useFocusVisible,
    useFocusedWithin: useFocusedWithin,
    useFocusVisibleWithin: useFocusVisibleWithin,
    usePressed: usePressed,
};
/**
 * Installs argment trigger. All the useTrigger calls must use hardcoded `trigger` arg,
 * as it's not valid to install variable React hooks!
 */
function useTrigger(trigger, opts) {
    return TRIGGER_TO_HOOK[trigger](opts);
}

// Utilities used by generated code
var classNames = classNames$1;

export { PlasmicIcon, PlasmicLink, PlasmicSlot, Stack, classNames, createPlasmicElementProxy, createUseScreenVariants, deriveRenderOpts, ensureGlobalVariants, hasVariant, makeFragment, mergeVariantsWithStates, renderPlasmicSlot, useTrigger, wrapWithClassName };
//# sourceMappingURL=index.js.map
