{"version":3,"file":"collection-utils-bf37b8fb.js","sources":["../../src/plume/collection-utils.tsx"],"sourcesContent":["/**\n * In general, we try not to expose react-aria's Collections API to Plume users.\n * The Collections API is how react-aria users pass data about collections of\n * things using the built-in Item and Section components, which are abstract,\n * metadata-only components that don't render anything but only serve to specify\n * data.  For example, here's how you would use react-spectrum's Picker:\n *\n *   <Picker>\n *     <Section title=\"Asia\">\n *       <Item key=\"taiwan\">Taiwan</Item>\n *       <Item key=\"japan\">Japan</Item>\n *       <Item key=\"china\">China</Item>\n *     </Section>\n *     <Section title=\"Europe\">\n *       <Item key=\"germany\">Germany</Item>\n *       <Item key=\"france\">France</Item>\n *     </Section>\n *   </Picker>\n *\n * You would re-use this same Item/Section components to pass similar things to\n * Menu, Tabs, etc.\n *\n * For Plasmic, this API is too abstract.  The user has explicitly designed components\n * like Select.Option and Select.OptionGroup, and it is weird that they don't actually\n * use these components. It is more natural to do:\n *\n *   <Select>\n *     <Select.OptionGroup title=\"Asia\">\n *       <Select.Option key=\"taiwan\">Taiwan</Select>\n *     </Select.OptionGroup>\n *   </Select>\n *\n * For Plume, we let users directly use the components they designed, both to collect\n * information and to perform actual rendering.  For example, for Plume,\n * you'd use Select.Option instead of Item, and Select.OptionGroup instead of Section.\n * This means that the Select.Option props will collect the same information Item\n * does.\n *\n * A component like Select.Option then serves two purposes:\n *\n * 1. Allow users to specify the collection of data, like in the above example\n *    Here, we're mainly interested in the props in those ReactElements so\n *    we can pass the Item/Section data onto react-aria's APIs.  We are not\n *    actually rendering these elements.\n * 2. Once react-aria's Collections API has gone through them and built\n *    Collection \"nodes\", we then create cloned versions of these elements\n *    with the corresponding node passed in as a secret prop.  These ReactElements\n *    are then actually used to _render_ the corresponding Option / OptionGroup.\n *\n * This file contains helper functions to help with implementing the above.\n *\n * Note also that most of the collections-based react-aria components expose\n * a parallel API that accepts a list of \"items\" and a render prop, instead\n * of list of Item/Section elements.  This is for efficiency, but we are opting\n * to only support the composite-component pattern for now for simplicity.\n */\n\nimport { Node } from \"@react-types/shared\";\nimport React from \"react\";\nimport { Item, Section } from \"@react-stately/collections\";\nimport { isString } from \"../common\";\nimport { getElementTypeName, toChildArray } from \"../react-utils\";\nimport { getPlumeType, PLUME_STRICT_MODE } from \"./plume-utils\";\n\nexport interface PlasmicLoaderProps<T> {\n  component: string;\n  componentProps: T;\n}\n\n/**\n * Props for a Plume component that corresponds to an Item\n */\nexport interface ItemLikeProps {\n  /**\n   * value key corresponding to this item. Not required if you use the\n   * `key` prop instead.\n   */\n  value?: string | null;\n\n  /**\n   * The text string value corresponding to this item. Used to support\n   * keyboard type-ahead.  If not specified, then will be derived from\n   * `children` if it is a string, or the `value` or `key`.\n   */\n  textValue?: string;\n\n  /**\n   * aria-label for this item.\n   */\n  \"aria-label\"?: string;\n\n  /**\n   * Primary content label for this item.\n   */\n  children?: React.ReactNode;\n\n  /**\n   * If true, this item will not be selectable.\n   */\n  isDisabled?: boolean;\n}\n\ntype LoaderAwareItemLikeProps =\n  | ItemLikeProps\n  | PlasmicLoaderProps<ItemLikeProps>;\n\n/**\n * Props for a Plume component that corresponds to a Section\n */\nexport interface SectionLikeProps {\n  /**\n   * Heading content of the title\n   */\n  title?: React.ReactNode;\n\n  /**\n   * aria-label for this section\n   */\n  \"aria-label\"?: string;\n\n  /**\n   * A list of items that belong in this group\n   */\n  children?: React.ReactNode;\n}\n\ntype LoaderAwareSectionLikeProps =\n  | SectionLikeProps\n  | PlasmicLoaderProps<SectionLikeProps>;\n\n/**\n * Given children of a component like Select or Menu, derive the items\n * that we will pass into the Collections API.  These will be\n * ReactElement<ItemLikeProps|SectionLikeProps>[].\n *\n * Will also assign keys to items by their index in the collection,\n * and collect the keys of disabled items.\n */\nexport function deriveItemsFromChildren<T extends React.ReactElement>(\n  children: React.ReactNode,\n  opts: {\n    itemPlumeType: string;\n    sectionPlumeType?: string;\n    invalidChildError?: string;\n    requireItemValue: boolean;\n  }\n) {\n  if (!children) {\n    return {\n      items: [] as T[],\n      disabledKeys: [] as React.Key[],\n    };\n  }\n\n  const { itemPlumeType, sectionPlumeType, invalidChildError } = opts;\n\n  // For Plume items without an explicit key, we assign a key as the index\n  // of the collection.\n  let itemCount = 0;\n  let sectionCount = 0;\n\n  const ensureValue = (element: React.ReactElement) => {\n    if (!propInChild(element, \"value\")) {\n      if (opts.requireItemValue && PLUME_STRICT_MODE) {\n        throw new Error(\n          `Must specify a \"value\" prop for ${getElementTypeName(element)}`\n        );\n      } else {\n        return cloneChild(element, { value: `${itemCount++}` });\n      }\n    } else {\n      // Still increment count even if key is present, so that the\n      // auto-assigned key really reflects the index\n      itemCount++;\n      return element;\n    }\n  };\n\n  const disabledKeys: React.Key[] = [];\n\n  const flattenedChildren = (\n    children: React.ReactNode\n  ): React.ReactElement[] => {\n    return toChildArray(children).flatMap((child) => {\n      if (React.isValidElement(child)) {\n        if (child.type === React.Fragment) {\n          return flattenedChildren(child.props.children);\n        }\n        const type = getPlumeType(child);\n        if (type === itemPlumeType) {\n          child = ensureValue(child);\n          const childKey = getItemLikeKey(child);\n          if (getChildProp(child, \"isDisabled\") && !!childKey) {\n            disabledKeys.push(childKey);\n          }\n          return [child];\n        }\n        if (type === sectionPlumeType) {\n          return [\n            cloneChild(child, {\n              // key of section doesn't actually matter, just needs\n              // to be unique\n              key: child.key ?? `section-${sectionCount++}`,\n              children: flattenedChildren(getChildProp(child, \"children\")),\n            }),\n          ];\n        }\n      }\n\n      if (PLUME_STRICT_MODE) {\n        throw new Error(invalidChildError ?? `Unexpected child`);\n      } else {\n        return [];\n      }\n    });\n  };\n\n  return { items: flattenedChildren(children) as T[], disabledKeys };\n}\n\nexport function useDerivedItemsFromChildren<T extends React.ReactElement>(\n  children: React.ReactNode,\n  opts: {\n    itemPlumeType: string;\n    sectionPlumeType?: string;\n    invalidChildError?: string;\n    requireItemValue: boolean;\n  }\n) {\n  const {\n    itemPlumeType,\n    sectionPlumeType,\n    invalidChildError,\n    requireItemValue,\n  } = opts;\n  return React.useMemo(() => {\n    return deriveItemsFromChildren<T>(children, {\n      itemPlumeType,\n      sectionPlumeType,\n      invalidChildError,\n      requireItemValue,\n    });\n  }, [\n    children,\n    itemPlumeType,\n    sectionPlumeType,\n    invalidChildError,\n    requireItemValue,\n  ]);\n}\n\n/**\n * Given a Collection node, create the React element that we should use\n * to render it.\n */\nexport function renderCollectionNode(node: Node<any>) {\n  // node.rendered should already have our item-like or section-like Plume\n  // component elements, so we just need to clone them with a secret\n  // _node prop that we use to render.\n  return cloneChild(node.rendered as React.ReactElement, {\n    _node: node,\n    key: node.key,\n  });\n}\n\n/**\n * Renders a item-like or section-like Plume component element into an\n * Item or a Section element.\n */\nexport function renderAsCollectionChild<\n  T extends React.ReactElement<\n    LoaderAwareItemLikeProps | LoaderAwareSectionLikeProps\n  >\n>(\n  child: T,\n  opts: {\n    itemPlumeType: string;\n    sectionPlumeType?: string;\n  }\n) {\n  const plumeType = getPlumeType(child);\n  if (plumeType === opts.itemPlumeType) {\n    const option = child as React.ReactElement<LoaderAwareItemLikeProps>;\n\n    // We look at the children passed to the item-like element, and derive key\n    // or textValue from it if it is a string\n    const content = getChildProp(option, \"children\");\n\n    // The children render prop needs to return an <Item/>\n    return (\n      <Item\n        // We use ItemLike.value if the user explicitly specified a value,\n        // and we fallback to key.  If the user specified neither, then\n        // the Collections API will generate a unique key for this item.\n        key={getItemLikeKey(option)}\n        // textValue is either explicitly specified by the user, or we\n        // try to derive it if `content` is a string.\n        textValue={\n          getChildProp(option, \"textValue\") ??\n          (isString(content)\n            ? content\n            : propInChild(option, \"value\")\n            ? getChildProp(option, \"value\")\n            : option.key)\n        }\n        aria-label={getChildProp(option, \"aria-label\")}\n      >\n        {\n          // Note that what we setting the item-like element as the children\n          // here, and not content; we want the entire item-like Plume element to\n          // end up as Node.rendered.\n        }\n        {option}\n      </Item>\n    );\n  } else {\n    const group = child as React.ReactElement<LoaderAwareSectionLikeProps>;\n    return (\n      <Section\n        // Note that we are using the whole section-like element as the title\n        // here, and not group.props.title; we want the entire section-like\n        // Plume element to end up as Node.rendered.\n        title={group}\n        aria-label={getChildProp(group, \"aria-label\")}\n        // We are flattening and deriving the descendant Options as items here.\n        // group.props.children should've already been cleaned up by\n        // deriveItemsFromChildren()\n        items={getChildProp(group, \"children\") as React.ReactElement[]}\n      >\n        {\n          // We use the same render function to turn descendent Options into Items\n        }\n        {(c: React.ReactElement) => renderAsCollectionChild(c, opts)}\n      </Section>\n    );\n  }\n}\n\nfunction getItemLikeKey(element: React.ReactElement<LoaderAwareItemLikeProps>) {\n  return getChildProp(element, \"value\") ?? element.key;\n}\n\n// PlasmicLoader-aware function to get prop from child.\nexport function getChildProp(child: React.ReactElement, prop: string) {\n  return \"componentProps\" in child.props\n    ? child.props.componentProps[prop]\n    : child.props[prop];\n}\n\n// PlasmicLoader-aware function to check `if (prop in element.props)`.\nfunction propInChild(child: React.ReactElement, prop: string): boolean {\n  return \"componentProps\" in child.props\n    ? prop in child.props.componentProps\n    : prop in child.props;\n}\n\n// PlasmicLoader-aware function to clone React element.\nfunction cloneChild(child: React.ReactElement, props: Record<string, any>) {\n  if ((child.type as any).getPlumeType) {\n    // If React element has getPlumeType(), assume that it is PlasmicLoader,\n    // so add nodeProps to componentProps instead of element props.\n    return React.cloneElement(child, {\n      componentProps: {\n        ...child.props.componentProps,\n        ...props,\n      },\n      ...(props.key ? { key: props.key } : {}),\n    });\n  }\n\n  return React.cloneElement(child, props);\n}\n"],"names":["React"],"mappings":"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"}