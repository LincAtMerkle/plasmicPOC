import classNames$1 from 'classnames';
import _get from 'dlv';
import * as React from 'react';
import React__default, { forwardRef, createElement, Fragment, isValidElement, useContext, createContext, useState, useRef, useMemo, useImperativeHandle, useCallback, cloneElement } from 'react';
import ReactDOM__default, { createPortal } from 'react-dom';
import { PlasmicDataSourceContextProvider } from '@plasmicapp/data-sources-context';
import { SSRProvider, useIsSSR as useIsSSR$1 } from '@react-aria/ssr';
import { useFocusRing, useFocusable, FocusScope } from '@react-aria/focus';
import { useCheckbox as useCheckbox$1 } from '@react-aria/checkbox';
import { VisuallyHidden } from '@react-aria/visually-hidden';
import { useToggleState } from '@react-stately/toggle';
import { useMenu as useMenu$1, useMenuSection, useMenuItem as useMenuItem$1, useMenuTrigger as useMenuTrigger$1 } from '@react-aria/menu';
import { useTreeState } from '@react-stately/tree';
import { Item, Section } from '@react-stately/collections';
import { useSeparator } from '@react-aria/separator';
import { useMenuTriggerState } from '@react-stately/menu';
import { usePress } from '@react-aria/interactions';
import { useSelect as useSelect$1, HiddenSelect } from '@react-aria/select';
import { useListBox, useOption, useListBoxSection } from '@react-aria/listbox';
import { useSelectState } from '@react-stately/select';
import { useSwitch as useSwitch$1 } from '@react-aria/switch';
import { useOverlay, useOverlayPosition, DismissButton } from '@react-aria/overlays';
import deepEqual from 'fast-deep-equal';
import { proxy, ref, useSnapshot } from 'valtio';
import { subscribeKey } from 'valtio/utils';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  it = o[Symbol.iterator]();
  return it.next.bind(it);
}

function notNil(x) {
  return x != null;
}
function pick(obj) {
  if (Object.keys(obj).length === 0) {
    return obj;
  }

  var res = {};

  for (var _len = arguments.length, keys = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    keys[_key - 1] = arguments[_key];
  }

  for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {
    var key = _keys[_i];

    if (key in obj) {
      res[key] = obj[key];
    }
  }

  return res;
}
function pickBy(obj, func) {
  var res = {};

  for (var _i2 = 0, _Object$entries = Object.entries(obj); _i2 < _Object$entries.length; _i2++) {
    var _Object$entries$_i = _Object$entries[_i2],
        key = _Object$entries$_i[0],
        val = _Object$entries$_i[1];

    if (func(key, val)) {
      res[key] = obj[key];
    }
  }

  return res;
}
function omit(obj) {
  if (Object.keys(obj).length === 0) {
    return obj;
  }

  var res = {};

  for (var _len2 = arguments.length, keys = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    keys[_key2 - 1] = arguments[_key2];
  }

  for (var _i3 = 0, _Object$keys = Object.keys(obj); _i3 < _Object$keys.length; _i3++) {
    var key = _Object$keys[_i3];

    if (!keys.includes(key)) {
      res[key] = obj[key];
    }
  }

  return res;
}
function isSubset(a1, a2) {
  return a1.every(function (x) {
    return a2.includes(x);
  });
}
function chainSingleArgFuncs() {
  for (var _len3 = arguments.length, funcs = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    funcs[_key3] = arguments[_key3];
  }

  if (funcs.length === 0) {
    return undefined;
  }

  return function (arg) {
    var res = arg;

    for (var _iterator = _createForOfIteratorHelperLoose(funcs), _step; !(_step = _iterator()).done;) {
      var func = _step.value;
      res = func(res);
    }

    return res;
  };
}
function isString(x) {
  return typeof x === "string";
}
function groupBy(collection, keyFunc) {
  var result = {};

  for (var _iterator2 = _createForOfIteratorHelperLoose(collection), _step2; !(_step2 = _iterator2()).done;) {
    var obj = _step2.value;
    var key = keyFunc(obj);

    if (key in result) {
      result[key].push(obj);
    } else {
      result[key] = [obj];
    }
  }

  return result;
}
function mapValues(obj, mapper) {
  var result = {};

  for (var key in obj) {
    result[key] = mapper(obj[key]);
  }

  return result;
}

var isBrowser = typeof window !== "undefined";
var NONE = /*#__PURE__*/Symbol("NONE");
var useIsomorphicLayoutEffect = isBrowser ? React__default.useLayoutEffect : React__default.useEffect;
function createElementWithChildren(elementType, props, children) {
  if (Array.isArray(children)) {
    return React__default.createElement.apply(React__default, [elementType, props].concat(children));
  } else if (children || "children" in props) {
    // Only call React.createElement with `children` if there are actual children,
    // or if there was an explicit (albeit undefined) children passed via
    // props.  Otherwise, if you pass `undefined` as the children argument
    // to React.createElement, the created element will have prop {children: undefined}.
    // If the `root` is an PlasmicGeneratedComponent, and these props with {children: undefined}
    // are used, then it will be taken as a `children` override, and will thus blank out
    // everything under the root node.
    return React__default.createElement(elementType, props, children);
  } else {
    return React__default.createElement(elementType, props);
  }
}
function ensureNotArray(children) {
  if (Array.isArray(children)) {
    if (children.length === 1) {
      return children[0];
    } else {
      return React__default.createElement.apply(React__default, [React__default.Fragment, {}].concat(children));
    }
  } else {
    return children;
  }
}
/**
 * Flattens ReactNode into an array of ReactChild, but does NOT replace
 * missing keys with array index, as React.Children.toArray() does.
 */

function toChildArray(children) {
  if (isReactChild(children)) {
    return [children];
  } else if (Array.isArray(children)) {
    return children.flatMap(toChildArray);
  } else {
    return [];
  }
}
function isReactText(child) {
  return typeof child === "string" || typeof child === "number";
}
function isReactChild(child) {
  return React__default.isValidElement(child) || isReactText(child);
}
function isReactNode(x) {
  return typeof x === "string" || typeof x === "number" || React__default.isValidElement(x);
}
function mergeProps(props) {
  for (var _len = arguments.length, restProps = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    restProps[_key - 1] = arguments[_key];
  }

  if (restProps.every(function (rest) {
    return Object.keys(rest).length === 0;
  })) {
    return props;
  }

  var result = _extends({}, props);

  for (var _i = 0, _restProps = restProps; _i < _restProps.length; _i++) {
    var rest = _restProps[_i];

    for (var _i2 = 0, _Object$keys = Object.keys(rest); _i2 < _Object$keys.length; _i2++) {
      var key = _Object$keys[_i2];
      result[key] = mergePropVals(key, result[key], rest[key]);
    }
  }

  return result;
}

function updateRef(ref, value) {
  if (!ref) {
    return;
  }

  if (typeof ref === "function") {
    ref(value);
  } else {
    if (!Object.isFrozen(ref)) {
      ref.current = value;
    }
  }
}

function mergeRefs() {
  for (var _len2 = arguments.length, refs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    refs[_key2] = arguments[_key2];
  }

  return function (value) {
    for (var _iterator = _createForOfIteratorHelperLoose(refs), _step; !(_step = _iterator()).done;) {
      var ref = _step.value;
      updateRef(ref, value);
    }
  };
}
function mergePropVals(name, val1, val2) {
  if (val1 === NONE || val2 === NONE) {
    // The NONE sentinel always skips all merging and returns null
    return null;
  } else if (val1 == null) {
    // If either of them is nil, prefer the other
    return val2;
  } else if (val2 == null) {
    return val1;
  } else if (name === "className") {
    // Special case for className -- always combine both class names
    return classNames$1(val1, val2);
  } else if (name === "style") {
    // Special case for style -- always shallow-merge style dicts
    return _extends({}, val1, val2);
  } else if (name === "ref") {
    // Special case for ref
    return mergeRefs(val1, val2);
  } else if (typeof val1 !== typeof val2) {
    // If the type of the two values are different, then no way to merge them.
    // Prefer val2.
    return val2;
  } else if (name.startsWith("on") && typeof val1 === "function") {
    // Special case for event handlers -- always call both handlers
    return function () {
      var res;

      if (typeof val1 === "function") {
        res = val1.apply(void 0, arguments);
      }

      if (typeof val2 === "function") {
        res = val2.apply(void 0, arguments);
      }

      return res;
    };
  } else {
    // For all else, prefer val2
    return val2;
  }
}
function getElementTypeName(element) {
  if (typeof element.type === "string") {
    return element.type;
  } else {
    var _ref, _ref2, _comp$displayName, _comp$render;

    var comp = element.type;
    return (_ref = (_ref2 = (_comp$displayName = comp.displayName) != null ? _comp$displayName : comp.name) != null ? _ref2 : (_comp$render = comp.render) == null ? void 0 : _comp$render.name) != null ? _ref : "Component";
  }
}

function renderStack(as, props, hasGap, ref) {
  var children = props.children,
      rest = _objectWithoutPropertiesLoose(props, ["children"]);

  var wrappedChildren = wrapFlexContainerChildren(children, hasGap != null ? hasGap : false);
  return createElementWithChildren(as, _extends({
    ref: ref
  }, rest), wrappedChildren);
}

function FlexStack_(props, outerRef) {
  var as = props.as,
      hasGap = props.hasGap,
      rest = _objectWithoutPropertiesLoose(props, ["as", "hasGap"]);

  return renderStack(as != null ? as : "div", rest, hasGap, outerRef);
}

var FlexStack = /*#__PURE__*/forwardRef(FlexStack_);

var makeStackImpl = function makeStackImpl(as) {
  return forwardRef(function (props, ref) {
    var hasGap = props.hasGap,
        rest = _objectWithoutPropertiesLoose(props, ["hasGap"]);

    return renderStack(as, rest, hasGap, ref);
  });
};

var Stack = /*#__PURE__*/Object.assign(FlexStack, {
  div: /*#__PURE__*/makeStackImpl("div"),
  a: /*#__PURE__*/makeStackImpl("a"),
  button: /*#__PURE__*/makeStackImpl("button"),
  h1: /*#__PURE__*/makeStackImpl("h1"),
  h2: /*#__PURE__*/makeStackImpl("h2"),
  h3: /*#__PURE__*/makeStackImpl("h3"),
  h4: /*#__PURE__*/makeStackImpl("h4"),
  h5: /*#__PURE__*/makeStackImpl("h5"),
  h6: /*#__PURE__*/makeStackImpl("h6"),
  label: /*#__PURE__*/makeStackImpl("label"),
  form: /*#__PURE__*/makeStackImpl("form"),
  section: /*#__PURE__*/makeStackImpl("section"),
  head: /*#__PURE__*/makeStackImpl("head"),
  main: /*#__PURE__*/makeStackImpl("main"),
  nav: /*#__PURE__*/makeStackImpl("nav")
});

function hasVariant(variants, groupName, variant) {
  if (variants == null) {
    return false;
  }

  var groupVariants = variants[groupName];

  if (groupVariants == null) {
    return false;
  } else if (groupVariants === true) {
    return variant === groupName;
  } else if (groupVariants === false) {
    return false;
  } else if (Array.isArray(groupVariants)) {
    return groupVariants.includes(variant);
  } else if (typeof groupVariants === "string") {
    return groupVariants === variant;
  } else {
    return groupVariants[variant] !== undefined && groupVariants[variant] !== false;
  }
}
function wrapFlexContainerChildren(children, hasGap) {
  // We need to always wrap the children, even if there are no gaps, because
  // otherwise if we toggle between with and without gap, React reconciliation
  // will blow away the children tree and all state if we switch from having
  // a wrapper and not.
  var className = hasGap ? "__wab_flex-container" : "__wab_passthrough";

  if (!children) {
    return null;
  } else if (Array.isArray(children)) {
    return createElement.apply(React, ["div", {
      className: className
    }].concat(children));
  } else {
    return createElement("div", {
      className: className
    }, children);
  }
}

function createPlasmicElement(override, defaultRoot, defaultProps, wrapChildrenInFlex) {
  if (!override || Object.keys(override).length === 0) {
    return createElementWithChildren(defaultRoot, defaultProps, defaultProps.children);
  }

  var override2 = deriveOverride(override);
  var props = mergeOverrideProps(defaultProps, override2.props);

  if (override2.type === "render") {
    return override2.render(props, defaultRoot);
  }

  var root = defaultRoot;

  if (override2.type === "as" && override2.as) {
    if (defaultRoot === Stack) {
      // If there was an "as" override specified, but the default type is
      // a Stack, then we don't want to switch to using "as" as the root,
      // because then we'd lose the flex wrapper that Stack provides.
      // Instead, we specify the "as" as the "as" prop to Stack.
      props.as = override2.as;
    } else {
      root = override2.as;
    }
  }

  var children = props.children;

  if (override2.wrapChildren) {
    children = override2.wrapChildren(ensureNotArray(children));
  }

  if (wrapChildrenInFlex) {
    // For legacy, we still support data-plasmic-wrap-flex-children
    children = wrapFlexContainerChildren(children, true);
  }

  var result = createElementWithChildren(root, props, children);

  if (override2.wrap) {
    result = override2.wrap(result);
  }

  return result;
} // We use data-plasmic-XXX attributes for custom properties since Typescript doesn't
// support type check on jsx pragma. See https://github.com/microsoft/TypeScript/issues/21699
// for more info.


var seenElements = /*#__PURE__*/new Map();
function createPlasmicElementProxy(defaultElement, props) {
  // We use seenElements to keep track of elements that has been rendered by
  // createPlasmicElementProxy().  When a JSX tree is evaluated, the JSX factory
  // is invoked from the leaf to the root as the last call.  So we can store
  // all the elements we've created until we encounter the leaf, at which point
  // we will clear this map.  We are guaranteed that this map will only contain
  // elements from one Plasmic* component at a time, because we're just creating
  // elements and not "rendering" at this point; even if this JSX tree references
  // other Plasmic* elements, we'll just create an element referencing that component,
  // rather than following into the content of that component.
  //
  // TODO: is this ConcurrentMode friendly?
  if (props == null) {
    props = {};
  }

  var name = props["data-plasmic-name"];
  var isRoot = props["data-plasmic-root"];
  var forNodeName = props["data-plasmic-for-node"];
  delete props["data-plasmic-name"];
  delete props["data-plasmic-root"];
  delete props["data-plasmic-for-node"];

  for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    children[_key - 2] = arguments[_key];
  }

  var element = createPlasmicElementFromJsx.apply(void 0, [defaultElement, props].concat(children));

  if (name) {
    seenElements.set(name, element);
  }

  if (isRoot) {
    var _seenElements$get;

    // If this is the root, and we requested a specific node by specifying data-plasmic-for-node,
    // then return that node instead
    var forNode = forNodeName ? (_seenElements$get = seenElements.get(forNodeName)) != null ? _seenElements$get : null : element; // Clear out the seenElements map, as we're done rendering this Plasmic* component.

    seenElements.clear();
    return forNode;
  }

  return element;
}

function createPlasmicElementFromJsx(defaultElement, props) {
  var _props$dataPlasmicT;

  var override = props["data-plasmic-override"];
  var wrapFlexChild = props["data-plasmic-wrap-flex-child"];
  var triggerProps = (_props$dataPlasmicT = props["data-plasmic-trigger-props"]) != null ? _props$dataPlasmicT : [];
  delete props["data-plasmic-override"];
  delete props["data-plasmic-wrap-flex-child"];
  delete props["data-plasmic-trigger-props"];

  for (var _len2 = arguments.length, children = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
    children[_key2 - 2] = arguments[_key2];
  }

  return createPlasmicElement(override, defaultElement, mergeProps.apply(void 0, [props, children.length === 0 ? {} : {
    children: children.length === 1 ? children[0] : children
  }].concat(triggerProps)), wrapFlexChild);
}

function makeFragment() {
  for (var _len3 = arguments.length, children = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    children[_key3] = arguments[_key3];
  }

  return createElement.apply(React, [Fragment, {}].concat(children));
}
var UNSET = /*#__PURE__*/Symbol("UNSET");

function mergeOverrideProps(defaults, overrides) {
  if (!overrides) {
    return defaults;
  }

  var result = _extends({}, defaults);

  for (var _i = 0, _Object$keys = Object.keys(overrides); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];
    var defaultVal = defaults[key];
    var overrideVal = overrides[key];

    if (overrideVal === UNSET) {
      delete result[key];
    } else {
      // We use the NONE sentinel if the overrideVal is nil, and is not one of the
      // props that we merge by default -- which are className, style, and
      // event handlers.  This means for all other "normal" props -- like children,
      // title, etc -- a nil value will unset the default.
      if (overrideVal == null && key !== "className" && key !== "style" && !(key.startsWith("on") && typeof defaultVal === "function")) {
        overrideVal = NONE;
      }

      result[key] = mergePropVals(key, defaultVal, overrideVal);
    }
  }

  return result;
}

function wrapWithClassName(element, className) {
  var key = isValidElement(element) ? element.key || undefined : undefined;
  return createElement("div", {
    key: key,
    className: className,
    style: {
      display: "grid"
    }
  }, element);
}

function deriveOverride(x) {
  if (!x) {
    // undefined Binding is an empty Binding
    return {
      type: "default",
      props: {}
    };
  } else if (isReactNode(x)) {
    // If ReactNode, then assume this is the children
    return {
      type: "default",
      props: {
        children: x
      }
    };
  } else if (typeof x === "object") {
    // If any of the overrideKeys is a key of this object, then assume
    // this is a full Override
    if ("as" in x) {
      return _extends({}, x, {
        props: x.props || {},
        type: "as"
      });
    } else if ("render" in x) {
      return _extends({}, x, {
        type: "render"
      });
    } else if ("props" in x) {
      return _extends({}, x, {
        props: x.props || {},
        type: "default"
      });
    } else if (isSubset(Object.keys(x), ["wrap", "wrapChildren"])) {
      // Only twiddling functions present, so assume no props overrides
      // (otherwise we'd assume these were props).
      return _extends({}, x, {
        props: {},
        type: "default"
      });
    } // Else, assume this is just a props object.


    return {
      type: "default",
      props: x
    };
  } else if (typeof x === "function") {
    return {
      type: "render",
      render: x
    };
  }

  throw new Error("Unexpected override: " + x);
}

function mergeVariants(v1, v2) {
  if (!v1 || !v2) {
    return v1 || v2 || {};
  }

  return _extends({}, v1, v2);
}

function mergeVariantsWithStates(variants, $state, linkedStates) {
  return _extends({}, variants, Object.fromEntries(linkedStates.map(function (_ref) {
    var variantGroup = _ref.variantGroup,
        statePath = _ref.statePath;
    return [variantGroup, _get($state, statePath)];
  })));
}

function mergeArgs(a1, a2) {
  if (!a1 || !a2) {
    return a1 || a2 || {};
  }

  return _extends({}, a1, a2);
}

function mergeFlexOverrides(o1, o2) {
  if (!o2) {
    return o1;
  }

  var keys = Array.from(new Set([].concat(Object.keys(o1), Object.keys(o2))));
  var merged = {};

  for (var _i2 = 0, _keys = keys; _i2 < _keys.length; _i2++) {
    var key = _keys[_i2];
    merged[key] = mergeFlexOverride(o1[key], o2[key]);
  }

  return merged;
}

function mergeFlexOverride(fo1, fo2) {
  var _o1$props, _ref2;

  if (!fo1) {
    return fo2;
  }

  if (!fo2) {
    return fo1;
  }

  var o1 = deriveOverride(fo1);
  var o2 = deriveOverride(fo2);
  var wrap = chainSingleArgFuncs.apply(void 0, [o1.wrap, o2.wrap].filter(notNil));
  var wrapChildren = chainSingleArgFuncs.apply(void 0, [o1.wrapChildren, o2.wrapChildren].filter(notNil)); // "render" type always takes precedence, but we still merge the props

  var props = mergeOverrideProps((_o1$props = o1.props) != null ? _o1$props : {}, o2.props);

  if (o2.type === "render") {
    return {
      render: o2.render,
      props: props,
      wrap: wrap,
      wrapChildren: wrapChildren
    };
  }

  if (o1.type === "render") {
    return {
      render: o1.render,
      props: props,
      wrap: wrap,
      wrapChildren: wrapChildren
    };
  } // "as" will take precedence


  var as = (_ref2 = o2.type === "as" ? o2.as : undefined) != null ? _ref2 : o1.type === "as" ? o1.as : undefined;
  return _extends({
    props: props,
    wrap: wrap,
    wrapChildren: wrapChildren
  }, as ? {
    as: as
  } : {});
}

function deriveRenderOpts(props, config) {
  var name = config.name,
      descendantNames = config.descendantNames,
      internalVariantPropNames = config.internalVariantPropNames,
      internalArgPropNames = config.internalArgPropNames;
  var reservedPropNames = ["variants", "args", "overrides"];
  var variants = mergeVariants(omit.apply(void 0, [pick.apply(void 0, [props].concat(internalVariantPropNames))].concat(reservedPropNames)), props.variants);
  var args = mergeArgs(omit.apply(void 0, [pick.apply(void 0, [props].concat(internalArgPropNames))].concat(reservedPropNames)), props.args);
  var overrides = mergeFlexOverrides(omit.apply(void 0, [pick.apply(void 0, [props].concat(descendantNames))].concat(internalArgPropNames, internalVariantPropNames, reservedPropNames)), props.overrides);
  var leftoverProps = omit.apply(void 0, [props, "variants", "args", "overrides"].concat(descendantNames, internalVariantPropNames, internalArgPropNames));

  if (Object.keys(leftoverProps).length > 0) {
    var _mergeFlexOverrides;

    overrides = mergeFlexOverrides(overrides, (_mergeFlexOverrides = {}, _mergeFlexOverrides[name] = {
      props: leftoverProps
    }, _mergeFlexOverrides));
  }

  return {
    variants: variants,
    args: args,
    overrides: overrides
  };
}

var isDefaultValue = function isDefaultValue(val) {
  return val === "PLEASE_RENDER_INSIDE_PROVIDER";
};

var seenDefaultVariants = {};
function ensureGlobalVariants(globalVariantValues) {
  Object.entries(globalVariantValues).filter(function (_ref) {
    var value = _ref[1];
    return isDefaultValue(value);
  }).forEach(function (_ref2) {
    var key = _ref2[0];
    globalVariantValues[key] = undefined;

    if (!seenDefaultVariants[key] && process.env.NODE_ENV === "development") {
      seenDefaultVariants[key] = true;
      var providerName = "" + key[0].toUpperCase() + key.substring(1) + "Context.Provider";
      console.warn("Plasmic context value for global variant \"" + key + "\" was not provided; please use " + providerName + " at the root of your React app. Learn More: https://www.plasmic.app/learn/other-assets/#global-variants");
    }
  });
  return globalVariantValues;
}

var PlasmicHeadContext = /*#__PURE__*/createContext(undefined);
function PlasmicHead(props) {
  var Head = useContext(PlasmicHeadContext);

  if (!Head) {
    console.warn("Plasmic: Head meta tags are being ignored. To make them work, pass a Head component into PlasmicRootProvider."); // TODO: Link to doc about Head.

    return null;
  } // Helmet does not support React.Fragments, so we need to use `[<meta />,
  // <meta />]` instead of `<><meta /><meta /></>`.


  return createElement(Head, null, props.image ? [createElement("meta", {
    key: "twitter:card",
    name: "twitter:card",
    content: "summary_large_image"
  }), createElement("meta", {
    key: "og:image",
    property: "og:image",
    content: props.image
  }), createElement("meta", {
    key: "twitter:image",
    name: "twitter:image",
    content: props.image
  })] : createElement("meta", {
    key: "twitter:card",
    name: "twitter:card",
    content: "summary"
  }), props.title && [createElement("title", {
    key: "title"
  }, props.title), createElement("meta", {
    key: "og:title",
    property: "og:title",
    content: props.title
  }), createElement("meta", {
    key: "twitter:title",
    property: "twitter:title",
    content: props.title
  })], props.description && [createElement("meta", {
    key: "description",
    name: "description",
    content: props.description
  }), createElement("meta", {
    key: "og:description",
    property: "og:description",
    content: props.description
  }), createElement("meta", {
    key: "twitter:description",
    name: "twitter:description",
    content: props.description
  })], props.canonical && createElement("link", {
    key: "canonical",
    ref: "canonical",
    href: props.canonical
  }));
}
var plasmicHeadMeta = {
  name: "hostless-plasmic-head",
  displayName: "Head",
  description: "Used to add page metadata to HTML <head />.",
  importName: "PlasmicHead",
  importPath: "@plasmicapp/react-web",
  isRepeatable: false,
  styleSections: false,
  props: {
    title: {
      type: "string",
      displayName: "Title"
    },
    description: {
      type: "string",
      displayName: "Description"
    },
    image: {
      type: "imageUrl",
      displayName: "Image"
    },
    canonical: {
      type: "string",
      displayName: "Canonical URL"
    }
  }
};

function PlasmicIcon(props) {
  var PlasmicIconType = props.PlasmicIconType,
      rest = _objectWithoutPropertiesLoose(props, ["PlasmicIconType"]);

  return createElement(PlasmicIconType, Object.assign({}, rest));
}

// TODO: make this configurable?

var IMG_SIZES = [16, 32, 48, 64, 96, 128, 256, 384];
var DEVICE_SIZES = [640, 750, 828, 1080, 1200, 1920, 2048, 3840];
var ALL_SIZES = /*#__PURE__*/[].concat(IMG_SIZES, DEVICE_SIZES);
var PlasmicImg = /*#__PURE__*/React__default.forwardRef(function PlasmicImg(props, outerRef) {
  var src = props.src,
      className = props.className,
      displayWidth = props.displayWidth,
      displayHeight = props.displayHeight,
      displayMinWidth = props.displayMinWidth,
      displayMinHeight = props.displayMinHeight,
      displayMaxWidth = props.displayMaxWidth,
      displayMaxHeight = props.displayMaxHeight,
      quality = props.quality,
      loader = props.loader,
      imgRef = props.imgRef,
      style = props.style,
      loading = props.loading,
      rest = _objectWithoutPropertiesLoose(props, ["src", "className", "displayWidth", "displayHeight", "displayMinWidth", "displayMinHeight", "displayMaxWidth", "displayMaxHeight", "quality", "loader", "imgRef", "style", "loading"]);

  var imgProps = Object.assign({}, rest, {
    // Default loading to "lazy" if not specified (which is different from the
    // html img, which defaults to eager!)
    loading: loading != null ? loading : "lazy"
  });

  var _ref = typeof src === "string" || !src ? {
    fullWidth: undefined,
    fullHeight: undefined,
    aspectRatio: undefined
  } : src,
      fullWidth = _ref.fullWidth,
      fullHeight = _ref.fullHeight,
      aspectRatio = _ref.aspectRatio;

  var srcStr = src ? typeof src === "string" ? src : typeof src.src === "string" ? src.src : src.src.src : ""; // Assume external image if either dimension is null and use usual <img>

  if (fullHeight == null || fullWidth == null) {
    return React__default.createElement("img", Object.assign({
      src: srcStr,
      className: className,
      style: style
    }, imgProps, {
      loading: loading,
      ref: mergeRefs(imgRef, outerRef)
    }));
  }

  if (isSvg(srcStr) && (displayHeight == null || displayHeight === "auto") && (displayWidth == null || displayWidth === "auto")) {
    displayWidth = "100%";
  }

  var computedDisplayWidth = displayWidth;

  if (fullWidth && fullHeight && (!displayWidth || displayWidth === "auto") && !!getPixelLength(displayHeight)) {
    // If there's a pixel length specified for displayHeight but not displayWidth,
    // then we can derive the pixel length for displayWidth.  Having an explicit
    // displayWidth makes this a fixed-size image, which makes it possible for us to
    // generate better markup!
    if (!isSvg(srcStr)) {
      // We shouldn't do it for SVGs though, because `fullWidth` and
      // `fullHeight` might have rounded values so the final
      // `displayWidth` could differ by 1px or so.
      computedDisplayWidth = getPixelLength(displayHeight) * fullWidth / fullHeight;
    }
  }

  var spacerWidth = fullWidth;
  var spacerHeight = fullHeight;

  if (aspectRatio && isFinite(aspectRatio) && isSvg(srcStr)) {
    // For SVGs, fullWidth and fullHeight can be rounded values, which would
    // cause some discrepancy between the actual aspect ratio and the aspect
    // ratio from those values. So, for those cases, we set large width / height
    // values to get a more precise ratio from the spacer.
    spacerWidth = DEFAULT_SVG_WIDTH;
    spacerHeight = Math.round(spacerWidth / aspectRatio);
  }

  var _getWidths = getWidths(computedDisplayWidth, fullWidth, {
    minWidth: displayMinWidth
  }),
      sizes = _getWidths.sizes,
      widthDescs = _getWidths.widthDescs;

  var imageLoader = getImageLoader(loader);
  var spacerSvg = "<svg width=\"" + spacerWidth + "\" height=\"" + spacerHeight + "\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"/>";
  var spacerSvgBase64 = typeof window === "undefined" ? Buffer.from(spacerSvg).toString("base64") : window.btoa(spacerSvg);

  var wrapperStyle = _extends({}, style || {});

  var spacerStyle = _extends({}, pick(style || {}, "objectFit", "objectPosition"));

  if (displayWidth != null && displayWidth !== "auto") {
    // If width is set, set it on the wrapper along with min/max width
    // and just use `width: 100%` on the spacer
    spacerStyle.width = "100%"; // Rely on the styles set by `classname` on the wrapper:
    // wrapperStyle.width = displayWidth;
    // wrapperStyle.minWidth = displayMinWidth;
    // wrapperStyle.maxWidth = displayMaxWidth;
  } else {
    // Otherwise, we want auto sizing from the spacer, so set width there.
    //
    // But if we have min/max width, it should be set in the wrapper and it
    // can be percentage values (and we add corresponding min/max width to
    // 100% in the spacer). In general it ends up with the correct effect,
    // but some edge cases might make `min-width: 100%` shrink the image more
    // than it should.
    spacerStyle.width = displayWidth;
    wrapperStyle.width = "auto";

    if (displayMinWidth) {
      spacerStyle.minWidth = "100%"; // Rely on min-width set by `classname` on the wrapper:
      // wrapperStyle.minWidth = displayMinWidth;
    }

    if (displayMaxWidth != null && displayMaxWidth !== "none") {
      spacerStyle.maxWidth = "100%"; // Rely on max-width set by `classname` on the wrapper:
      // wrapperStyle.maxWidth = displayMaxWidth;
    }
  }

  if (displayHeight != null && displayHeight !== "auto") {
    spacerStyle.height = "100%"; // wrapperStyle.height = displayHeight;
    // wrapperStyle.minHeight = displayMinHeight;
    // wrapperStyle.maxHeight = displayMaxHeight;
  } else {
    spacerStyle.height = displayHeight;
    wrapperStyle.height = "auto";

    if (displayMinHeight) {
      spacerStyle.minHeight = "100%"; // wrapperStyle.minHeight = displayMinHeight;
    }

    if (displayMaxHeight != null && displayMaxHeight !== "none") {
      spacerStyle.maxHeight = "100%"; // wrapperStyle.maxHeight = displayMaxHeight;
    }
  }

  return React__default.createElement("div", {
    className: classNames$1(className, "__wab_img-wrapper"),
    ref: outerRef,
    style: wrapperStyle
  }, React__default.createElement("img", {
    alt: "",
    "aria-hidden": true,
    className: "__wab_img-spacer-svg",
    src: "data:image/svg+xml;base64," + spacerSvgBase64,
    style: spacerStyle
  }), makePicture({
    imageLoader: imageLoader,
    widthDescs: widthDescs,
    sizes: sizes,
    src: srcStr,
    quality: quality,
    ref: imgRef,
    style: style ? pick(style, "objectFit", "objectPosition") : undefined,
    imgProps: imgProps,
    className: "__wab_img"
  }));
});

function makePicture(opts) {
  // If imageLoader is undefined, then this renders to just a normal
  // <img />.  Else it will render to a <picture> with a <source> for
  // webp, and srcSet/sizes set according to width requirements.
  var imageLoader = opts.imageLoader,
      widthDescs = opts.widthDescs,
      src = opts.src,
      quality = opts.quality,
      style = opts.style,
      className = opts.className,
      sizes = opts.sizes,
      imgProps = opts.imgProps,
      ref = opts.ref;
  return React__default.createElement("picture", {
    className: "__wab_picture"
  }, imageLoader && imageLoader.supportsUrl(src) && React__default.createElement("source", {
    type: "image/webp",
    srcSet: widthDescs.map(function (wd) {
      return imageLoader.transformUrl({
        src: src,
        quality: quality,
        width: wd.width,
        format: "webp"
      }) + " " + wd.desc;
    }).join(", ")
  }), React__default.createElement("img", Object.assign({}, imgProps, {
    ref: ref,
    className: className,
    decoding: "async",
    src: imageLoader && imageLoader.supportsUrl(src) ? imageLoader.transformUrl({
      src: src,
      quality: quality,
      width: widthDescs[widthDescs.length - 1].width
    }) : src,
    srcSet: imageLoader && imageLoader.supportsUrl(src) ? widthDescs.map(function (wd) {
      return imageLoader.transformUrl({
        src: src,
        quality: quality,
        width: wd.width
      }) + " " + wd.desc;
    }).join(", ") : undefined,
    sizes: imageLoader && imageLoader.supportsUrl(src) ? sizes : undefined,
    style: _extends({}, style ? pick(style, "objectFit", "objectPosition") : {}, {
      width: 0,
      height: 0
    })
  })));
}

var DEFAULT_SVG_WIDTH = 10000;

function isSvg(src) {
  return src.endsWith(".svg") || src.startsWith("data:image/svg");
}

function getClosestPresetSize(width, fullWidth) {
  var _ALL_SIZES$findIndex;

  var nextBiggerIndex = (_ALL_SIZES$findIndex = ALL_SIZES.findIndex(function (w) {
    return w >= width;
  })) != null ? _ALL_SIZES$findIndex : ALL_SIZES.length - 1;
  var nextBigger = ALL_SIZES[nextBiggerIndex];

  if (nextBigger >= fullWidth) {
    // If the requested width is larger than the fullWidth,
    // we just use the original width instead. It's impossible
    // to make an image bigger than fullWidth!
    return undefined;
  } else if (nextBiggerIndex + 1 < ALL_SIZES.length && fullWidth <= ALL_SIZES[nextBiggerIndex + 1]) {
    // If the fullWidth is just between nextBigger and the one after that,
    // then also might as well just use the original size (so, width is 30,
    // nextBigger is 32, then we just use the original as long as fullWidth is
    // less than 48)
    return undefined;
  }

  return nextBigger;
}
/**
 * Computes the appropriate srcSet and sizes to use
 */


function getWidths(width, fullWidth, extra) {
  var minWidth = extra == null ? void 0 : extra.minWidth;
  var pixelWidth = getPixelLength(width);
  var pixelMinWidth = getPixelLength(minWidth);

  if (pixelWidth != null && (!minWidth || pixelMinWidth != null)) {
    // If there's an exact width, then we just need to display it at 1x and 2x density
    return {
      widthDescs: [{
        width: getClosestPresetSize(Math.max(pixelWidth, pixelMinWidth != null ? pixelMinWidth : 0), fullWidth),
        desc: "1x"
      }, {
        width: getClosestPresetSize(Math.max(pixelWidth, pixelMinWidth != null ? pixelMinWidth : 0) * 2, fullWidth),
        desc: "2x"
      }],
      sizes: undefined
    };
  } // Otherwise we don't know what sizes we'll end up, so we just cap it at
  // device width.  TODO: do better!


  var usefulSizes = DEVICE_SIZES.filter(function (size) {
    return !fullWidth || size < fullWidth;
  });

  if (!!fullWidth && usefulSizes.length === 0) {
    // image fullWidth is smaller than all device sizes.  So all we can do
    // is offer 1x
    return {
      widthDescs: [{
        width: getClosestPresetSize(fullWidth, fullWidth),
        desc: "1x"
      }],
      sizes: undefined
    };
  }

  return {
    widthDescs: usefulSizes.map(function (size) {
      return {
        width: getClosestPresetSize(size, fullWidth),
        // If this is the last (buggest) useful width, but it is
        // still within the bounds set by DEVICE_SIZES, then just
        // use the original, unresized image.  This means if we match
        // the largest size, we use unresized and best quality image.
        // We only do this, though, if fullWidth is "reasonable" --
        // smaller than the largest size we would consider.
        // i === usefulSizes.length - 1 &&
        // fullWidth < DEVICE_SIZES[DEVICE_SIZES.length - 1]
        //   ? undefined
        //   : size,
        desc: size + "w"
      };
    }),
    sizes: "100vw"
  };
}

function getPixelLength(length) {
  if (length == null || length == "") {
    return undefined;
  }

  if (typeof length === "number") {
    return length;
  }

  var parsed = parseNumeric(length);

  if (parsed && (!parsed.units || parsed.units === "px")) {
    return parsed.num;
  }

  return undefined;
}

function parseNumeric(val) {
  // Parse strings like "30", "30px", "30%", "30px /* blah blah */"
  var res = val.match(/^\s*(-?(?:\d+\.\d*|\d*\.\d+|\d+))\s*([a-z]*|%)\s*(?:\/\*.*)?$/i);

  if (res == null) {
    return undefined;
  }

  var num = res[1];
  var units = res[2];
  return {
    num: +num,
    units: units
  };
}

function getImageLoader(loader) {
  if (loader == null) {
    return undefined;
  } else if (loader === "plasmic") {
    return PLASMIC_IMAGE_LOADER;
  } else {
    return loader;
  }
}

var PLASMIC_IMAGE_LOADER = {
  supportsUrl: function supportsUrl(src) {
    return src.startsWith("https://img.plasmic.app") && !isSvg(src);
  },
  transformUrl: function transformUrl(opts) {
    var _opts$quality;

    var params = [opts.width ? "w=" + opts.width : undefined, "q=" + ((_opts$quality = opts.quality) != null ? _opts$quality : 75), opts.format ? "f=" + opts.format : undefined].filter(function (x) {
      return !!x;
    });
    return opts.src + "?" + params.join("&");
  }
};

var PlasmicLink = /*#__PURE__*/React__default.forwardRef(function PlasmicLink(props, ref) {
  // props.href is required for nextjs; if no props.href,
  // then we just render the default anchor element
  if (props.platform === "nextjs" && props.href) {
    var nextjsProps = ["href", "replace", "scroll", "shallow", "passHref", "prefetch", "locale"];
    return React__default.createElement(props.component, pick.apply(void 0, [props].concat(nextjsProps)), React__default.createElement("a", Object.assign({}, omit.apply(void 0, [props, "component", "platform"].concat(nextjsProps)), {
      ref: ref
    })));
  }

  if (props.platform === "gatsby" && isInternalHref(props.href)) {
    return React__default.createElement(props.component, _extends({}, omit(props, "component", "platform", "href"), {
      to: props.href,
      ref: ref
    }));
  }

  return React__default.createElement("a", Object.assign({}, omit(props, "component", "platform"), {
    ref: ref
  }));
});

function isInternalHref(href) {
  return /^\/(?!\/)/.test(href);
}

var PlasmicTranslatorContext = /*#__PURE__*/React__default.createContext(undefined);

function isIterable(val) {
  return val != null && typeof val[Symbol.iterator] === "function";
}

function genTranslatableString(elt) {
  var components = {};
  var componentsCount = 0;

  var getText = function getText(node) {
    if (!node) {
      return "";
    }

    if (typeof node === "number" || typeof node === "boolean" || typeof node === "string") {
      return node.toString();
    }

    if (typeof node !== "object") {
      return "";
    }

    if (Array.isArray(node) || isIterable(node)) {
      return Array.from(node).map(function (child) {
        return getText(child);
      }).filter(function (child) {
        return !!child;
      }).join("");
    }

    var nodeChildren = hasKey(node, "props") && hasKey(node.props, "children") && node.props.children || hasKey(node, "children") && node.children || [];
    var contents = "" + React__default.Children.toArray(nodeChildren).map(function (child) {
      return getText(child);
    }).filter(function (child) {
      return !!child;
    }).join("");

    if (React__default.isValidElement(node) && node.type === React__default.Fragment) {
      return contents;
    }

    var componentId = componentsCount + 1;
    componentsCount++;
    components[componentId] = React__default.isValidElement(node) ? React__default.cloneElement(node, {
      key: componentId,
      children: undefined
    }) : node;
    return "<" + componentId + ">" + contents + "</" + componentId + ">";
  };

  var str = getText(elt);
  return {
    str: str,
    components: components,
    componentsCount: componentsCount
  };
}
function Trans(_ref) {
  var children = _ref.children;

  var _t = React__default.useContext(PlasmicTranslatorContext);

  if (!_t) {
    warnNoTranslationFunctionAtMostOnce();
    return children;
  }

  var _genTranslatableStrin = genTranslatableString(children),
      str = _genTranslatableStrin.str,
      components = _genTranslatableStrin.components,
      componentsCount = _genTranslatableStrin.componentsCount;

  return _t(str, componentsCount > 0 ? {
    components: components
  } : undefined);
}
var hasWarned = false;

function warnNoTranslationFunctionAtMostOnce() {
  if (!hasWarned) {
    console.warn("Using Plasmic Translation but no translation function has been provided");
    hasWarned = true;
  }
}

function hasKey(v, key) {
  return typeof v === "object" && v !== null && key in v;
}

function PlasmicSlot(props) {
  return renderPlasmicSlot(props);
}
function renderPlasmicSlot(opts) {
  var as = opts.as,
      defaultContents = opts.defaultContents,
      value = opts.value,
      rest = _objectWithoutPropertiesLoose(opts, ["as", "defaultContents", "value"]);

  var content = value === undefined ? defaultContents : value;

  if (!content || Array.isArray(content) && content.length === 0) {
    return null;
  } // If the content is a raw string, then we need to wrap the raw string
  // into an element, in case the slot is inside a flex-gap
  // container (you cannot apply margin to just a text node).


  var maybeString = maybeAsString(content);

  if (maybeString) {
    content = createElement("div", {
      className: "__wab_slot-string-wrapper"
    }, maybeString);
  }

  var nonEmptyProps = Object.keys(rest).filter(function (p) {
    return !!rest[p];
  });

  if (nonEmptyProps.length === 0) {
    // No attrs to apply to the slot (which means the slot is unstyled), then
    // just render the content directly; no need for style wrapper.
    return createElement(Fragment, null, content);
  }

  return createElement(as || "div", mergeProps({
    className: "__wab_slot"
  }, rest), content);
}

function maybeAsString(node) {
  // Unwrap fragments
  if (isValidElement(node) && ( // Fragment and Trans don't render DOM elements
  node.type === Fragment || node.type === Trans)) {
    return maybeAsString(node.props.children);
  }

  if (typeof node === "string") {
    return node;
  }

  if (Array.isArray(node) && node.length === 1 && typeof node[0] === "string") {
    return node[0];
  }

  return undefined;
}

var listeners = [];
var queries = {};

function matchScreenVariants() {
  if (!isBrowser) {
    return [];
  }

  return Object.entries(queries).filter(function (_ref) {
    var query = _ref[1];
    return window.matchMedia(query).matches;
  }).map(function (_ref2) {
    var name = _ref2[0];
    return name;
  });
} // undefined if screen variants have never been calculated


var curScreenVariants = undefined;

function recalculateScreenVariants() {
  var screenVariant = matchScreenVariants();

  if (!curScreenVariants || screenVariant.join("") !== curScreenVariants.join("")) {
    curScreenVariants = screenVariant;
    ReactDOM__default.unstable_batchedUpdates(function () {
      return listeners.forEach(function (listener) {
        return listener();
      });
    });
  }
}

function ensureInitCurScreenVariants() {
  // Initializes curScreenVariants if it hadn't been before. Note that this must
  // be called from within an effect.
  if (curScreenVariants === undefined) {
    curScreenVariants = matchScreenVariants();
  }
}

if (isBrowser) {
  window.addEventListener("resize", recalculateScreenVariants);
}

function createUseScreenVariants(isMulti, screenQueries) {
  Object.assign(queries, screenQueries);
  curScreenVariants = undefined;
  return function () {
    // It is important that upon first render, we return [] or undefined, because
    // that is what SSR will use, and the client must match.  In an effect (which
    // only happens on the client), we then actually ask for the real screen variant
    // and, if different from [] or undefined, forces a re-render.
    var _React$useState = useState(),
        updateState = _React$useState[1];

    var lastScreenVariantsRef = useRef(curScreenVariants || []); // We do useLayoutEffect instead of useEffect to immediately
    // register our forceUpdate. This ensures that if there was
    // a window resize event between render and effects, that the
    // listener will be registered in time

    useIsomorphicLayoutEffect(function () {
      var updateIfChanged = function updateIfChanged() {
        if (curScreenVariants && lastScreenVariantsRef.current.join("") !== curScreenVariants.join("")) {
          lastScreenVariantsRef.current = curScreenVariants; // Force update

          updateState({});
        }
      }; // Listeners are invoked whenever the window is resized


      listeners.push(updateIfChanged); // Initialize the curScreenVariants for the first time.  We don't need
      // to invoke the listeners here because all components will already
      // have this effect running and will re-render if the real screen
      // variant is non-empty.

      ensureInitCurScreenVariants(); // Now, if the curScreenVariants differs from what we returned last,
      // then force a re-render.

      updateIfChanged();
      return function () {
        // Remove our listener on unmount
        listeners.splice(listeners.indexOf(updateIfChanged), 1);
      };
    }, []);

    if (isMulti) {
      return curScreenVariants || [];
    } else if (curScreenVariants) {
      return curScreenVariants[curScreenVariants.length - 1];
    } else {
      return undefined;
    }
  };
}

var PlasmicRootContext = /*#__PURE__*/createContext(undefined);
function PlasmicRootProvider(props) {
  var platform = props.platform,
      children = props.children,
      userAuthToken = props.userAuthToken;
  var context = useMemo(function () {
    return {
      platform: platform
    };
  }, [platform]);
  var dataSourceContextValue = useMemo(function () {
    return {
      userAuthToken: userAuthToken
    };
  }, [userAuthToken]);
  return createElement(PlasmicRootContext.Provider, {
    value: context
  }, createElement(SSRProvider, null, createElement(PlasmicDataSourceContextProvider, {
    value: dataSourceContextValue
  }, createElement(PlasmicTranslatorContext.Provider, {
    value: props.translator
  }, createElement(PlasmicHeadContext.Provider, {
    value: props.Head
  }, children)))));
}
var useIsSSR = useIsSSR$1;
function useHasPlasmicRoot() {
  return !!useContext(PlasmicRootContext);
}
var hasWarnedSSR = false;
/**
 * Warns the user if PlasmicRootProvider is not used
 */

function useEnsureSSRProvider() {
  var hasRoot = useHasPlasmicRoot();

  if (hasRoot || hasWarnedSSR || process.env.NODE_ENV !== "development") {
    return;
  }

  hasWarnedSSR = true;
  console.warn("Plasmic: To ensure your components work correctly with server-side rendering, please use PlasmicRootProvider at the root of your application.  See https://docs.plasmic.app/learn/ssr");
}

function useFocused(opts) {
  var _useAriaFocusRing = useFocusRing({
    within: false,
    isTextInput: opts.isTextInput
  }),
      isFocused = _useAriaFocusRing.isFocused,
      focusProps = _useAriaFocusRing.focusProps;

  return [isFocused, focusProps];
}

function useFocusVisible(opts) {
  var _useAriaFocusRing2 = useFocusRing({
    within: false,
    isTextInput: opts.isTextInput
  }),
      isFocusVisible = _useAriaFocusRing2.isFocusVisible,
      focusProps = _useAriaFocusRing2.focusProps;

  return [isFocusVisible, focusProps];
}

function useFocusedWithin(opts) {
  var _useAriaFocusRing3 = useFocusRing({
    within: true,
    isTextInput: opts.isTextInput
  }),
      isFocused = _useAriaFocusRing3.isFocused,
      focusProps = _useAriaFocusRing3.focusProps;

  return [isFocused, focusProps];
}

function useFocusVisibleWithin(opts) {
  var _useAriaFocusRing4 = useFocusRing({
    within: true,
    isTextInput: opts.isTextInput
  }),
      isFocusVisible = _useAriaFocusRing4.isFocusVisible,
      focusProps = _useAriaFocusRing4.focusProps;

  return [isFocusVisible, focusProps];
}

function useHover() {
  var _React$useState = useState(false),
      isHover = _React$useState[0],
      setHover = _React$useState[1];

  return [isHover, {
    onMouseEnter: function onMouseEnter() {
      return setHover(true);
    },
    onMouseLeave: function onMouseLeave() {
      return setHover(false);
    }
  }];
}

function usePressed() {
  var _React$useState2 = useState(false),
      isPressed = _React$useState2[0],
      setPressed = _React$useState2[1];

  return [isPressed, {
    onMouseDown: function onMouseDown() {
      return setPressed(true);
    },
    onMouseUp: function onMouseUp() {
      return setPressed(false);
    }
  }];
}

var TRIGGER_TO_HOOK = {
  useHover: useHover,
  useFocused: useFocused,
  useFocusVisible: useFocusVisible,
  useFocusedWithin: useFocusedWithin,
  useFocusVisibleWithin: useFocusVisibleWithin,
  usePressed: usePressed
};
/**
 * Installs argment trigger. All the useTrigger calls must use hardcoded `trigger` arg,
 * as it's not valid to install variable React hooks!
 */

function useTrigger(trigger, opts) {
  return TRIGGER_TO_HOOK[trigger](opts);
}

// Utilities used by generated code
var classNames = classNames$1;

var PLUME_STRICT_MODE = true;
function setPlumeStrictMode(mode) {
  PLUME_STRICT_MODE = mode;
}
function mergeVariantToggles() {
  for (var _len = arguments.length, toggles = new Array(_len), _key = 0; _key < _len; _key++) {
    toggles[_key] = arguments[_key];
  }

  var definedToggles = toggles.filter(function (x) {
    return !!x.def;
  });
  var grouped = groupBy(definedToggles, function (_ref) {
    var def = _ref.def;
    return def.group;
  });
  return mapValues(grouped, function (subToggles) {
    return Object.fromEntries(subToggles.map(function (_ref2) {
      var def = _ref2.def,
          active = _ref2.active;
      return [def.variant, !!active];
    }));
  });
}
function noOutline() {
  return {
    outline: "none"
  };
}
function getPlumeType(child) {
  if (!isValidElement(child)) {
    return undefined;
  }

  var childType = child.type;
  return childType.__plumeType || (childType.getPlumeType == null ? void 0 : childType.getPlumeType(child.props));
}

function useButton(plasmicClass, props, config, ref) {
  var _ref, _ref2, _extends2, _overrides;

  if (ref === void 0) {
    ref = null;
  }

  var link = props.link,
      isDisabled = props.isDisabled,
      startIcon = props.startIcon,
      endIcon = props.endIcon,
      showStartIcon = props.showStartIcon,
      showEndIcon = props.showEndIcon,
      children = props.children,
      rest = _objectWithoutPropertiesLoose(props, ["link", "isDisabled", "startIcon", "endIcon", "showStartIcon", "showEndIcon", "children"]);

  var variants = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalVariantProps)), mergeVariantToggles({
    def: config.showStartIconVariant,
    active: showStartIcon
  }, {
    def: config.showEndIconVariant,
    active: showEndIcon
  }, {
    def: config.isDisabledVariant,
    active: isDisabled
  }));

  var args = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalArgProps)), config.startIconSlot && (_ref = {}, _ref[config.startIconSlot] = startIcon, _ref), config.endIconSlot && (_ref2 = {}, _ref2[config.endIconSlot] = endIcon, _ref2), (_extends2 = {}, _extends2[config.contentSlot] = children, _extends2));

  var overrides = (_overrides = {}, _overrides[config.root] = {
    as: !!link ? "a" : "button",
    props: _extends({}, omit.apply(void 0, [rest].concat(plasmicClass.internalArgProps, plasmicClass.internalVariantProps)), {
      ref: ref,
      disabled: isDisabled
    }, !!link && {
      href: link
    })
  }, _overrides);
  return {
    plasmicProps: {
      variants: variants,
      args: args,
      overrides: overrides
    }
  };
}

function getStyleProps(props) {
  return pick(props, "className", "style");
}
function getDefaultPlasmicProps(plasmicClass, props) {
  return {
    plasmicProps: {
      variants: pick.apply(void 0, [props].concat(plasmicClass.internalVariantProps)),
      args: pick.apply(void 0, [props].concat(plasmicClass.internalArgProps)),
      overrides: {}
    }
  };
}
var RE_DATA_PROP = /^(data-.*)$/;
function getDataProps(props) {
  return pickBy(props, function (k) {
    return RE_DATA_PROP.test(k);
  });
}

function asAriaCheckboxProps(props) {
  var ariaProps = _extends({}, props, {
    isSelected: props.isChecked,
    defaultSelected: props.defaultChecked
  });

  delete ariaProps["isChecked"];
  delete ariaProps["defaultChecked"];
  return ariaProps;
}

function useCheckbox(plasmicClass, props, config, ref) {
  var _overrides, _ref;

  if (ref === void 0) {
    ref = null;
  }

  var children = props.children,
      isDisabled = props.isDisabled,
      isIndeterminate = props.isIndeterminate;
  useEnsureSSRProvider();
  var inputRef = useRef(null);
  var rootRef = useRef(null);
  var ariaProps = asAriaCheckboxProps(props);
  var state = useToggleState(ariaProps);

  var _useAriaCheckbox = useCheckbox$1(ariaProps, state, inputRef),
      inputProps = _useAriaCheckbox.inputProps;

  var variants = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalVariantProps)), mergeVariantToggles({
    def: config.isDisabledVariant,
    active: isDisabled
  }, {
    def: config.isCheckedVariant,
    active: state.isSelected
  }, {
    def: config.isIndeterminateVariant,
    active: isIndeterminate
  }, {
    def: config.noLabelVariant,
    active: !children
  }));

  var overrides = (_overrides = {}, _overrides[config.root] = {
    as: "label",
    props: mergeProps(getStyleProps(props), {
      ref: rootRef
    }),
    wrapChildren: function wrapChildren(children) {
      return createElement(Fragment, null, createElement(VisuallyHidden, {
        isFocusable: true
      }, createElement("input", Object.assign({}, inputProps, {
        ref: inputRef
      }))), children);
    }
  }, _overrides);

  var args = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalArgProps)), config.labelSlot ? (_ref = {}, _ref[config.labelSlot] = children, _ref) : {});

  var plumeState = useMemo(function () {
    return {
      setChecked: function setChecked(checked) {
        return state.setSelected(checked);
      }
    };
  }, [state]);
  useImperativeHandle(ref, function () {
    return {
      getRoot: function getRoot() {
        return rootRef.current;
      },
      focus: function focus() {
        var _inputRef$current;

        return (_inputRef$current = inputRef.current) == null ? void 0 : _inputRef$current.focus();
      },
      blur: function blur() {
        var _inputRef$current2;

        return (_inputRef$current2 = inputRef.current) == null ? void 0 : _inputRef$current2.blur();
      },
      setChecked: function setChecked(checked) {
        return plumeState.setChecked(checked);
      }
    };
  }, [rootRef, inputRef, plumeState]);
  return {
    plasmicProps: {
      variants: variants,
      overrides: overrides,
      args: args
    },
    state: plumeState
  };
}

/**
 * Given children of a component like Select or Menu, derive the items
 * that we will pass into the Collections API.  These will be
 * ReactElement<ItemLikeProps|SectionLikeProps>[].
 *
 * Will also assign keys to items by their index in the collection,
 * and collect the keys of disabled items.
 */

function deriveItemsFromChildren(children, opts) {
  if (!children) {
    return {
      items: [],
      disabledKeys: []
    };
  }

  var itemPlumeType = opts.itemPlumeType,
      sectionPlumeType = opts.sectionPlumeType,
      invalidChildError = opts.invalidChildError; // For Plume items without an explicit key, we assign a key as the index
  // of the collection.

  var itemCount = 0;
  var sectionCount = 0;

  var ensureValue = function ensureValue(element) {
    if (!propInChild(element, "value")) {
      if (opts.requireItemValue && PLUME_STRICT_MODE) {
        throw new Error("Must specify a \"value\" prop for " + getElementTypeName(element));
      } else {
        return cloneChild(element, {
          value: "" + itemCount++
        });
      }
    } else {
      // Still increment count even if key is present, so that the
      // auto-assigned key really reflects the index
      itemCount++;
      return element;
    }
  };

  var disabledKeys = [];

  var flattenedChildren = function flattenedChildren(children) {
    return toChildArray(children).flatMap(function (child) {
      if (React__default.isValidElement(child)) {
        if (child.type === React__default.Fragment) {
          return flattenedChildren(child.props.children);
        }

        var type = getPlumeType(child);

        if (type === itemPlumeType) {
          child = ensureValue(child);
          var childKey = getItemLikeKey(child);

          if (getChildProp(child, "isDisabled") && !!childKey) {
            disabledKeys.push(childKey);
          }

          return [child];
        }

        if (type === sectionPlumeType) {
          var _child$key;

          return [cloneChild(child, {
            // key of section doesn't actually matter, just needs
            // to be unique
            key: (_child$key = child.key) != null ? _child$key : "section-" + sectionCount++,
            children: flattenedChildren(getChildProp(child, "children"))
          })];
        }
      }

      if (PLUME_STRICT_MODE) {
        throw new Error(invalidChildError != null ? invalidChildError : "Unexpected child");
      } else {
        return [];
      }
    });
  };

  return {
    items: flattenedChildren(children),
    disabledKeys: disabledKeys
  };
}
function useDerivedItemsFromChildren(children, opts) {
  var itemPlumeType = opts.itemPlumeType,
      sectionPlumeType = opts.sectionPlumeType,
      invalidChildError = opts.invalidChildError,
      requireItemValue = opts.requireItemValue;
  return React__default.useMemo(function () {
    return deriveItemsFromChildren(children, {
      itemPlumeType: itemPlumeType,
      sectionPlumeType: sectionPlumeType,
      invalidChildError: invalidChildError,
      requireItemValue: requireItemValue
    });
  }, [children, itemPlumeType, sectionPlumeType, invalidChildError, requireItemValue]);
}
/**
 * Given a Collection node, create the React element that we should use
 * to render it.
 */

function renderCollectionNode(node) {
  // node.rendered should already have our item-like or section-like Plume
  // component elements, so we just need to clone them with a secret
  // _node prop that we use to render.
  return cloneChild(node.rendered, {
    _node: node,
    key: node.key
  });
}
/**
 * Renders a item-like or section-like Plume component element into an
 * Item or a Section element.
 */

function renderAsCollectionChild(child, opts) {
  var plumeType = getPlumeType(child);

  if (plumeType === opts.itemPlumeType) {
    var _getChildProp;

    var option = child; // We look at the children passed to the item-like element, and derive key
    // or textValue from it if it is a string

    var content = getChildProp(option, "children"); // The children render prop needs to return an <Item/>

    return React__default.createElement(Item // We use ItemLike.value if the user explicitly specified a value,
    // and we fallback to key.  If the user specified neither, then
    // the Collections API will generate a unique key for this item.
    , {
      // We use ItemLike.value if the user explicitly specified a value,
      // and we fallback to key.  If the user specified neither, then
      // the Collections API will generate a unique key for this item.
      key: getItemLikeKey(option),
      // textValue is either explicitly specified by the user, or we
      // try to derive it if `content` is a string.
      textValue: (_getChildProp = getChildProp(option, "textValue")) != null ? _getChildProp : isString(content) ? content : propInChild(option, "value") ? getChildProp(option, "value") : option.key,
      "aria-label": getChildProp(option, "aria-label")
    }, option);
  } else {
    var group = child;
    return React__default.createElement(Section // Note that we are using the whole section-like element as the title
    // here, and not group.props.title; we want the entire section-like
    // Plume element to end up as Node.rendered.
    , {
      // Note that we are using the whole section-like element as the title
      // here, and not group.props.title; we want the entire section-like
      // Plume element to end up as Node.rendered.
      title: group,
      "aria-label": getChildProp(group, "aria-label"),
      // We are flattening and deriving the descendant Options as items here.
      // group.props.children should've already been cleaned up by
      // deriveItemsFromChildren()
      items: getChildProp(group, "children")
    }, function (c) {
      return renderAsCollectionChild(c, opts);
    });
  }
}

function getItemLikeKey(element) {
  var _getChildProp2;

  return (_getChildProp2 = getChildProp(element, "value")) != null ? _getChildProp2 : element.key;
} // PlasmicLoader-aware function to get prop from child.


function getChildProp(child, prop) {
  return "componentProps" in child.props ? child.props.componentProps[prop] : child.props[prop];
} // PlasmicLoader-aware function to check `if (prop in element.props)`.

function propInChild(child, prop) {
  return "componentProps" in child.props ? prop in child.props.componentProps : prop in child.props;
} // PlasmicLoader-aware function to clone React element.


function cloneChild(child, props) {
  if (child.type.getPlumeType) {
    // If React element has getPlumeType(), assume that it is PlasmicLoader,
    // so add nodeProps to componentProps instead of element props.
    return React__default.cloneElement(child, _extends({
      componentProps: _extends({}, child.props.componentProps, props)
    }, props.key ? {
      key: props.key
    } : {}));
  }

  return React__default.cloneElement(child, props);
}

var TriggeredOverlayContext = /*#__PURE__*/createContext(undefined);

var MenuContext = /*#__PURE__*/createContext(undefined);

var COLLECTION_OPTS = {
  itemPlumeType: "menu-item",
  sectionPlumeType: "menu-group"
};
/**
 * Converts props from BaseMenuProps to react-aria's useMenu() props.
 */

function asAriaMenuProps(props) {
  var children = props.children,
      rest = _objectWithoutPropertiesLoose(props, ["children"]);

  var _useDerivedItemsFromC = useDerivedItemsFromChildren(children, _extends({}, COLLECTION_OPTS, {
    invalidChildError: "Can only use Menu.Item and Menu.Group as children to Menu",
    requireItemValue: false
  })),
      items = _useDerivedItemsFromC.items,
      disabledKeys = _useDerivedItemsFromC.disabledKeys;

  var collectionChildRenderer = useCallback(function (child) {
    return renderAsCollectionChild(child, COLLECTION_OPTS);
  }, []);
  return {
    ariaProps: _extends({}, rest, {
      children: collectionChildRenderer,
      items: items,
      disabledKeys: disabledKeys
    })
  };
}

function useMenu(plasmicClass, props, config, ref) {
  var _overrides, _extends2;

  if (ref === void 0) {
    ref = null;
  }

  useEnsureSSRProvider();

  var _asAriaMenuProps = asAriaMenuProps(props),
      ariaProps = _asAriaMenuProps.ariaProps;

  var triggerContext = useContext(TriggeredOverlayContext);
  var rootRef = useRef(null);
  var state = useTreeState(ariaProps);
  var menuListRef = useRef(null);

  var _useAriaMenu = useMenu$1(_extends({}, ariaProps, {
    autoFocus: triggerContext == null ? void 0 : triggerContext.autoFocus
  }), state, menuListRef),
      menuProps = _useAriaMenu.menuProps;

  var contextValue = useMemo(function () {
    return {
      state: state,
      menuProps: props
    };
  }, [state, props]);

  var variants = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalVariantProps)));

  var overrides = (_overrides = {}, _overrides[config.root] = {
    props: mergeProps(getStyleProps(props), {
      ref: rootRef
    })
  }, _overrides[config.itemsContainer] = {
    as: "ul",
    props: mergeProps(menuProps, {
      ref: menuListRef,
      style: _extends({}, noOutline())
    })
  }, _overrides);

  var args = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalArgProps)), (_extends2 = {}, _extends2[config.itemsSlot] = createElement(MenuContext.Provider, {
    value: contextValue
  }, Array.from(state.collection).map(function (node) {
    return renderCollectionNode(node);
  })), _extends2));

  var plumeState = useMemo(function () {
    return {
      getFocusedValue: function getFocusedValue() {
        return state.selectionManager.focusedKey;
      },
      setFocusedValue: function setFocusedValue(value) {
        return state.selectionManager.setFocusedKey(value);
      }
    };
  }, [state]);
  useImperativeHandle(ref, function () {
    return {
      getRoot: function getRoot() {
        return rootRef.current;
      },
      getFocusedValue: function getFocusedValue() {
        return plumeState.getFocusedValue();
      },
      setFocusedValue: function setFocusedValue(key) {
        return plumeState.setFocusedValue(key);
      }
    };
  }, [rootRef, plumeState]);
  return {
    plasmicProps: {
      variants: variants,
      args: args,
      overrides: overrides
    },
    state: plumeState
  };
}

function useMenuGroup(plasmicClass, props, config) {
  var _extends2, _overrides;

  var context = useContext(MenuContext);
  var node = props._node;

  if (!context || !node) {
    if (PLUME_STRICT_MODE) {
      throw new Error("You can only use a Menu.Group within a Menu component.");
    }

    return getDefaultPlasmicProps(plasmicClass, props);
  }

  var _useMenuSection = useMenuSection({
    heading: props.title,
    "aria-label": props["aria-label"]
  }),
      headingProps = _useMenuSection.headingProps,
      groupProps = _useMenuSection.groupProps;

  var _useSeparator = useSeparator({
    elementType: "li"
  }),
      separatorProps = _useSeparator.separatorProps;

  var variants = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalVariantProps)), mergeVariantToggles({
    def: config.noTitleVariant,
    active: !props.title
  }, {
    def: config.isFirstVariant,
    active: context.state.collection.getFirstKey() === node.key
  }));

  var args = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalArgProps)), (_extends2 = {}, _extends2[config.titleSlot] = props.title, _extends2[config.itemsSlot] = Array.from(node.childNodes).map(function (childNode) {
    return renderCollectionNode(childNode);
  }), _extends2));

  var overrides = (_overrides = {}, _overrides[config.root] = {
    props: getStyleProps(props)
  }, _overrides[config.separator] = {
    props: _extends({}, separatorProps),
    as: "li"
  }, _overrides[config.titleContainer] = _extends({
    props: _extends({
      role: "presentation"
    }, headingProps)
  }, !props.title && {
    render: function render() {
      return null;
    }
  }), _overrides[config.itemsContainer] = {
    props: _extends({}, groupProps),
    as: "ul"
  }, _overrides);
  return {
    plasmicProps: {
      variants: variants,
      args: args,
      overrides: overrides
    }
  };
}

function useMenuItem(plasmicClass, props, config) {
  var _extends2, _overrides;

  var menuContext = useContext(MenuContext);
  var triggerContext = useContext(TriggeredOverlayContext);

  if (!menuContext) {
    if (PLUME_STRICT_MODE) {
      throw new Error("You can only use a Menu.Item within a Menu component.");
    }

    return getDefaultPlasmicProps(plasmicClass, props);
  }

  var children = props.children,
      onAction = props.onAction;
  var state = menuContext.state,
      menuProps = menuContext.menuProps; // We pass in the Node secretly as an undocumented prop from <Select />

  var node = props._node;
  var isDisabled = state.disabledKeys.has(node.key);
  var isHighlighted = state.selectionManager.isFocused && state.selectionManager.focusedKey === node.key;
  var ref = useRef(null);

  var _useAriaMenuItem = useMenuItem$1(mergeProps({
    // We need to merge both the onAction on MenuItem and the onAction
    // on Menu
    onAction: onAction
  }, {
    onAction: menuProps.onAction,
    onClose: triggerContext == null ? void 0 : triggerContext.state.close
  }, {
    isDisabled: isDisabled,
    "aria-label": node && node["aria-label"],
    key: node.key,
    isVirtualized: false,
    closeOnSelect: true
  }), state, ref),
      menuItemProps = _useAriaMenuItem.menuItemProps,
      labelProps = _useAriaMenuItem.labelProps;

  var variants = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalVariantProps)), mergeVariantToggles({
    def: config.isDisabledVariant,
    active: isDisabled
  }, {
    def: config.isHighlightedVariant,
    active: isHighlighted
  }));

  var args = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalArgProps)), (_extends2 = {}, _extends2[config.labelSlot] = children, _extends2));

  var overrides = (_overrides = {}, _overrides[config.root] = {
    as: "li",
    props: mergeProps(menuItemProps, {
      ref: ref,
      style: noOutline()
    })
  }, _overrides[config.labelContainer] = {
    props: _extends({}, labelProps)
  }, _overrides);
  return {
    plasmicProps: {
      variants: variants,
      args: args,
      overrides: overrides
    }
  };
}

/**
 * A menu trigger hook that combines react-aria's useMenuTrigger, useAriaMenuTrigger,
 * useOverlayPosition, useOverlay, and usePress
 */

function useMenuTrigger(opts, state) {
  var triggerRef = opts.triggerRef,
      isDisabled = opts.isDisabled,
      placement = opts.placement,
      menuMatchTriggerWidth = opts.menuMatchTriggerWidth,
      menuWidth = opts.menuWidth,
      menu = opts.menu;

  var _useAriaMenuTrigger = useMenuTrigger$1({
    type: "menu",
    isDisabled: isDisabled
  }, state, triggerRef),
      triggerPressProps = _useAriaMenuTrigger.menuTriggerProps,
      menuProps = _useAriaMenuTrigger.menuProps;

  var _usePress = usePress(_extends({}, triggerPressProps, {
    isDisabled: isDisabled
  })),
      triggerProps = _usePress.pressProps;

  var makeMenu = function makeMenu() {
    var realMenu = typeof menu === "function" ? menu() : menu;

    if (!realMenu) {
      return null;
    }

    if (getPlumeType(realMenu) !== "menu") {
      if (PLUME_STRICT_MODE) {
        throw new Error("Must use an instance of the Menu component.");
      }

      return null;
    }

    return cloneElement(realMenu, mergeProps(realMenu.props, menuProps));
  };

  var triggerContext = useMemo(function () {
    var _state$focusStrategy;

    return {
      triggerRef: triggerRef,
      state: state,
      autoFocus: (_state$focusStrategy = state.focusStrategy) != null ? _state$focusStrategy : true,
      placement: placement,
      overlayMatchTriggerWidth: menuMatchTriggerWidth,
      overlayMinTriggerWidth: true,
      overlayWidth: menuWidth
    };
  }, [triggerRef, state, placement, menuMatchTriggerWidth, menuWidth]);
  return {
    triggerProps: triggerProps,
    makeMenu: makeMenu,
    triggerContext: triggerContext
  };
}

function DropdownMenu(props) {
  var isOpen = props.isOpen,
      defaultOpen = props.defaultOpen,
      onOpenChange = props.onOpenChange,
      children = props.children,
      placement = props.placement,
      menu = props.menu;
  var triggerRef = useRef(null);
  var state = useMenuTriggerState({
    isOpen: isOpen,
    defaultOpen: defaultOpen,
    onOpenChange: onOpenChange,
    shouldFlip: true
  });

  var _useMenuTrigger = useMenuTrigger({
    triggerRef: triggerRef,
    placement: placement,
    menu: menu
  }, state),
      triggerProps = _useMenuTrigger.triggerProps,
      makeMenu = _useMenuTrigger.makeMenu,
      triggerContext = _useMenuTrigger.triggerContext;

  return createElement(TriggeredOverlayContext.Provider, {
    value: triggerContext
  }, cloneElement(children, mergeProps(children.props, triggerProps, {
    ref: triggerRef
  })), state.isOpen && makeMenu());
}

function useMenuButton(plasmicClass, props, config, outerRef) {
  var _extends2, _overrides;

  if (outerRef === void 0) {
    outerRef = null;
  }

  var placement = props.placement,
      isOpen = props.isOpen,
      defaultOpen = props.defaultOpen,
      onOpenChange = props.onOpenChange,
      isDisabled = props.isDisabled,
      menu = props.menu,
      autoFocus = props.autoFocus,
      menuMatchTriggerWidth = props.menuMatchTriggerWidth,
      menuWidth = props.menuWidth;
  useEnsureSSRProvider();
  var rootRef = useRef(null);
  var triggerRef = useRef(null);
  var state = useMenuTriggerState({
    isOpen: isOpen,
    defaultOpen: defaultOpen,
    onOpenChange: onOpenChange,
    shouldFlip: true
  });

  var _useMenuTrigger = useMenuTrigger({
    isDisabled: isDisabled,
    triggerRef: triggerRef,
    placement: placement,
    menuMatchTriggerWidth: menuMatchTriggerWidth,
    menuWidth: menuWidth,
    menu: menu
  }, state),
      triggerProps = _useMenuTrigger.triggerProps,
      makeMenu = _useMenuTrigger.makeMenu,
      triggerContext = _useMenuTrigger.triggerContext;

  var _useFocusable = useFocusable(props, triggerRef),
      triggerFocusProps = _useFocusable.focusableProps;

  var variants = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalVariantProps)), mergeVariantToggles({
    def: config.isOpenVariant,
    active: state.isOpen
  }, {
    def: config.isDisabledVariant,
    active: isDisabled
  }));

  var args = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalArgProps)), (_extends2 = {}, _extends2[config.menuSlot] = state.isOpen ? makeMenu() : undefined, _extends2));

  var overrides = (_overrides = {}, _overrides[config.root] = {
    wrapChildren: function wrapChildren(children) {
      return createElement(TriggeredOverlayContext.Provider, {
        value: triggerContext
      }, children);
    },
    props: {
      ref: rootRef
    }
  }, _overrides[config.trigger] = {
    props: mergeProps(triggerProps, triggerFocusProps, getStyleProps(props), pick(props, "title"), {
      ref: triggerRef,
      autoFocus: autoFocus,
      disabled: !!isDisabled,
      // Make sure this button is not interpreted as submit
      type: "button"
    })
  }, _overrides);
  var plumeState = useMemo(function () {
    return {
      open: function open() {
        return state.open();
      },
      close: function close() {
        return state.close();
      },
      isOpen: function isOpen() {
        return state.isOpen;
      }
    };
  }, [state]);
  useImperativeHandle(outerRef, function () {
    return {
      getRoot: function getRoot() {
        return rootRef.current;
      },
      getTrigger: function getTrigger() {
        return triggerRef.current;
      },
      focus: function focus() {
        return triggerRef.current && triggerRef.current.focus();
      },
      blur: function blur() {
        return triggerRef.current && triggerRef.current.blur();
      },
      open: plumeState.open,
      close: plumeState.close,
      isOpen: plumeState.isOpen
    };
  }, [rootRef, triggerRef, plumeState]);
  return {
    plasmicProps: {
      variants: variants,
      args: args,
      overrides: overrides
    },
    state: plumeState
  };
}

var SelectContext = /*#__PURE__*/createContext(undefined);

var COLLECTION_OPTS$1 = {
  itemPlumeType: "select-option",
  sectionPlumeType: "select-option-group"
};
/**
 * Converts props in our BaseSelectProps into props that react-aria's
 * useSelect() understands.
 *
 * Because we're not exposing the Collections API (see ./index.tsx),
 * we are converting our own API into props for useSelect.
 *
 * Specifically, in Plume's API,
 * - `children` flattens to a list of ReactElements of type Select.Option
 *   or Select.OptionGroup
 *
 * and we map it this way to the Collections API:
 * - `items` is a list of those flattened ReactElements from `children`!
 * - `children`, as a render prop, is supposed to take one of the `items`
 *   and return a `Section` or `Item` element. We take an Option/OptionGroup
 *   element, and use its props to render the appropriate `Section` or
 *   `Item`. The "trick" here is that we then stuff the Option element as
 *   `Item.children`, and the OptionGroup element as `Section.title`.
 *
 * When the Collections API does its work deriving `Node`s, the corresponding
 * Option/OptionGroup ReactElements will end up as `Node.rendered`.
 *
 * Then, when we are actually rendering the content of the dropdown, we
 * iterate through each collected `Node`, and renders
 * React.cloneElement(Node.rendered, {_node: node}).  This "secretly" passes
 * the derived collection `Node` as a prop to Option and OptionGroup, and they
 * can make use of the derived `Node.key` etc in their rendering functions.
 *
 * One thing to note here is that we never "rendered" the Option/OptionGroup
 * React elements that the user constructed; instead, we just looked at the
 * props used on those elements, and passed those onto the Collections API.
 * What gets rendered to the screen is the cloned version of these elements
 * with the secret derived `_node` prop.  That means Option and OptionGroup
 * render functions can assume that _node is passed in.
 */

function useAriaSelectProps(props) {
  var value = props.value,
      defaultValue = props.defaultValue,
      children = props.children,
      onChange = props.onChange,
      rest = _objectWithoutPropertiesLoose(props, ["value", "defaultValue", "children", "onChange", "placement", "menuMatchTriggerWidth", "menuWidth"]);

  var _useDerivedItemsFromC = useDerivedItemsFromChildren(children, _extends({}, COLLECTION_OPTS$1, {
    invalidChildError: "Can only use Select.Option and Select.OptionGroup as children to Select",
    requireItemValue: true
  })),
      items = _useDerivedItemsFromC.items,
      disabledKeys = _useDerivedItemsFromC.disabledKeys;

  var collectionChildRenderer = useCallback(function (child) {
    return renderAsCollectionChild(child, COLLECTION_OPTS$1);
  }, []);
  var onSelectionChange = useMemo(function () {
    if (onChange) {
      return function (val) {
        return onChange(val == null || val === "null" ? null : val);
      };
    } else {
      return undefined;
    }
  }, [onChange]);
  return {
    ariaProps: _extends({}, rest, {
      children: collectionChildRenderer,
      onSelectionChange: onSelectionChange,
      items: items,
      disabledKeys: disabledKeys,
      defaultSelectedKey: defaultValue
    }, "value" in props && {
      selectedKey: value != null ? value : null
    })
  };
}

function useSelect(plasmicClass, props, config, ref) {
  var _overrides, _extends2;

  if (ref === void 0) {
    ref = null;
  }

  useEnsureSSRProvider();

  var _useAriaSelectProps = useAriaSelectProps(props),
      ariaProps = _useAriaSelectProps.ariaProps;

  var placement = props.placement;
  var state = useSelectState(ariaProps);
  var triggerRef = useRef(null);
  var rootRef = useRef(null);
  var isDisabled = props.isDisabled,
      name = props.name,
      menuWidth = props.menuWidth,
      menuMatchTriggerWidth = props.menuMatchTriggerWidth,
      autoFocus = props.autoFocus,
      placeholder = props.placeholder,
      selectedContent = props.selectedContent;

  var _useAriaSelect = useSelect$1(ariaProps, state, triggerRef),
      triggerPressProps = _useAriaSelect.triggerProps,
      menuProps = _useAriaSelect.menuProps;

  var _usePress = usePress(_extends({}, triggerPressProps, {
    isDisabled: isDisabled
  })),
      triggerProps = _usePress.pressProps;

  var triggerContent = state.selectedItem ? selectedContent != null ? selectedContent : getChildProp(state.selectedItem.value, "children") : null;

  var variants = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalVariantProps)), mergeVariantToggles({
    def: config.isOpenVariant,
    active: state.isOpen
  }, {
    def: config.placeholderVariant,
    active: !state.selectedItem
  }, {
    def: config.isDisabledVariant,
    active: isDisabled
  }));

  var triggerContext = useMemo(function () {
    return {
      triggerRef: triggerRef,
      state: state,
      placement: placement,
      overlayMatchTriggerWidth: menuMatchTriggerWidth,
      overlayMinTriggerWidth: true,
      overlayWidth: menuWidth
    };
  }, [triggerRef, state, placement, menuMatchTriggerWidth, menuWidth]);
  var overrides = (_overrides = {}, _overrides[config.root] = {
    props: mergeProps(getStyleProps(props), {
      ref: rootRef
    }),
    wrapChildren: function wrapChildren(children) {
      return createElement(Fragment, null, createElement(HiddenSelect, {
        state: state,
        triggerRef: triggerRef,
        name: name,
        isDisabled: isDisabled
      }), children);
    }
  }, _overrides[config.trigger] = {
    props: mergeProps(triggerProps, {
      ref: triggerRef,
      autoFocus: autoFocus,
      disabled: !!isDisabled,
      // Don't trigger form submission!
      type: "button"
    })
  }, _overrides[config.overlay] = {
    wrap: function wrap(content) {
      return createElement(TriggeredOverlayContext.Provider, {
        value: triggerContext
      }, content);
    }
  }, _overrides[config.optionsContainer] = {
    wrap: function wrap(content) {
      return createElement(ListBoxWrapper, {
        state: state,
        menuProps: menuProps
      }, content);
    }
  }, _overrides);

  var args = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalArgProps)), (_extends2 = {}, _extends2[config.triggerContentSlot] = triggerContent, _extends2[config.placeholderSlot] = placeholder, _extends2[config.optionsSlot] = createElement(SelectContext.Provider, {
    value: state
  }, Array.from(state.collection).map(function (node) {
    return renderCollectionNode(node);
  })), _extends2));

  var plumeState = useMemo(function () {
    return {
      open: function open() {
        return state.open();
      },
      close: function close() {
        return state.close();
      },
      isOpen: function isOpen() {
        return state.isOpen;
      },
      getSelectedValue: function getSelectedValue() {
        return state.selectedKey ? "" + state.selectedKey : null;
      },
      setSelectedValue: function setSelectedValue(key) {
        return state.setSelectedKey(key);
      }
    };
  }, [state]);
  useImperativeHandle(ref, function () {
    return {
      getRoot: function getRoot() {
        return rootRef.current;
      },
      getTrigger: function getTrigger() {
        return triggerRef.current;
      },
      focus: function focus() {
        var _triggerRef$current;

        return (_triggerRef$current = triggerRef.current) == null ? void 0 : _triggerRef$current.focus();
      },
      blur: function blur() {
        var _triggerRef$current2;

        return (_triggerRef$current2 = triggerRef.current) == null ? void 0 : _triggerRef$current2.blur();
      },
      open: function open() {
        return plumeState.open();
      },
      close: function close() {
        return plumeState.close();
      },
      isOpen: function isOpen() {
        return plumeState.isOpen();
      },
      getSelectedValue: function getSelectedValue() {
        return plumeState.getSelectedValue();
      },
      setSelectedValue: function setSelectedValue(key) {
        return plumeState.setSelectedValue(key);
      }
    };
  }, [rootRef, triggerRef, plumeState]);
  return {
    plasmicProps: {
      variants: variants,
      args: args,
      overrides: overrides
    },
    state: plumeState
  };
}

function ListBoxWrapper(props) {
  var state = props.state,
      menuProps = props.menuProps,
      children = props.children;
  var ref = useRef(null);

  var _useListBox = useListBox(_extends({}, menuProps, {
    isVirtualized: false,
    autoFocus: state.focusStrategy || true,
    disallowEmptySelection: true
  }), state, ref),
      listBoxProps = _useListBox.listBoxProps;

  return cloneElement(children, mergeProps(children.props, listBoxProps, {
    style: noOutline(),
    ref: ref
  }));
}

function useSelectOption(plasmicClass, props, config, outerRef) {
  var _extends2, _overrides;

  if (outerRef === void 0) {
    outerRef = null;
  }

  var state = useContext(SelectContext);

  if (!state) {
    // If no context, then we are being incorrectly used.  Complain or just don't
    // bother installing any hooks.  It's okay to violate rules of hooks here
    // because this instance won't suddenly be used correctly in another render.
    if (PLUME_STRICT_MODE) {
      throw new Error("You can only use a Select.Option within a Select component.");
    }

    return getDefaultPlasmicProps(plasmicClass, props);
  }

  var children = props.children;
  var rootRef = useRef(null);
  var onRef = mergeRefs(rootRef, outerRef); // We pass in the Node secretly as an undocumented prop from <Select />

  var node = props._node;
  var isSelected = state.selectionManager.isSelected(node.key);
  var isDisabled = state.disabledKeys.has(node.key);
  var isHighlighted = state.selectionManager.isFocused && state.selectionManager.focusedKey === node.key;

  var _useAriaOption = useOption({
    isSelected: isSelected,
    isDisabled: isDisabled,
    "aria-label": node && node["aria-label"],
    key: node.key,
    shouldSelectOnPressUp: true,
    shouldFocusOnHover: true,
    isVirtualized: false
  }, state, rootRef),
      optionProps = _useAriaOption.optionProps,
      labelProps = _useAriaOption.labelProps;

  var variants = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalVariantProps)), mergeVariantToggles({
    def: config.isSelectedVariant,
    active: isSelected
  }, {
    def: config.isDisabledVariant,
    active: isDisabled
  }, {
    def: config.isHighlightedVariant,
    active: isHighlighted
  }));

  var args = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalArgProps)), (_extends2 = {}, _extends2[config.labelSlot] = children, _extends2));

  var overrides = (_overrides = {}, _overrides[config.root] = {
    props: mergeProps(optionProps, getStyleProps(props), {
      ref: onRef,
      style: noOutline()
    })
  }, _overrides[config.labelContainer] = {
    props: labelProps
  }, _overrides);
  return {
    plasmicProps: {
      variants: variants,
      args: args,
      overrides: overrides
    }
  };
}

function useSelectOptionGroup(plasmicClass, props, config) {
  var _extends2, _overrides;

  var state = useContext(SelectContext); // `node` should exist if the OptionGroup was instantiated properly
  // within a Select

  var node = props._node;

  if (!state || !node) {
    if (PLUME_STRICT_MODE) {
      throw new Error("You can only use a Select.OptionGroup within a Select component.");
    }

    return getDefaultPlasmicProps(plasmicClass, props);
  }

  var _useListBoxSection = useListBoxSection({
    heading: props.title,
    "aria-label": props["aria-label"]
  }),
      headingProps = _useListBoxSection.headingProps,
      groupProps = _useListBoxSection.groupProps;

  var _useSeparator = useSeparator({
    elementType: "li"
  }),
      separatorProps = _useSeparator.separatorProps;

  var variants = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalVariantProps)), mergeVariantToggles({
    def: config.noTitleVariant,
    active: !props.title
  }, {
    def: config.isFirstVariant,
    active: state.collection.getFirstKey() === node.key
  }));

  var args = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalArgProps)), (_extends2 = {}, _extends2[config.titleSlot] = props.title, _extends2[config.optionsSlot] = Array.from(node.childNodes).map(function (childNode) {
    return renderCollectionNode(childNode);
  }), _extends2));

  var overrides = (_overrides = {}, _overrides[config.root] = {
    props: getStyleProps(props)
  }, _overrides[config.separator] = {
    props: _extends({}, separatorProps)
  }, _overrides[config.titleContainer] = _extends({
    props: _extends({
      role: "presentation"
    }, headingProps)
  }, !props.title && {
    render: function render() {
      return null;
    }
  }), _overrides[config.optionsContainer] = {
    props: _extends({}, groupProps)
  }, _overrides);
  return {
    plasmicProps: {
      variants: variants,
      args: args,
      overrides: overrides
    }
  };
}

function asAriaSwitchProps(props) {
  var ariaProps = _extends({}, props, {
    isSelected: props.isChecked,
    defaultSelected: props.defaultChecked
  });

  delete ariaProps["isChecked"];
  delete ariaProps["defaultChecked"];
  return ariaProps;
}

function useSwitch(plasmicClass, props, config, ref) {
  var _overrides, _ref;

  if (ref === void 0) {
    ref = null;
  }

  var children = props.children,
      isDisabled = props.isDisabled;
  useEnsureSSRProvider();
  var inputRef = useRef(null);
  var rootRef = useRef(null);
  var ariaProps = asAriaSwitchProps(props);
  var state = useToggleState(ariaProps);

  var _useAriaSwitch = useSwitch$1(ariaProps, state, inputRef),
      inputProps = _useAriaSwitch.inputProps;

  var variants = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalVariantProps)), mergeVariantToggles({
    def: config.isDisabledVariant,
    active: isDisabled
  }, {
    def: config.isCheckedVariant,
    active: state.isSelected
  }, {
    def: config.noLabelVariant,
    active: !children
  }));

  var overrides = (_overrides = {}, _overrides[config.root] = {
    as: "label",
    props: mergeProps(getStyleProps(props), {
      ref: rootRef
    }),
    wrapChildren: function wrapChildren(children) {
      return createElement(Fragment, null, createElement(VisuallyHidden, {
        isFocusable: true
      }, createElement("input", Object.assign({}, inputProps, {
        ref: inputRef
      }))), children);
    }
  }, _overrides);

  var args = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalArgProps)), config.labelSlot ? (_ref = {}, _ref[config.labelSlot] = children, _ref) : {});

  var plumeState = useMemo(function () {
    return {
      setChecked: function setChecked(checked) {
        return state.setSelected(checked);
      }
    };
  }, [state]);
  useImperativeHandle(ref, function () {
    return {
      getRoot: function getRoot() {
        return rootRef.current;
      },
      focus: function focus() {
        var _inputRef$current;

        return (_inputRef$current = inputRef.current) == null ? void 0 : _inputRef$current.focus();
      },
      blur: function blur() {
        var _inputRef$current2;

        return (_inputRef$current2 = inputRef.current) == null ? void 0 : _inputRef$current2.blur();
      },
      setChecked: function setChecked(checked) {
        return plumeState.setChecked(checked);
      }
    };
  }, [rootRef, inputRef, plumeState]);
  return {
    plasmicProps: {
      variants: variants,
      overrides: overrides,
      args: args
    },
    state: plumeState
  };
}

function useTextInput(plasmicClass, props, config, ref) {
  var _ref, _ref2, _overrides;

  if (ref === void 0) {
    ref = null;
  }

  var isDisabled = props.isDisabled,
      startIcon = props.startIcon,
      endIcon = props.endIcon,
      showStartIcon = props.showStartIcon,
      showEndIcon = props.showEndIcon,
      className = props.className,
      style = props.style,
      inputClassName = props.inputClassName,
      inputStyle = props.inputStyle,
      rest = _objectWithoutPropertiesLoose(props, ["isDisabled", "startIcon", "endIcon", "showStartIcon", "showEndIcon", "className", "style", "inputClassName", "inputStyle"]);

  var rootRef = useRef(null);
  var inputRef = useRef(null);
  useImperativeHandle(ref, function () {
    return {
      focus: function focus() {
        var _inputRef$current;

        (_inputRef$current = inputRef.current) == null ? void 0 : _inputRef$current.focus();
      },
      blur: function blur() {
        var _inputRef$current2;

        (_inputRef$current2 = inputRef.current) == null ? void 0 : _inputRef$current2.blur();
      },
      getRoot: function getRoot() {
        return rootRef.current;
      },
      getInput: function getInput() {
        return inputRef.current;
      }
    };
  }, [rootRef, inputRef]);

  var variants = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalVariantProps)), mergeVariantToggles({
    def: config.showStartIconVariant,
    active: showStartIcon
  }, {
    def: config.showEndIconVariant,
    active: showEndIcon
  }, {
    def: config.isDisabledVariant,
    active: isDisabled
  }));

  var args = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalArgProps)), config.startIconSlot && (_ref = {}, _ref[config.startIconSlot] = startIcon, _ref), config.endIconSlot && (_ref2 = {}, _ref2[config.endIconSlot] = endIcon, _ref2));

  var overrides = (_overrides = {}, _overrides[config.root] = {
    props: {
      ref: rootRef,
      className: className,
      style: style
    }
  }, _overrides[config.input] = {
    props: _extends({}, omit.apply(void 0, [rest].concat(plasmicClass.internalArgProps.filter(function (prop) {
      return prop !== "required";
    }), plasmicClass.internalVariantProps)), {
      disabled: isDisabled,
      ref: inputRef,
      className: inputClassName,
      style: inputStyle
    })
  }, _overrides);
  return {
    plasmicProps: {
      variants: variants,
      args: args,
      overrides: overrides
    }
  };
}

function useTriggeredOverlay(plasmicClass, props, config, outerRef, isDismissable) {
  var _extends2, _overrides;

  if (outerRef === void 0) {
    outerRef = null;
  }

  if (isDismissable === void 0) {
    isDismissable = true;
  }

  var overlayRef = useRef(null);
  var onOverlayRef = mergeRefs(overlayRef, outerRef);
  var context = useContext(TriggeredOverlayContext);

  if (!context) {
    // If no context, then we are not being correctly used.  Either complain, or
    // exit early.  It's okay to exit early and break the rules of React hooks
    // because we won't suddenly have the appropriate context anyway for this instance.
    if (PLUME_STRICT_MODE) {
      throw new Error("You can only use a triggered overlay with a TriggeredOverlayContext");
    }

    return getDefaultPlasmicProps(plasmicClass, props);
  }

  var children = props.children;
  var triggerRef = context.triggerRef,
      placement = context.placement,
      overlayMatchTriggerWidth = context.overlayMatchTriggerWidth,
      overlayMinTriggerWidth = context.overlayMinTriggerWidth,
      overlayWidth = context.overlayWidth,
      state = context.state; // Measure the width of the trigger to inform the width of the menu (below).

  var _React$useState = useState(false),
      isRendered = _React$useState[0],
      setRendered = _React$useState[1];

  var triggerWidth = triggerRef.current && (overlayMatchTriggerWidth || overlayMinTriggerWidth) ? triggerRef.current.offsetWidth : undefined;
  useIsomorphicLayoutEffect(function () {
    if (!isRendered && triggerRef.current && (overlayMatchTriggerWidth || overlayMinTriggerWidth)) {
      setRendered(true);
    }
  }, [triggerRef, isRendered, overlayMatchTriggerWidth, overlayMinTriggerWidth]);

  var _useOverlay = useOverlay({
    isOpen: state.isOpen,
    onClose: state.close,
    isDismissable: isDismissable,
    shouldCloseOnBlur: true
  }, overlayRef),
      overlayAriaProps = _useOverlay.overlayProps;

  var _useOverlayPosition = useOverlayPosition({
    targetRef: triggerRef,
    overlayRef: overlayRef,
    placement: placement != null ? placement : "bottom left",
    shouldFlip: true,
    isOpen: state.isOpen,
    onClose: state.close,
    containerPadding: 0
  }),
      overlayPositionProps = _useOverlayPosition.overlayProps,
      updatePosition = _useOverlayPosition.updatePosition,
      placementAxis = _useOverlayPosition.placement;

  useIsomorphicLayoutEffect(function () {
    if (state.isOpen) {
      requestAnimationFrame(function () {
        updatePosition();
      });
    }
  }, [state.isOpen, updatePosition]);
  var overlayProps = mergeProps({
    style: {
      left: "auto",
      right: "auto",
      top: "auto",
      bottom: "auto",
      position: "absolute",
      width: overlayWidth != null ? overlayWidth : overlayMatchTriggerWidth ? triggerWidth : "auto",
      minWidth: overlayMinTriggerWidth ? triggerWidth : "auto"
    }
  }, overlayAriaProps, overlayPositionProps);

  var variants = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalVariantProps)), mergeVariantToggles({
    def: config.isPlacedTopVariant,
    active: placementAxis === "top"
  }, {
    def: config.isPlacedBottomVariant,
    active: placementAxis === "bottom"
  }, {
    def: config.isPlacedLeftVariant,
    active: placementAxis === "left"
  }, {
    def: config.isPlacedRightVariant,
    active: placementAxis === "right"
  }));

  var args = _extends({}, pick.apply(void 0, [props].concat(plasmicClass.internalArgProps)), (_extends2 = {}, _extends2[config.contentSlot] = createElement(FocusScope, {
    restoreFocus: true
  }, createElement(DismissButton, {
    onDismiss: state.close
  }), children), _extends2));

  var overrides = (_overrides = {}, _overrides[config.root] = {
    props: mergeProps(overlayProps, getStyleProps(props), {
      ref: onOverlayRef
    }),
    wrap: function wrap(root) {
      if (typeof document !== "undefined") {
        return createPortal(root, document.body);
      } else {
        // Possibly being invoked on the server during SSR; no need to
        // bother with a portal in that case.
        return root;
      }
    }
  }, _overrides);
  return {
    plasmicProps: {
      variants: variants,
      args: args,
      overrides: overrides
    }
  };
}

function generateStateOnChangeProp($state, stateName, dataReps) {
  return function (val, path) {
    return set($state, [stateName].concat(dataReps, path), val);
  };
}
/**
 * This function generate the state value prop for repeated states
 * Example:
 *   - parent[][].counter[].count
 * We need to pass `parent[index1][index2].counter to the child component
 */

function generateStateValueProp($state, path // ["parent", 0, 1, "counter"]
) {
  return _get($state, path);
}
/**
 * Forked from https://github.com/lukeed/dset
 * Changes: fixed setting a deep value to a proxy object
 */

function set(obj, keys, val) {
  keys = keys.split ? keys.split(".") : keys;
  var i = 0,
      l = keys.length,
      t = obj,
      x,
      k;

  while (i < l) {
    k = keys[i++];
    if (k === "__proto__" || k === "constructor" || k === "prototype") break;

    if (i === l) {
      t[k] = val;
      t = t[k];
    } else {
      if (typeof (x = t[k]) === typeof keys) {
        t = t[k] = x;
      } else if (keys[i] * 0 !== 0 || !!~("" + keys[i]).indexOf(".")) {
        t[k] = {};
        t = t[k];
      } else {
        t[k] = [];
        t = t[k];
      }
    }
  }
}

var mkUntrackedValue = function mkUntrackedValue(o) {
  return typeof o === "object" ? ref(o) : o;
};

var transformPathStringToObj = function transformPathStringToObj(str) {
  var splitStatePathPart = function splitStatePathPart(state) {
    return state.endsWith("[]") ? [].concat(splitStatePathPart(state.slice(0, -2)), ["[]"]) : [state];
  };

  return str.split(".").flatMap(splitStatePathPart);
};

function shallowEqual(a1, a2) {
  if (a1.length !== a2.length) {
    return false;
  }

  for (var i = 0; i < a1.length; i++) {
    if (a1[i] !== a2[i]) {
      return false;
    }
  }

  return true;
}

function isNum(value) {
  return typeof value === "symbol" ? false : !isNaN(+value);
}

function saveNewState($$state, path, spec) {
  var key = JSON.stringify(path);
  $$state.existingStates.set(key, {
    path: path,
    specKey: spec.path
  });

  if (!$$state.statesInstanceBySpec.has(spec.path)) {
    $$state.statesInstanceBySpec.set(spec.path, []);
  }

  $$state.statesInstanceBySpec.get(spec.path).push({
    path: path,
    specKey: spec.path
  });
}

function create$StateProxy($$state, handlers) {
  var getNextKeyToSpecMap = function getNextKeyToSpecMap(currPath) {
    return new Map(Object.entries(Object.values($$state.specsByKey).filter(function (spec) {
      return shallowEqual(currPath.map(function (p) {
        return isNum(p) ? "[]" : p;
      }), spec.pathObj.slice(0, currPath.length));
    }).reduce(function (agg, spec) {
      var nextKey = spec.pathObj[currPath.length];

      if (!(nextKey in agg)) {
        agg[nextKey] = [];
      }

      agg[nextKey].push(spec);
      return agg;
    }, {})));
  };

  var rec = function rec(currPath) {
    var nextKeyToSpecs = getNextKeyToSpecMap(currPath);

    var getSpecForProperty = function getSpecForProperty(property) {
      var _nextKeyToSpecs$get, _nextKeyToSpecs$get2;

      return nextKeyToSpecs.has("[]") && isNum(property) ? (_nextKeyToSpecs$get = nextKeyToSpecs.get("[]")) == null ? void 0 : _nextKeyToSpecs$get[0] : typeof property === "string" && nextKeyToSpecs.has(property) ? (_nextKeyToSpecs$get2 = nextKeyToSpecs.get(property)) == null ? void 0 : _nextKeyToSpecs$get2[0] : undefined;
    };

    var getNextPath = function getNextPath(property) {
      return [].concat(currPath, [isNum(property) ? +property : property]);
    };

    return new Proxy(nextKeyToSpecs.has("[]") ? [] : {}, {
      deleteProperty: function deleteProperty(target, property) {
        var prefixPath = getNextPath(property);
        var specKeysToUpdate = new Set();
        $$state.existingStates.forEach(function (_ref) {
          var path = _ref.path,
              specKey = _ref.specKey;

          if (path.length >= prefixPath.length && shallowEqual(path.slice(0, prefixPath.length), prefixPath)) {
            deleteState($$state, path);
            specKeysToUpdate.add(specKey);
          }
        });
        specKeysToUpdate.forEach(function (specKey) {
          var spec = $$state.specsByKey[specKey];

          if (spec.onChangeProp) {
            var _$$state$props$spec$o, _$$state$props;

            (_$$state$props$spec$o = (_$$state$props = $$state.props)[spec.onChangeProp]) == null ? void 0 : _$$state$props$spec$o.call(_$$state$props, _get($$state.stateValues, currPath), currPath);
          }
        });
        return Reflect.deleteProperty(target, property);
      },
      get: function get(target, property, receiver) {
        var spec = getSpecForProperty(property);

        if (spec && typeof property !== "symbol") {
          var nextPath = getNextPath(property);

          if (spec.pathObj.length === currPath.length + 1) {
            var _handlers$get, _handlers;

            // reached the end of the spec
            target[property] = (_handlers$get = (_handlers = handlers(nextPath, spec)).get) == null ? void 0 : _handlers$get.call(_handlers, target, property, receiver);
          } else if (!(property in target)) {
            target[property] = rec(nextPath);
          }
        }

        return Reflect.get(target, property, receiver);
      },
      set: function set$1(target, property, value, receiver) {
        var spec = getSpecForProperty(property);
        var nextPath = getNextPath(property);

        if (spec && typeof property !== "symbol") {
          if (spec.pathObj.length === currPath.length + 1) {
            var _handlers$set, _handlers2;

            // reached the end of the spec
            target[property] = (_handlers$set = (_handlers2 = handlers(nextPath, spec)).set) == null ? void 0 : _handlers$set.call(_handlers2, target, property, value, receiver);
            return Reflect.set(target, property, value, receiver);
          } else if (typeof value === "object") {
            target[property] = rec(nextPath);

            for (var _i = 0, _Object$keys = Object.keys(value); _i < _Object$keys.length; _i++) {
              var key = _Object$keys[_i];
              target[property][key] = value[key];
            }

            return true;
          }
        }

        if (property === "registerInitFunc" && currPath.length === 0) {
          return Reflect.set(target, property, value, receiver);
        }

        if (nextKeyToSpecs.has("[]")) {
          var _nextKeyToSpecs$get3;

          set($$state.stateValues, nextPath, value);

          (_nextKeyToSpecs$get3 = nextKeyToSpecs.get("[]")) == null ? void 0 : _nextKeyToSpecs$get3.forEach(function (spec) {
            if (spec != null && spec.onChangeProp) {
              var _$$state$props$spec$o2, _$$state$props2;

              (_$$state$props$spec$o2 = (_$$state$props2 = $$state.props)[spec.onChangeProp]) == null ? void 0 : _$$state$props$spec$o2.call(_$$state$props2, value, nextPath);
            }
          });
          return Reflect.set(target, property, value, receiver);
        } // invalid setting a value that doesn't make part of the spec


        return false;
      }
    });
  };

  return rec([]);
}

var deleteState = function deleteState($$state, path) {
  var _$$state$unsubscripti;

  var key = JSON.stringify(path);
  (_$$state$unsubscripti = $$state.unsubscriptionsByState[key]) == null ? void 0 : _$$state$unsubscripti.forEach(function (f) {
    return f();
  });
  delete $$state.unsubscriptionsByState[key];
  $$state.existingStates["delete"](key); // delete get($$state.stateValues, path.slice(-1))[path.slice(-1)[0]];
  // delete get($$state.initStateValues, path.slice(-1))[path.slice(-1)[0]];
};

var getIndexes = function getIndexes(path, spec) {
  var indexes = [];

  if (path.length !== spec.pathObj.length) {
    throw new Error("Unexpected error: state path and spec path have different lengths");
  }

  for (var i = 0; i < spec.pathObj.length; i++) {
    if (spec.pathObj[i] === "[]") {
      indexes.push(path[i]);
    }
  }

  return indexes;
};

function initializeStateValue($$state, initialStatePath, initialSpec) {
  var _$$state$unsubscripti2;

  var initialStateKey = JSON.stringify(initialStatePath);
  var stateAccess = new Set();
  var $state = create$StateProxy($$state, function (path, spec) {
    return {
      get: function get() {
        var key = JSON.stringify(path);
        stateAccess.add({
          path: path,
          spec: spec
        });

        if (spec.valueProp) {
          return !spec.isRepeated ? $$state.props[spec.valueProp] : _get($$state.props[spec.valueProp], path.slice(1));
        }

        if ($$state.existingStates.has(key)) {
          // is already initialized
          return _get($$state.stateValues, path);
        } else if (spec.initFunc) {
          initializeStateValue($$state, path, spec);
        }

        return _get($$state.stateValues, path);
      },
      set: function set() {
        throw new Error("Cannot update state values during initialization");
      }
    };
  });
  (_$$state$unsubscripti2 = $$state.unsubscriptionsByState[initialStateKey]) == null ? void 0 : _$$state$unsubscripti2.forEach(function (f) {
    return f();
  });
  $$state.unsubscriptionsByState[initialStateKey] = [];
  stateAccess.forEach(function (_ref2) {
    var path = _ref2.path,
        spec = _ref2.spec;
    var unsubscribe = subscribeKey(_get($$state.stateValues, path.slice(-1)), path.slice(-1)[0], function () {
      return set($$state.stateValues, initialStatePath, mkUntrackedValue(initialSpec.initFunc($$state.props, $state, getIndexes(path, spec))));
    });
    $$state.unsubscriptionsByState[initialStateKey].push(unsubscribe);
  });
  var untrackedInitialValue = mkUntrackedValue(initialSpec.initFunc($$state.props, $state, getIndexes(initialStatePath, initialSpec)));

  set($$state.initStateValues, initialStatePath, untrackedInitialValue);

  set($$state.stateValues, initialStatePath, untrackedInitialValue);

  return untrackedInitialValue;
}

function useDollarState(specs, props) {
  var $$state = React__default.useRef(proxy({
    stateValues: {},
    initStateValues: {},
    specsByKey: Object.fromEntries(specs.map(function (spec) {
      return [spec.path, _extends({}, spec, {
        pathObj: transformPathStringToObj(spec.path),
        isRepeated: spec.path.split(".").some(function (part) {
          return part.endsWith("[]");
        })
      })];
    })),
    statesInstanceBySpec: new Map(),
    existingStates: new Map(),
    unsubscriptionsByState: {},
    props: undefined,
    registrationsQueue: []
  })).current;
  $$state.props = mkUntrackedValue(props);
  var $state = React__default.useRef(Object.assign(create$StateProxy($$state, function (path, spec) {
    var key = JSON.stringify(path);

    if (!$$state.existingStates.has(key)) {
      var _spec$initVal;

      saveNewState($$state, path, spec);
      var untrackedValue = !spec.initFunc ? mkUntrackedValue((_spec$initVal = spec.initVal) != null ? _spec$initVal : undefined) : initializeStateValue($$state, path, spec);

      set($$state.stateValues, path, untrackedValue);

      set($$state.initStateValues, path, untrackedValue);
    }

    return {
      get: function get() {
        if (spec.valueProp) {
          var value = !spec.isRepeated ? $$state.props[spec.valueProp] : _get($$state.props[spec.valueProp], path.slice(1));
          return value;
        } else {
          return _get($$state.stateValues, path);
        }
      },
      set: function set$1(_t, _p, value) {
        set($$state.stateValues, path, mkUntrackedValue(value));

        if (spec.onChangeProp) {
          var _$$state$props$spec$o3, _$$state$props3;

          (_$$state$props$spec$o3 = (_$$state$props3 = $$state.props)[spec.onChangeProp]) == null ? void 0 : _$$state$props$spec$o3.call(_$$state$props3, value, path);
        }

        return true;
      }
    };
  }), {
    registerInitFunc: function registerInitFunc(pathStr, f) {
      var _$$state$statesInstan;

      if ((_$$state$statesInstan = $$state.statesInstanceBySpec.get(pathStr)) != null && _$$state$statesInstan.some(function (_ref3) {
        var path = _ref3.path,
            specKey = _ref3.specKey;
        return !deepEqual(_get($$state.initStateValues, path), f(props, $state, getIndexes(path, $$state.specsByKey[specKey])));
      })) {
        $$state.registrationsQueue.push({
          pathStr: pathStr,
          f: f
        });
      }
    }
  })).current; // For each spec with an initFunc, evaluate it and see if
  // the init value has changed. If so, reset its state.

  var resetSpecs = [];
  $$state.existingStates.forEach(function (_ref4) {
    var path = _ref4.path,
        specKey = _ref4.specKey;
    var spec = $$state.specsByKey[specKey];

    if (spec.initFunc) {
      var newInit = spec.initFunc(props, $state, getIndexes(path, spec));

      if (!deepEqual(newInit, _get($$state.initStateValues, path))) {
        resetSpecs.push({
          path: path,
          spec: spec
        });
      }
    }
  });
  React__default.useLayoutEffect(function () {
    resetSpecs.forEach(function (_ref5) {
      var path = _ref5.path,
          spec = _ref5.spec;
      var newInit = initializeStateValue($$state, path, spec);

      if (spec.onChangeProp) {
        var _$$state$props$spec$o4, _$$state$props4;

        (_$$state$props$spec$o4 = (_$$state$props4 = $$state.props)[spec.onChangeProp]) == null ? void 0 : _$$state$props$spec$o4.call(_$$state$props4, newInit, path);
      }
    });
  }, [props, resetSpecs]);
  React__default.useLayoutEffect(function () {
    $$state.registrationsQueue.forEach(function (_ref6) {
      var f = _ref6.f,
          pathStr = _ref6.pathStr;
      $$state.specsByKey[pathStr].initFunc = f;
    });
    $$state.registrationsQueue = [];
  }, [$$state.registrationsQueue]); // Re-render if any value changed in one of these objects

  useSnapshot($$state.stateValues, {
    sync: true
  });
  useSnapshot($$state.specsByKey, {
    sync: true
  });
  return $state;
}

function useCanvasDollarState(specs, props) {
  var $$state = proxy({
    stateValues: {},
    initStateValues: {},
    specsByKey: Object.fromEntries(specs.map(function (spec) {
      return [spec.path, _extends({}, spec, {
        pathObj: transformPathStringToObj(spec.path),
        isRepeated: spec.path.split(".").some(function (part) {
          return part.endsWith("[]");
        })
      })];
    })),
    statesInstanceBySpec: new Map(),
    existingStates: new Map(),
    unsubscriptionsByState: {},
    props: undefined,
    registrationsQueue: []
  });
  $$state.props = mkUntrackedValue(props);
  var $state = create$StateProxy($$state, function (path, spec) {
    return {
      get: function get() {
        return _get($$state.stateValues, path);
      },
      set: function set$1(_t, _p, value) {
        set($$state.stateValues, path, mkUntrackedValue(value));

        if (spec.onChangeProp) {
          var _$$state$props$spec$o5, _$$state$props5;

          (_$$state$props$spec$o5 = (_$$state$props5 = $$state.props)[spec.onChangeProp]) == null ? void 0 : _$$state$props$spec$o5.call(_$$state$props5, value, path);
        }

        return true;
      }
    };
  });

  for (var _iterator = _createForOfIteratorHelperLoose(specs), _step; !(_step = _iterator()).done;) {
    var spec = _step.value;
    var path = transformPathStringToObj(spec.path);
    var init = spec.valueProp ? $$state.props[spec.valueProp] : spec.initVal ? spec.initVal : spec.initFunc ? initializeStateValue($$state, path, $$state.specsByKey[spec.path]) : undefined;

    set($state, path, init);
  }

  return $state;
}

export { DropdownMenu, PlasmicHead, PlasmicIcon, PlasmicImg, PlasmicLink, PlasmicRootProvider, PlasmicSlot, SelectContext, Stack, Trans, TriggeredOverlayContext, classNames, createPlasmicElementProxy, createUseScreenVariants, deriveRenderOpts, ensureGlobalVariants, genTranslatableString, generateStateOnChangeProp, generateStateValueProp, getDataProps, hasVariant, makeFragment, mergeVariantsWithStates, omit, pick, plasmicHeadMeta, renderPlasmicSlot, set, setPlumeStrictMode, useButton, useCanvasDollarState, useCheckbox, useDollarState, useIsSSR, useMenu, useMenuButton, useMenuGroup, useMenuItem, useSelect, useSelectOption, useSelectOptionGroup, useSwitch, useTextInput, useTrigger, useTriggeredOverlay, wrapWithClassName };
//# sourceMappingURL=react-web.esm.js.map
