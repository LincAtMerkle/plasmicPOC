{"version":3,"file":"react-web.cjs.production.min.js","sources":["../src/common.ts","../src/react-utils.tsx","../src/render/Stack.tsx","../src/render/elements.ts","../src/render/PlasmicHead/index.tsx","../src/render/PlasmicImg/index.tsx","../src/render/PlasmicLink.tsx","../src/render/translation.tsx","../src/render/PlasmicSlot.tsx","../src/render/screen-variants.ts","../src/render/ssr.tsx","../src/render/triggers.ts","../src/index-common.tsx","../src/plume/plume-utils.ts","../src/plume/props-utils.ts","../src/plume/collection-utils.tsx","../src/plume/triggered-overlay/context.tsx","../src/plume/menu/context.tsx","../src/plume/menu/menu.tsx","../src/plume/menu-button/menu-trigger.tsx","../src/plume/select/context.tsx","../src/plume/select/select.tsx","../src/states/helpers.ts","../src/states/valtio.tsx","../src/plume/menu-button/DropdownMenu.tsx","../src/render/PlasmicIcon.tsx","../src/render/global-variants.ts","../src/plume/button/index.tsx","../src/plume/checkbox/index.tsx","../src/plume/menu-button/menu-button.tsx","../src/plume/menu/menu-group.tsx","../src/plume/menu/menu-item.tsx","../src/plume/select/select-option.tsx","../src/plume/select/select-option-group.tsx","../src/plume/switch/index.tsx","../src/plume/text-input/index.tsx","../src/plume/triggered-overlay/triggered-overlay.tsx"],"sourcesContent":["export function notNil<T>(x: T | undefined | null): x is T {\n  return x != null;\n}\n\nexport function pick<T>(\n  obj: T,\n  ...keys: (string | number | symbol)[]\n): Partial<T> {\n  if (Object.keys(obj).length === 0) {\n    return obj;\n  }\n  const res: any = {};\n  for (const key of keys) {\n    if (key in obj) {\n      res[key] = obj[key as keyof T];\n    }\n  }\n  return res as Partial<T>;\n}\n\nexport function pickBy<T>(\n  obj: T,\n  func: (key: string, val: any) => boolean\n): Partial<T> {\n  const res: any = {};\n  for (const [key, val] of Object.entries(obj)) {\n    if (func(key, val)) {\n      res[key] = obj[key as keyof T];\n    }\n  }\n  return res as Partial<T>;\n}\n\nexport function omit<T>(obj: T, ...keys: (keyof T)[]): Partial<T> {\n  if (Object.keys(obj).length === 0) {\n    return obj;\n  }\n  const res: Partial<T> = {};\n  for (const key of Object.keys(obj) as (keyof T)[]) {\n    if (!keys.includes(key)) {\n      res[key] = obj[key];\n    }\n  }\n  return res;\n}\n\nexport function isSubset<T>(a1: T[], a2: T[]) {\n  return a1.every((x) => a2.includes(x));\n}\n\nexport function chainSingleArgFuncs<A>(...funcs: ((arg: A) => A)[]) {\n  if (funcs.length === 0) {\n    return undefined;\n  }\n  return (arg: A) => {\n    let res: A = arg;\n    for (const func of funcs) {\n      res = func(res);\n    }\n    return res;\n  };\n}\n\nexport function ensure<T>(x: T | null | undefined): T {\n  if (x === null || x === undefined) {\n    debugger;\n    throw new Error(`Value must not be undefined or null`);\n  } else {\n    return x;\n  }\n}\n\nexport function isString(x: any): x is string {\n  return typeof x === \"string\";\n}\n\nexport function groupBy<T>(\n  collection: T[],\n  keyFunc: (x: T) => string\n): Record<string, T[]> {\n  const result: Record<string, T[]> = {};\n  for (const obj of collection) {\n    const key = keyFunc(obj);\n    if (key in result) {\n      result[key].push(obj);\n    } else {\n      result[key] = [obj];\n    }\n  }\n  return result;\n}\n\nexport function mapValues<V, V2>(\n  obj: Record<string, V>,\n  mapper: (value: V) => V2\n): Record<string, V2> {\n  const result: Record<string, V2> = {};\n  for (const key in obj) {\n    result[key] = mapper(obj[key]);\n  }\n  return result;\n}\n","import classNames from \"classnames\";\nimport React from \"react\";\n\nexport const isBrowser = typeof window !== \"undefined\";\nexport const NONE = Symbol(\"NONE\");\n\nexport const useIsomorphicLayoutEffect = isBrowser\n  ? React.useLayoutEffect\n  : React.useEffect;\n\nexport function createElementWithChildren(\n  elementType: any,\n  props: any,\n  children: React.ReactNode\n) {\n  if (Array.isArray(children)) {\n    return React.createElement(\n      elementType,\n      props,\n      ...children\n    ) as React.ReactElement;\n  } else if (children || \"children\" in props) {\n    // Only call React.createElement with `children` if there are actual children,\n    // or if there was an explicit (albeit undefined) children passed via\n    // props.  Otherwise, if you pass `undefined` as the children argument\n    // to React.createElement, the created element will have prop {children: undefined}.\n    // If the `root` is an PlasmicGeneratedComponent, and these props with {children: undefined}\n    // are used, then it will be taken as a `children` override, and will thus blank out\n    // everything under the root node.\n    return React.createElement(elementType, props, children);\n  } else {\n    return React.createElement(elementType, props);\n  }\n}\n\nexport function ensureNotArray(children: React.ReactNode) {\n  if (Array.isArray(children)) {\n    if (children.length === 1) {\n      return children[0];\n    } else {\n      return React.createElement(React.Fragment, {}, ...children);\n    }\n  } else {\n    return children;\n  }\n}\n\n/**\n * Flattens ReactNode into an array of ReactChild, but does NOT replace\n * missing keys with array index, as React.Children.toArray() does.\n */\nexport function toChildArray(children: React.ReactNode): React.ReactChild[] {\n  if (isReactChild(children)) {\n    return [children];\n  } else if (Array.isArray(children)) {\n    return children.flatMap(toChildArray);\n  } else {\n    return [];\n  }\n}\n\nexport function isReactText(child: React.ReactNode): child is React.ReactText {\n  return typeof child === \"string\" || typeof child === \"number\";\n}\n\nexport function isReactChild(\n  child: React.ReactNode\n): child is React.ReactChild {\n  return React.isValidElement(child) || isReactText(child);\n}\n\nexport function isReactFragment(\n  child: React.ReactNode\n): child is React.ReactElement {\n  return React.isValidElement(child) && child.type === React.Fragment;\n}\n\nexport function isReactNode(x: any) {\n  return (\n    typeof x === \"string\" || typeof x === \"number\" || React.isValidElement(x)\n  );\n}\n\n// From https://stackoverflow.com/questions/54775790/forcing-excess-property-checking-on-variable-passed-to-typescript-function\n// We also wrap the error message in a Partial<> because otherwise Jetbrains IDEs will autocomplete the component with all the string methods as props - see https://github.com/plasmicapp/plasmic/issues/16.\nexport type StrictProps<T, TExpected> = Exclude<\n  keyof T,\n  keyof TExpected\n> extends never\n  ? {}\n  : Partial<\"Unexpected extraneous props\">;\n\nexport type HTMLElementRefOf<T extends keyof JSX.IntrinsicElements> = Exclude<\n  React.ComponentProps<T>[\"ref\"],\n  string\n>;\n\nexport function mergeProps(\n  props: Record<string, any>,\n  ...restProps: Record<string, any>[]\n): Record<string, any> {\n  if (restProps.every((rest) => Object.keys(rest).length === 0)) {\n    return props;\n  }\n\n  const result = { ...props };\n\n  for (const rest of restProps) {\n    for (const key of Object.keys(rest)) {\n      result[key] = mergePropVals(key, result[key], rest[key]);\n    }\n  }\n\n  return result;\n}\n\nfunction updateRef<T>(ref: React.Ref<T> | undefined, value: T | null) {\n  if (!ref) {\n    return;\n  }\n\n  if (typeof ref === \"function\") {\n    ref(value);\n  } else {\n    if (!Object.isFrozen(ref)) {\n      (ref as React.MutableRefObject<T | null>).current = value;\n    }\n  }\n}\n\nexport function mergeRefs<T>(...refs: (React.Ref<T> | undefined)[]) {\n  return (value: T) => {\n    for (const ref of refs) {\n      updateRef(ref, value);\n    }\n  };\n}\n\nexport function mergePropVals(name: string, val1: any, val2: any): any {\n  if (val1 === NONE || val2 === NONE) {\n    // The NONE sentinel always skips all merging and returns null\n    return null;\n  } else if (val1 == null) {\n    // If either of them is nil, prefer the other\n    return val2;\n  } else if (val2 == null) {\n    return val1;\n  } else if (name === \"className\") {\n    // Special case for className -- always combine both class names\n    return classNames(val1, val2);\n  } else if (name === \"style\") {\n    // Special case for style -- always shallow-merge style dicts\n    return { ...val1, ...val2 };\n  } else if (name === \"ref\") {\n    // Special case for ref\n    return mergeRefs(val1, val2);\n  } else if (typeof val1 !== typeof val2) {\n    // If the type of the two values are different, then no way to merge them.\n    // Prefer val2.\n    return val2;\n  } else if (name.startsWith(\"on\") && typeof val1 === \"function\") {\n    // Special case for event handlers -- always call both handlers\n    return (...args: any[]) => {\n      let res: any;\n      if (typeof val1 === \"function\") {\n        res = val1(...args);\n      }\n      if (typeof val2 === \"function\") {\n        res = val2(...args);\n      }\n      return res;\n    };\n  } else {\n    // For all else, prefer val2\n    return val2;\n  }\n}\n\nexport function getElementTypeName(element: React.ReactElement) {\n  if (typeof element.type === \"string\") {\n    return element.type;\n  } else {\n    const comp = element.type as any;\n    return comp.displayName ?? comp.name ?? comp.render?.name ?? \"Component\";\n  }\n}\n","import * as React from \"react\";\nimport { createElementWithChildren } from \"../react-utils\";\nimport { wrapFlexContainerChildren } from \"./elements\";\n\nfunction renderStack<T extends keyof JSX.IntrinsicElements>(\n  as: T,\n  props: React.ComponentProps<T>,\n  hasGap: boolean | undefined,\n  ref: React.Ref<any>\n) {\n  const { children, ...rest } = props;\n  const wrappedChildren = wrapFlexContainerChildren(children, hasGap ?? false);\n  return createElementWithChildren(as, { ref, ...rest }, wrappedChildren);\n}\n\nfunction FlexStack_<T extends keyof JSX.IntrinsicElements = \"div\">(\n  props: { as?: T; hasGap?: boolean } & React.ComponentProps<T>,\n  outerRef: React.Ref<any>\n) {\n  const { as, hasGap, ...rest } = props;\n  return renderStack(\n    as ?? \"div\",\n    rest as React.ComponentProps<T>,\n    hasGap,\n    outerRef\n  );\n}\n\nconst FlexStack = React.forwardRef(FlexStack_) as <\n  T extends keyof JSX.IntrinsicElements = \"div\"\n>(\n  props: { as?: T; hasGap?: boolean } & React.ComponentProps<T>\n) => React.ReactElement;\n\nconst makeStackImpl = <T extends keyof JSX.IntrinsicElements>(as: T) => {\n  return React.forwardRef(\n    (\n      props: React.ComponentProps<T> & { hasGap?: boolean },\n      ref: React.Ref<any>\n    ) => {\n      const { hasGap, ...rest } = props;\n      return renderStack(as, rest as React.ComponentProps<T>, hasGap, ref);\n    }\n  ) as React.FC<React.ComponentProps<T> & { hasGap?: boolean }>;\n};\n\nexport const Stack = Object.assign(FlexStack, {\n  div: makeStackImpl(\"div\"),\n  a: makeStackImpl(\"a\"),\n  button: makeStackImpl(\"button\"),\n  h1: makeStackImpl(\"h1\"),\n  h2: makeStackImpl(\"h2\"),\n  h3: makeStackImpl(\"h3\"),\n  h4: makeStackImpl(\"h4\"),\n  h5: makeStackImpl(\"h5\"),\n  h6: makeStackImpl(\"h6\"),\n  label: makeStackImpl(\"label\"),\n  form: makeStackImpl(\"form\"),\n  section: makeStackImpl(\"section\"),\n  head: makeStackImpl(\"head\"),\n  main: makeStackImpl(\"main\"),\n  nav: makeStackImpl(\"nav\"),\n});\n","import get from \"dlv\";\nimport * as React from \"react\";\nimport { chainSingleArgFuncs, isSubset, notNil, omit, pick } from \"../common\";\nimport {\n  createElementWithChildren,\n  ensureNotArray,\n  isReactNode,\n  mergeProps,\n  mergePropVals,\n  NONE,\n} from \"../react-utils\";\nimport { $State } from \"../states/valtio\";\nimport { Stack } from \"./Stack\";\n\ninterface Variants {\n  [vg: string]: any;\n}\n\nexport type MultiChoiceArg<M extends string> = M | M[] | { [v in M]?: boolean };\nexport type SingleChoiceArg<M extends string> = M;\nexport type SingleBooleanChoiceArg<M extends string> = M | boolean;\n\ninterface OverrideTwiddle {\n  wrapChildren?: (children: React.ReactNode) => React.ReactNode;\n  wrap?: (node: React.ReactNode) => React.ReactNode;\n}\n\nexport type DefaultOverride<C extends React.ElementType> = {\n  type: \"default\";\n  props?: Partial<React.ComponentProps<C>>;\n} & OverrideTwiddle;\n\nexport type AsOverride<C extends React.ElementType> = {\n  type: \"as\";\n  as: C;\n  props?: Partial<React.ComponentProps<C>>;\n} & OverrideTwiddle;\n\nexport type RenderOverride<C extends React.ElementType> = {\n  type: \"render\";\n  render: (props: React.ComponentProps<C>, Comp: C) => React.ReactNode;\n  props?: Partial<React.ComponentProps<C>>;\n} & OverrideTwiddle;\n\nexport type Override<DefaultElementType extends React.ElementType> =\n  | DefaultOverride<DefaultElementType>\n  | AsOverride<any>\n  | RenderOverride<DefaultElementType>;\n\nexport type Overrides = Record<string, Flex<any>>;\nexport type Args = Record<string, any>;\n\n// Flex provides a more \"flexible\" way to specify bindings.\nexport type Flex<DefaultElementType extends React.ElementType> =\n  // Fully-specified bindings\n  | (Omit<DefaultOverride<DefaultElementType>, \"type\"> & {\n      as?: never;\n      render?: never;\n    })\n  | Omit<AsOverride<any>, \"type\">\n  | (Omit<RenderOverride<DefaultElementType>, \"type\"> & {\n      as?: never;\n    })\n\n  // Valid ReactNode, used as children.\n  // Note: We use React.ReactChild instead of React.ReactNode because we don't want to include\n  // React.ReactFragment, which includes {}, which would allow any object to be passed in,\n  // defeating any attempt to type-check!\n  | React.ReactChild\n\n  // Ignored\n  | null\n  | undefined\n\n  // dict of props for the DefaultElementType\n  | (Partial<React.ComponentProps<DefaultElementType>> & {\n      wrap?: never;\n      wrapChildren?: never;\n      props?: never;\n      as?: never;\n      render?: never;\n    })\n\n  // render function taking in dict of props for the DefaultElementType\n  | ((props: React.ComponentProps<DefaultElementType>) => React.ReactNode);\n\nexport function hasVariant<V extends Variants>(\n  variants: V | undefined,\n  groupName: keyof V,\n  variant: string\n) {\n  if (variants == null) {\n    return false;\n  }\n  const groupVariants = variants[groupName];\n  if (groupVariants == null) {\n    return false;\n  } else if (groupVariants === true) {\n    return variant === groupName;\n  } else if (groupVariants === false) {\n    return false;\n  } else if (Array.isArray(groupVariants)) {\n    return groupVariants.includes(variant);\n  } else if (typeof groupVariants === \"string\") {\n    return groupVariants === variant;\n  } else {\n    return (\n      groupVariants[variant] !== undefined && groupVariants[variant] !== false\n    );\n  }\n}\n\nexport function wrapFlexContainerChildren(\n  children: React.ReactNode,\n  hasGap: boolean\n) {\n  // We need to always wrap the children, even if there are no gaps, because\n  // otherwise if we toggle between with and without gap, React reconciliation\n  // will blow away the children tree and all state if we switch from having\n  // a wrapper and not.\n  const className = hasGap ? \"__wab_flex-container\" : \"__wab_passthrough\";\n  if (!children) {\n    return null;\n  } else if (Array.isArray(children)) {\n    return React.createElement(\"div\", { className }, ...children);\n  } else {\n    return React.createElement(\"div\", { className }, children);\n  }\n}\n\nfunction createPlasmicElement<DefaultElementType extends React.ElementType>(\n  override: Flex<DefaultElementType>,\n  defaultRoot: DefaultElementType,\n  defaultProps: Partial<React.ComponentProps<DefaultElementType>>,\n  wrapChildrenInFlex?: boolean\n): React.ReactNode | null {\n  if (!override || Object.keys(override).length === 0) {\n    return createElementWithChildren(\n      defaultRoot,\n      defaultProps,\n      defaultProps.children\n    );\n  }\n  const override2 = deriveOverride(override);\n  const props = mergeOverrideProps(defaultProps, override2.props);\n  if (override2.type === \"render\") {\n    return override2.render(\n      props as React.ComponentProps<DefaultElementType>,\n      defaultRoot\n    );\n  }\n\n  let root = defaultRoot;\n  if (override2.type === \"as\" && override2.as) {\n    if (defaultRoot === (Stack as React.ElementType)) {\n      // If there was an \"as\" override specified, but the default type is\n      // a Stack, then we don't want to switch to using \"as\" as the root,\n      // because then we'd lose the flex wrapper that Stack provides.\n      // Instead, we specify the \"as\" as the \"as\" prop to Stack.\n      props.as = override2.as;\n    } else {\n      root = override2.as;\n    }\n  }\n\n  let children = props.children;\n\n  if (override2.wrapChildren) {\n    children = override2.wrapChildren(ensureNotArray(children));\n  }\n\n  if (wrapChildrenInFlex) {\n    // For legacy, we still support data-plasmic-wrap-flex-children\n    children = wrapFlexContainerChildren(children, true);\n  }\n\n  let result = createElementWithChildren(root, props, children);\n\n  if (override2.wrap) {\n    result = override2.wrap(result) as React.ReactElement;\n  }\n\n  return result;\n}\n\n// We use data-plasmic-XXX attributes for custom properties since Typescript doesn't\n// support type check on jsx pragma. See https://github.com/microsoft/TypeScript/issues/21699\n// for more info.\nconst seenElements = new Map<string, React.ReactNode>();\nexport function createPlasmicElementProxy<\n  DefaultElementType extends React.ElementType\n>(\n  defaultElement: DefaultElementType,\n  props: Partial<React.ComponentProps<DefaultElementType>>,\n  ...children: React.ReactNode[]\n) {\n  // We use seenElements to keep track of elements that has been rendered by\n  // createPlasmicElementProxy().  When a JSX tree is evaluated, the JSX factory\n  // is invoked from the leaf to the root as the last call.  So we can store\n  // all the elements we've created until we encounter the leaf, at which point\n  // we will clear this map.  We are guaranteed that this map will only contain\n  // elements from one Plasmic* component at a time, because we're just creating\n  // elements and not \"rendering\" at this point; even if this JSX tree references\n  // other Plasmic* elements, we'll just create an element referencing that component,\n  // rather than following into the content of that component.\n  //\n  // TODO: is this ConcurrentMode friendly?\n\n  if (props == null) {\n    props = {};\n  }\n\n  const name = props[\"data-plasmic-name\"];\n  const isRoot = props[\"data-plasmic-root\"];\n  const forNodeName = props[\"data-plasmic-for-node\"];\n\n  delete props[\"data-plasmic-name\"];\n  delete props[\"data-plasmic-root\"];\n  delete props[\"data-plasmic-for-node\"];\n\n  const element = createPlasmicElementFromJsx(\n    defaultElement,\n    props,\n    ...children\n  );\n  if (name) {\n    seenElements.set(name, element);\n  }\n\n  if (isRoot) {\n    // If this is the root, and we requested a specific node by specifying data-plasmic-for-node,\n    // then return that node instead\n    const forNode = forNodeName\n      ? seenElements.get(forNodeName) ?? null\n      : element;\n\n    // Clear out the seenElements map, as we're done rendering this Plasmic* component.\n    seenElements.clear();\n    return forNode;\n  }\n  return element;\n}\n\nfunction createPlasmicElementFromJsx<\n  DefaultElementType extends React.ElementType\n>(\n  defaultElement: DefaultElementType,\n  props: Partial<React.ComponentProps<DefaultElementType>>,\n  ...children: React.ReactNode[]\n) {\n  const override = props[\"data-plasmic-override\"];\n  const wrapFlexChild = props[\"data-plasmic-wrap-flex-child\"];\n  const triggerProps = (props[\"data-plasmic-trigger-props\"] ??\n    []) as React.HTMLAttributes<HTMLElement>[];\n  delete props[\"data-plasmic-override\"];\n  delete props[\"data-plasmic-wrap-flex-child\"];\n  delete props[\"data-plasmic-trigger-props\"];\n  return createPlasmicElement(\n    override,\n    defaultElement,\n    mergeProps(\n      props,\n      children.length === 0\n        ? {}\n        : { children: children.length === 1 ? children[0] : children },\n      ...triggerProps\n    ) as any,\n    wrapFlexChild\n  );\n}\n\nexport function makeFragment(...children: React.ReactNode[]) {\n  return React.createElement(React.Fragment, {}, ...children);\n}\n\nexport const UNSET = Symbol(\"UNSET\");\n\nfunction mergeOverrideProps(\n  defaults: Record<string, any>,\n  overrides?: Record<string, any>\n): Record<string, any> {\n  if (!overrides) {\n    return defaults;\n  }\n\n  const result = { ...defaults };\n\n  for (const key of Object.keys(overrides)) {\n    const defaultVal = defaults[key];\n    let overrideVal = overrides[key];\n    if (overrideVal === UNSET) {\n      delete result[key];\n    } else {\n      // We use the NONE sentinel if the overrideVal is nil, and is not one of the\n      // props that we merge by default -- which are className, style, and\n      // event handlers.  This means for all other \"normal\" props -- like children,\n      // title, etc -- a nil value will unset the default.\n      if (\n        overrideVal == null &&\n        key !== \"className\" &&\n        key !== \"style\" &&\n        !(key.startsWith(\"on\") && typeof defaultVal === \"function\")\n      ) {\n        overrideVal = NONE;\n      }\n      result[key] = mergePropVals(key, defaultVal, overrideVal);\n    }\n  }\n\n  return result;\n}\n\nexport function wrapWithClassName(element: React.ReactNode, className: string) {\n  const key = React.isValidElement(element)\n    ? element.key || undefined\n    : undefined;\n  return React.createElement(\n    \"div\",\n    {\n      key,\n      className,\n      style: {\n        display: \"grid\",\n      },\n    },\n    element\n  );\n}\n\nfunction deriveOverride<C extends React.ElementType>(x: Flex<C>): Override<C> {\n  if (!x) {\n    // undefined Binding is an empty Binding\n    return {\n      type: \"default\",\n      props: {} as any,\n    };\n  } else if (isReactNode(x)) {\n    // If ReactNode, then assume this is the children\n    return {\n      type: \"default\",\n      props: {\n        children: x,\n      } as any,\n    };\n  } else if (typeof x === \"object\") {\n    // If any of the overrideKeys is a key of this object, then assume\n    // this is a full Override\n    if (\"as\" in x) {\n      return {\n        ...x,\n        props: x.props || {},\n        type: \"as\",\n      } as any;\n    } else if (\"render\" in x) {\n      return {\n        ...x,\n        type: \"render\",\n      } as any;\n    } else if (\"props\" in x) {\n      return {\n        ...x,\n        props: x.props || {},\n        type: \"default\",\n      };\n    } else if (isSubset(Object.keys(x), [\"wrap\", \"wrapChildren\"])) {\n      // Only twiddling functions present, so assume no props overrides\n      // (otherwise we'd assume these were props).\n      return {\n        ...x,\n        props: {},\n        type: \"default\",\n      };\n    }\n\n    // Else, assume this is just a props object.\n    return {\n      type: \"default\",\n      props: x as any,\n    };\n  } else if (typeof x === \"function\") {\n    return {\n      type: \"render\",\n      render: x,\n    };\n  }\n\n  throw new Error(`Unexpected override: ${x}`);\n}\n\nfunction mergeVariants<V extends Variants>(\n  v1: Partial<V> | undefined,\n  v2: Partial<V> | undefined\n): Partial<V> {\n  if (!v1 || !v2) {\n    return v1 || v2 || {};\n  }\n  return { ...v1, ...v2 };\n}\n\nexport function mergeVariantsWithStates(\n  variants: Variants,\n  $state: $State,\n  linkedStates: {\n    variantGroup: string;\n    statePath: (string | number)[];\n  }[]\n): Variants {\n  return {\n    ...variants,\n    ...Object.fromEntries(\n      linkedStates.map(({ variantGroup, statePath }) => [\n        variantGroup,\n        get($state, statePath),\n      ])\n    ),\n  };\n}\n\nfunction mergeArgs<A extends Args>(\n  a1: Partial<A> | undefined,\n  a2: Partial<A> | undefined\n): Partial<A> {\n  if (!a1 || !a2) {\n    return a1 || a2 || {};\n  }\n  return { ...a1, ...a2 };\n}\n\nfunction mergeFlexOverrides<O extends Overrides>(\n  o1: Partial<O>,\n  o2: Partial<O> | undefined\n): Partial<O> {\n  if (!o2) {\n    return o1;\n  }\n  const keys = Array.from(new Set([...Object.keys(o1), ...Object.keys(o2)]));\n  const merged: Record<string, any> = {};\n  for (const key of keys) {\n    merged[key] = mergeFlexOverride(o1[key], o2[key]);\n  }\n  return merged as Partial<O>;\n}\n\nfunction mergeFlexOverride<C extends React.ElementType<any>>(\n  fo1: Flex<C> | undefined,\n  fo2: Flex<C> | undefined\n): Flex<C> | undefined {\n  if (!fo1) {\n    return fo2;\n  }\n  if (!fo2) {\n    return fo1;\n  }\n\n  const o1 = deriveOverride(fo1);\n  const o2 = deriveOverride(fo2);\n  const wrap = chainSingleArgFuncs(...[o1.wrap, o2.wrap].filter(notNil));\n  const wrapChildren = chainSingleArgFuncs(\n    ...[o1.wrapChildren, o2.wrapChildren].filter(notNil)\n  );\n\n  // \"render\" type always takes precedence, but we still merge the props\n  const props = mergeOverrideProps(o1.props ?? {}, o2.props) as Partial<\n    React.ComponentProps<C>\n  >;\n  if (o2.type === \"render\") {\n    return {\n      render: o2.render,\n      props,\n      wrap,\n      wrapChildren,\n    };\n  }\n\n  if (o1.type === \"render\") {\n    return {\n      render: o1.render,\n      props,\n      wrap,\n      wrapChildren,\n    };\n  }\n\n  // \"as\" will take precedence\n  const as =\n    (o2.type === \"as\" ? o2.as : undefined) ??\n    (o1.type === \"as\" ? o1.as : undefined);\n\n  return {\n    props,\n    wrap,\n    wrapChildren,\n    ...(as ? { as } : {}),\n  };\n}\n\nexport function deriveRenderOpts(\n  props: Record<string, any>,\n  config: {\n    name: string;\n    descendantNames: string[];\n    internalVariantPropNames: string[];\n    internalArgPropNames: string[];\n  }\n) {\n  const {\n    name,\n    descendantNames,\n    internalVariantPropNames,\n    internalArgPropNames,\n  } = config;\n  const reservedPropNames = [\"variants\", \"args\", \"overrides\"];\n  const variants = mergeVariants(\n    omit(pick(props, ...internalVariantPropNames), ...reservedPropNames),\n    props.variants\n  );\n  const args = mergeArgs(\n    omit(pick(props, ...internalArgPropNames), ...reservedPropNames),\n    props.args\n  );\n  let overrides = mergeFlexOverrides(\n    omit(\n      pick(props, ...descendantNames),\n      ...internalArgPropNames,\n      ...internalVariantPropNames,\n      ...reservedPropNames\n    ),\n    props.overrides\n  );\n\n  const leftoverProps = omit(\n    props,\n    \"variants\",\n    \"args\",\n    \"overrides\",\n    ...descendantNames,\n    ...internalVariantPropNames,\n    ...internalArgPropNames\n  ) as Partial<React.ComponentProps<\"button\">>;\n\n  if (Object.keys(leftoverProps).length > 0) {\n    overrides = mergeFlexOverrides(overrides, {\n      [name]: {\n        props: leftoverProps,\n      },\n    });\n  }\n  return { variants, args, overrides };\n}\n","import * as React from \"react\";\n\nexport const PlasmicHeadContext = React.createContext<\n  React.ComponentType<any> | undefined\n>(undefined);\n\ntype PlasmicHeadProps = {\n  title?: string;\n  description?: string;\n  image?: string;\n  canonical?: string;\n};\n\nexport function PlasmicHead(props: PlasmicHeadProps) {\n  const Head = React.useContext(PlasmicHeadContext);\n  if (!Head) {\n    console.warn(\n      `Plasmic: Head meta tags are being ignored. To make them work, pass a Head component into PlasmicRootProvider.`\n    );\n    // TODO: Link to doc about Head.\n    return null;\n  }\n\n  // Helmet does not support React.Fragments, so we need to use `[<meta />,\n  // <meta />]` instead of `<><meta /><meta /></>`.\n  return (\n    <Head>\n      {props.image ? (\n        [\n          <meta\n            key=\"twitter:card\"\n            name=\"twitter:card\"\n            content=\"summary_large_image\"\n          />,\n          <meta key=\"og:image\" property=\"og:image\" content={props.image} />,\n          <meta\n            key=\"twitter:image\"\n            name=\"twitter:image\"\n            content={props.image}\n          />,\n        ]\n      ) : (\n        <meta key=\"twitter:card\" name=\"twitter:card\" content=\"summary\" />\n      )}\n      {props.title && [\n        <title key=\"title\">{props.title}</title>,\n        <meta key=\"og:title\" property=\"og:title\" content={props.title} />,\n        <meta\n          key=\"twitter:title\"\n          property=\"twitter:title\"\n          content={props.title}\n        />,\n      ]}\n      {props.description && [\n        <meta\n          key=\"description\"\n          name=\"description\"\n          content={props.description}\n        />,\n        <meta\n          key=\"og:description\"\n          property=\"og:description\"\n          content={props.description}\n        />,\n        <meta\n          key=\"twitter:description\"\n          name=\"twitter:description\"\n          content={props.description}\n        />,\n      ]}\n      {props.canonical && (\n        <link key=\"canonical\" ref=\"canonical\" href={props.canonical} />\n      )}\n    </Head>\n  );\n}\n\nexport const plasmicHeadMeta = {\n  name: \"hostless-plasmic-head\",\n  displayName: \"Head\",\n  description: \"Used to add page metadata to HTML <head />.\",\n  importName: \"PlasmicHead\",\n  importPath: \"@plasmicapp/react-web\",\n  isRepeatable: false,\n  styleSections: false,\n  props: {\n    title: {\n      type: \"string\",\n      displayName: \"Title\",\n    },\n    description: {\n      type: \"string\",\n      displayName: \"Description\",\n    },\n    image: {\n      type: \"imageUrl\",\n      displayName: \"Image\",\n    },\n    canonical: {\n      type: \"string\",\n      displayName: \"Canonical URL\",\n    },\n  },\n};\n","/**\n * Responsive `<img/>` replacement, based on `next/image`\n */\n\nimport classNames from \"classnames\";\nimport React, { CSSProperties } from \"react\";\nimport { pick } from \"../../common\";\nimport { mergeRefs } from \"../../react-utils\";\n\nexport interface ImageLoader {\n  supportsUrl: (url: string) => boolean;\n  transformUrl: (opts: {\n    src: string;\n    width?: number;\n    quality?: number;\n    format?: \"webp\";\n  }) => string;\n}\n\ntype ImgTagProps = Omit<\n  React.ComponentProps<\"img\">,\n  \"src\" | \"srcSet\" | \"ref\" | \"style\"\n>;\n\n// Default image sizes to snap to\n// TODO: make this configurable?\nconst IMG_SIZES = [16, 32, 48, 64, 96, 128, 256, 384];\nconst DEVICE_SIZES = [640, 750, 828, 1080, 1200, 1920, 2048, 3840];\nconst ALL_SIZES = [...IMG_SIZES, ...DEVICE_SIZES];\n\nexport interface PlasmicImgProps extends ImgTagProps {\n  /**\n   * Either an object with the src string, and its full width and height,\n   * or just a src string with unknown intrinsic dimensions.\n   */\n  src?:\n    | string\n    | {\n        src:\n          | string\n          | {\n              src: string;\n              height: number;\n              width: number;\n              blurDataURL?: string;\n            };\n        fullHeight: number;\n        fullWidth: number;\n        // We might also get a more precise aspectRatio for SVGs\n        // instead of relyiing on fullWidth / fullHeight, because\n        // those values might be rounded and not so accurate.\n        aspectRatio?: number;\n      };\n\n  /**\n   * className applied to the wrapper element if one is used.\n   */\n  className?: string;\n\n  /**\n   * css width\n   */\n  displayWidth?: number | string;\n\n  /**\n   * css height\n   */\n  displayHeight?: number | string;\n\n  /**\n   * css min-width\n   */\n  displayMinWidth?: number | string;\n\n  /**\n   * css min-height\n   */\n  displayMinHeight?: number | string;\n\n  /**\n   * css max-width\n   */\n  displayMaxWidth?: number | string;\n\n  /**\n   * css max-height\n   */\n  displayMaxHeight?: number | string;\n\n  /**\n   * For variable quality formats like jpg, the quality from 0 to 100\n   */\n  quality?: number;\n\n  /**\n   * ImageLoader to use for loading different dimensions of the image.\n   * If none specified, will not attempt to load different dimensions.\n   */\n  loader?: \"plasmic\" | ImageLoader;\n\n  /**\n   * Style applied to the wrapper element. objectFit and objectPosition\n   * rules are applied to the img element.\n   */\n  style?: React.CSSProperties;\n\n  /**\n   * Ref for the img element.  The normal <PlasmicImg ref={...} />\n   * prop gives the root element instead, which may be the img element\n   * or a wrapper element\n   */\n  imgRef?: React.Ref<HTMLImageElement>;\n}\n\nexport const PlasmicImg = React.forwardRef(function PlasmicImg(\n  props: PlasmicImgProps,\n  outerRef: React.Ref<HTMLElement>\n) {\n  let {\n    src,\n    className,\n    displayWidth,\n    displayHeight,\n    displayMinWidth,\n    displayMinHeight,\n    displayMaxWidth,\n    displayMaxHeight,\n    quality,\n    loader,\n    imgRef,\n    style,\n    loading,\n    ...rest\n  } = props;\n\n  const imgProps = Object.assign({}, rest, {\n    // Default loading to \"lazy\" if not specified (which is different from the\n    // html img, which defaults to eager!)\n    loading: loading ?? \"lazy\",\n  });\n\n  const { fullWidth, fullHeight, aspectRatio } =\n    typeof src === \"string\" || !src\n      ? { fullWidth: undefined, fullHeight: undefined, aspectRatio: undefined }\n      : src;\n  const srcStr = src\n    ? typeof src === \"string\"\n      ? src\n      : typeof src.src === \"string\"\n      ? src.src\n      : src.src.src\n    : \"\";\n\n  // Assume external image if either dimension is null and use usual <img>\n  if (fullHeight == null || fullWidth == null) {\n    return (\n      <img\n        src={srcStr}\n        className={className}\n        style={style}\n        {...imgProps}\n        loading={loading}\n        ref={mergeRefs(imgRef, outerRef) as any}\n      />\n    );\n  }\n\n  if (\n    isSvg(srcStr) &&\n    (displayHeight == null || displayHeight === \"auto\") &&\n    (displayWidth == null || displayWidth === \"auto\")\n  ) {\n    displayWidth = \"100%\";\n  }\n\n  let computedDisplayWidth = displayWidth;\n  if (\n    fullWidth &&\n    fullHeight &&\n    (!displayWidth || displayWidth === \"auto\") &&\n    !!getPixelLength(displayHeight)\n  ) {\n    // If there's a pixel length specified for displayHeight but not displayWidth,\n    // then we can derive the pixel length for displayWidth.  Having an explicit\n    // displayWidth makes this a fixed-size image, which makes it possible for us to\n    // generate better markup!\n    if (!isSvg(srcStr)) {\n      // We shouldn't do it for SVGs though, because `fullWidth` and\n      // `fullHeight` might have rounded values so the final\n      // `displayWidth` could differ by 1px or so.\n      computedDisplayWidth =\n        (getPixelLength(displayHeight)! * fullWidth) / fullHeight;\n    }\n  }\n\n  let spacerWidth = fullWidth;\n  let spacerHeight = fullHeight;\n  if (aspectRatio && isFinite(aspectRatio) && isSvg(srcStr)) {\n    // For SVGs, fullWidth and fullHeight can be rounded values, which would\n    // cause some discrepancy between the actual aspect ratio and the aspect\n    // ratio from those values. So, for those cases, we set large width / height\n    // values to get a more precise ratio from the spacer.\n    spacerWidth = DEFAULT_SVG_WIDTH;\n    spacerHeight = Math.round(spacerWidth / aspectRatio);\n  }\n\n  const { sizes, widthDescs } = getWidths(computedDisplayWidth, fullWidth, {\n    minWidth: displayMinWidth,\n  });\n  const imageLoader = getImageLoader(loader);\n  const spacerSvg = `<svg width=\"${spacerWidth}\" height=\"${spacerHeight}\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"/>`;\n  const spacerSvgBase64 =\n    typeof window === \"undefined\"\n      ? Buffer.from(spacerSvg).toString(\"base64\")\n      : window.btoa(spacerSvg);\n\n  let wrapperStyle: CSSProperties = { ...(style || {}) };\n  let spacerStyle: CSSProperties = {\n    ...pick(style || {}, \"objectFit\", \"objectPosition\"),\n  };\n\n  if (displayWidth != null && displayWidth !== \"auto\") {\n    // If width is set, set it on the wrapper along with min/max width\n    // and just use `width: 100%` on the spacer\n    spacerStyle.width = \"100%\";\n    // Rely on the styles set by `classname` on the wrapper:\n    // wrapperStyle.width = displayWidth;\n    // wrapperStyle.minWidth = displayMinWidth;\n    // wrapperStyle.maxWidth = displayMaxWidth;\n  } else {\n    // Otherwise, we want auto sizing from the spacer, so set width there.\n    //\n    // But if we have min/max width, it should be set in the wrapper and it\n    // can be percentage values (and we add corresponding min/max width to\n    // 100% in the spacer). In general it ends up with the correct effect,\n    // but some edge cases might make `min-width: 100%` shrink the image more\n    // than it should.\n    spacerStyle.width = displayWidth;\n    wrapperStyle.width = \"auto\";\n    if (displayMinWidth) {\n      spacerStyle.minWidth = \"100%\";\n      // Rely on min-width set by `classname` on the wrapper:\n      // wrapperStyle.minWidth = displayMinWidth;\n    }\n    if (displayMaxWidth != null && displayMaxWidth !== \"none\") {\n      spacerStyle.maxWidth = \"100%\";\n      // Rely on max-width set by `classname` on the wrapper:\n      // wrapperStyle.maxWidth = displayMaxWidth;\n    }\n  }\n\n  if (displayHeight != null && displayHeight !== \"auto\") {\n    spacerStyle.height = \"100%\";\n    // wrapperStyle.height = displayHeight;\n    // wrapperStyle.minHeight = displayMinHeight;\n    // wrapperStyle.maxHeight = displayMaxHeight;\n  } else {\n    spacerStyle.height = displayHeight;\n    wrapperStyle.height = \"auto\";\n    if (displayMinHeight) {\n      spacerStyle.minHeight = \"100%\";\n      // wrapperStyle.minHeight = displayMinHeight;\n    }\n    if (displayMaxHeight != null && displayMaxHeight !== \"none\") {\n      spacerStyle.maxHeight = \"100%\";\n      // wrapperStyle.maxHeight = displayMaxHeight;\n    }\n  }\n\n  return (\n    <div\n      className={classNames(className, \"__wab_img-wrapper\")}\n      ref={outerRef as any}\n      style={wrapperStyle}\n    >\n      <img\n        alt=\"\"\n        aria-hidden\n        className=\"__wab_img-spacer-svg\"\n        src={`data:image/svg+xml;base64,${spacerSvgBase64}`}\n        style={spacerStyle}\n      />\n      {makePicture({\n        imageLoader,\n        widthDescs,\n        sizes,\n        src: srcStr,\n        quality,\n        ref: imgRef,\n        style: style ? pick(style, \"objectFit\", \"objectPosition\") : undefined,\n        imgProps,\n        className: \"__wab_img\",\n      })}\n    </div>\n  );\n});\n\nfunction makePicture(opts: {\n  imageLoader?: ImageLoader;\n  widthDescs: WidthDesc[];\n  sizes?: string;\n  src: string;\n  quality?: number;\n  style?: React.CSSProperties;\n  className?: string;\n  imgProps: ImgTagProps;\n  ref?: React.Ref<HTMLImageElement>;\n}) {\n  // If imageLoader is undefined, then this renders to just a normal\n  // <img />.  Else it will render to a <picture> with a <source> for\n  // webp, and srcSet/sizes set according to width requirements.\n  const {\n    imageLoader,\n    widthDescs,\n    src,\n    quality,\n    style,\n    className,\n    sizes,\n    imgProps,\n    ref,\n  } = opts;\n  return (\n    <picture className=\"__wab_picture\">\n      {imageLoader && imageLoader.supportsUrl(src) && (\n        <source\n          type=\"image/webp\"\n          srcSet={widthDescs\n            .map(\n              (wd) =>\n                `${imageLoader.transformUrl({\n                  src,\n                  quality,\n                  width: wd.width,\n                  format: \"webp\",\n                })} ${wd.desc}`\n            )\n            .join(\", \")}\n        />\n      )}\n      <img\n        {...imgProps}\n        ref={ref}\n        className={className}\n        decoding=\"async\"\n        src={\n          imageLoader && imageLoader.supportsUrl(src)\n            ? imageLoader.transformUrl({\n                src,\n                quality,\n                width: widthDescs[widthDescs.length - 1].width,\n              })\n            : src\n        }\n        srcSet={\n          imageLoader && imageLoader.supportsUrl(src)\n            ? widthDescs\n                .map(\n                  (wd) =>\n                    `${imageLoader.transformUrl({\n                      src,\n                      quality,\n                      width: wd.width,\n                    })} ${wd.desc}`\n                )\n                .join(\", \")\n            : undefined\n        }\n        sizes={imageLoader && imageLoader.supportsUrl(src) ? sizes : undefined}\n        style={{\n          ...(style ? pick(style, \"objectFit\", \"objectPosition\") : {}),\n          width: 0,\n          height: 0,\n        }}\n      />\n    </picture>\n  );\n}\n\nconst DEFAULT_SVG_WIDTH = 10000;\n\nfunction isSvg(src: string) {\n  return src.endsWith(\".svg\") || src.startsWith(\"data:image/svg\");\n}\n\ninterface WidthDesc {\n  width?: number;\n  desc: string;\n}\n\nfunction getClosestPresetSize(width: number, fullWidth: number) {\n  const nextBiggerIndex =\n    ALL_SIZES.findIndex((w) => w >= width) ?? ALL_SIZES.length - 1;\n  const nextBigger = ALL_SIZES[nextBiggerIndex];\n  if (nextBigger >= fullWidth) {\n    // If the requested width is larger than the fullWidth,\n    // we just use the original width instead. It's impossible\n    // to make an image bigger than fullWidth!\n    return undefined;\n  } else if (\n    nextBiggerIndex + 1 < ALL_SIZES.length &&\n    fullWidth <= ALL_SIZES[nextBiggerIndex + 1]\n  ) {\n    // If the fullWidth is just between nextBigger and the one after that,\n    // then also might as well just use the original size (so, width is 30,\n    // nextBigger is 32, then we just use the original as long as fullWidth is\n    // less than 48)\n    return undefined;\n  }\n\n  return nextBigger;\n}\n\n/**\n * Computes the appropriate srcSet and sizes to use\n */\nfunction getWidths(\n  width: number | string | undefined,\n  fullWidth: number,\n  extra?: { minWidth: string | number | undefined }\n): { sizes: string | undefined; widthDescs: WidthDesc[] } {\n  const minWidth = extra?.minWidth;\n  const pixelWidth = getPixelLength(width);\n  const pixelMinWidth = getPixelLength(minWidth);\n  if (pixelWidth != null && (!minWidth || pixelMinWidth != null)) {\n    // If there's an exact width, then we just need to display it at 1x and 2x density\n    return {\n      widthDescs: [\n        {\n          width: getClosestPresetSize(\n            Math.max(pixelWidth, pixelMinWidth ?? 0),\n            fullWidth\n          ),\n          desc: \"1x\",\n        },\n        {\n          width: getClosestPresetSize(\n            Math.max(pixelWidth, pixelMinWidth ?? 0) * 2,\n            fullWidth\n          ),\n          desc: \"2x\",\n        },\n      ],\n      sizes: undefined,\n    };\n  }\n  // Otherwise we don't know what sizes we'll end up, so we just cap it at\n  // device width.  TODO: do better!\n  const usefulSizes = DEVICE_SIZES.filter(\n    (size) => !fullWidth || size < fullWidth\n  );\n  if (!!fullWidth && usefulSizes.length === 0) {\n    // image fullWidth is smaller than all device sizes.  So all we can do\n    // is offer 1x\n    return {\n      widthDescs: [\n        {\n          width: getClosestPresetSize(fullWidth, fullWidth),\n          desc: \"1x\",\n        },\n      ],\n      sizes: undefined,\n    };\n  }\n  return {\n    widthDescs: usefulSizes.map((size) => ({\n      width: getClosestPresetSize(size, fullWidth),\n      // If this is the last (buggest) useful width, but it is\n      // still within the bounds set by DEVICE_SIZES, then just\n      // use the original, unresized image.  This means if we match\n      // the largest size, we use unresized and best quality image.\n      // We only do this, though, if fullWidth is \"reasonable\" --\n      // smaller than the largest size we would consider.\n      // i === usefulSizes.length - 1 &&\n      // fullWidth < DEVICE_SIZES[DEVICE_SIZES.length - 1]\n      //   ? undefined\n      //   : size,\n      desc: `${size}w`,\n    })),\n    sizes: \"100vw\",\n  };\n}\n\nfunction getPixelLength(length: number | string | undefined) {\n  if (length == null || length == \"\") {\n    return undefined;\n  }\n\n  if (typeof length === \"number\") {\n    return length;\n  }\n\n  const parsed = parseNumeric(length);\n  if (parsed && (!parsed.units || parsed.units === \"px\")) {\n    return parsed.num;\n  }\n\n  return undefined;\n}\n\nfunction parseNumeric(val: string) {\n  // Parse strings like \"30\", \"30px\", \"30%\", \"30px /* blah blah */\"\n  const res = val.match(\n    /^\\s*(-?(?:\\d+\\.\\d*|\\d*\\.\\d+|\\d+))\\s*([a-z]*|%)\\s*(?:\\/\\*.*)?$/i\n  );\n  if (res == null) {\n    return undefined;\n  }\n  const num = res[1];\n  const units = res[2];\n  return { num: +num, units };\n}\n\nfunction getImageLoader(loader: \"plasmic\" | ImageLoader | undefined) {\n  if (loader == null) {\n    return undefined;\n  } else if (loader === \"plasmic\") {\n    return PLASMIC_IMAGE_LOADER;\n  } else {\n    return loader;\n  }\n}\n\nconst PLASMIC_IMAGE_LOADER: ImageLoader = {\n  supportsUrl: (src) => {\n    return src.startsWith(\"https://img.plasmic.app\") && !isSvg(src);\n  },\n  transformUrl: (opts) => {\n    const params = [\n      opts.width ? `w=${opts.width}` : undefined,\n      `q=${opts.quality ?? 75}`,\n      opts.format ? `f=${opts.format}` : undefined,\n    ].filter((x) => !!x);\n    return `${opts.src}?${params.join(\"&\")}`;\n  },\n};\n","import React from \"react\";\nimport { omit, pick } from \"../common\";\n\nexport const PlasmicLink = React.forwardRef(function PlasmicLink(\n  props: any,\n  ref: React.Ref<any>\n) {\n  // props.href is required for nextjs; if no props.href,\n  // then we just render the default anchor element\n  if (props.platform === \"nextjs\" && props.href) {\n    const nextjsProps = [\n      \"href\",\n      \"replace\",\n      \"scroll\",\n      \"shallow\",\n      \"passHref\",\n      \"prefetch\",\n      \"locale\",\n    ];\n\n    return React.createElement(\n      props.component,\n      pick(props, ...nextjsProps),\n      <a {...omit(props, \"component\", \"platform\", ...nextjsProps)} ref={ref} />\n    );\n  }\n\n  if (props.platform === \"gatsby\" && isInternalHref(props.href)) {\n    return React.createElement(props.component, {\n      ...omit(props, \"component\", \"platform\", \"href\"),\n      ...{ to: props.href, ref },\n    });\n  }\n\n  return <a {...omit(props, \"component\", \"platform\")} ref={ref} />;\n});\n\nfunction isInternalHref(href: string): boolean {\n  return /^\\/(?!\\/)/.test(href);\n}\n","import React from \"react\";\n\nexport type PlasmicTranslator = (\n  str: string,\n  opts?: {\n    components?: {\n      [key: string]: React.ReactElement;\n    };\n  }\n) => React.ReactNode;\n\nexport const PlasmicTranslatorContext =\n  React.createContext<PlasmicTranslator | undefined>(undefined);\n\nexport interface TransProps {\n  children?: React.ReactNode;\n}\n\nfunction isIterable(val: any): val is Iterable<any> {\n  return val != null && typeof val[Symbol.iterator] === \"function\";\n}\n\nexport function genTranslatableString(elt: React.ReactNode) {\n  const components: {\n    [key: string]: React.ReactElement;\n  } = {};\n  let componentsCount = 0;\n\n  const getText = (node: React.ReactNode): string => {\n    if (!node) {\n      return \"\";\n    }\n    if (\n      typeof node === \"number\" ||\n      typeof node === \"boolean\" ||\n      typeof node === \"string\"\n    ) {\n      return node.toString();\n    }\n    if (typeof node !== \"object\") {\n      return \"\";\n    }\n    if (Array.isArray(node) || isIterable(node)) {\n      return Array.from(node)\n        .map((child) => getText(child))\n        .filter((child) => !!child)\n        .join(\"\");\n    }\n    const nodeChildren: React.ReactNode =\n      (hasKey(node, \"props\") &&\n        hasKey(node.props, \"children\") &&\n        (node.props.children as React.ReactNode | undefined)) ||\n      (hasKey(node, \"children\") && node.children) ||\n      [];\n    const contents = `${React.Children.toArray(nodeChildren)\n      .map((child) => getText(child))\n      .filter((child) => !!child)\n      .join(\"\")}`;\n    if (React.isValidElement(node) && node.type === React.Fragment) {\n      return contents;\n    }\n    const componentId = componentsCount + 1;\n    componentsCount++;\n    components[componentId] = React.isValidElement(node)\n      ? React.cloneElement(node as any, {\n          key: componentId,\n          children: undefined,\n        })\n      : (node as never);\n    return `<${componentId}>${contents}</${componentId}>`;\n  };\n\n  const str = getText(elt);\n  return {\n    str,\n    components,\n    componentsCount,\n  };\n}\n\nexport function Trans({ children }: TransProps) {\n  const _t = React.useContext(PlasmicTranslatorContext);\n  if (!_t) {\n    warnNoTranslationFunctionAtMostOnce();\n    return children;\n  }\n\n  const { str, components, componentsCount } = genTranslatableString(children);\n  return _t(str, componentsCount > 0 ? { components } : undefined);\n}\n\nlet hasWarned = false;\nfunction warnNoTranslationFunctionAtMostOnce() {\n  if (!hasWarned) {\n    console.warn(\n      \"Using Plasmic Translation but no translation function has been provided\"\n    );\n    hasWarned = true;\n  }\n}\n\nfunction hasKey<K extends string>(v: any, key: K): v is Record<K, any> {\n  return typeof v === \"object\" && v !== null && key in v;\n}\n","import * as React from \"react\";\nimport { mergeProps } from \"../react-utils\";\nimport { Trans } from \"./translation\";\n\nexport function PlasmicSlot<T extends keyof JSX.IntrinsicElements = \"div\">(\n  props: React.ComponentProps<T> & {\n    as?: T;\n    defaultContents?: React.ReactNode;\n    value?: React.ReactNode;\n  }\n) {\n  return renderPlasmicSlot(props);\n}\n\nexport function renderPlasmicSlot<\n  T extends keyof JSX.IntrinsicElements = \"div\"\n>(opts: {\n  as?: T;\n  defaultContents?: React.ReactNode;\n  value?: React.ReactNode;\n}) {\n  const { as, defaultContents, value, ...rest } = opts;\n\n  let content = value === undefined ? defaultContents : value;\n  if (!content || (Array.isArray(content) && content.length === 0)) {\n    return null;\n  }\n\n  // If the content is a raw string, then we need to wrap the raw string\n  // into an element, in case the slot is inside a flex-gap\n  // container (you cannot apply margin to just a text node).\n  const maybeString = maybeAsString(content);\n  if (maybeString) {\n    content = <div className=\"__wab_slot-string-wrapper\">{maybeString}</div>;\n  }\n\n  const nonEmptyProps = Object.keys(rest).filter((p) => !!(rest as any)[p]);\n  if (nonEmptyProps.length === 0) {\n    // No attrs to apply to the slot (which means the slot is unstyled), then\n    // just render the content directly; no need for style wrapper.\n    return <>{content}</>;\n  }\n\n  return React.createElement(\n    as || \"div\",\n    mergeProps({ className: \"__wab_slot\" }, rest),\n    content\n  );\n}\n\nfunction maybeAsString(node: React.ReactNode): string | undefined {\n  // Unwrap fragments\n  if (\n    React.isValidElement(node) &&\n    // Fragment and Trans don't render DOM elements\n    (node.type === React.Fragment || node.type === Trans)\n  ) {\n    return maybeAsString(node.props.children);\n  }\n\n  if (typeof node === \"string\") {\n    return node;\n  }\n\n  if (Array.isArray(node) && node.length === 1 && typeof node[0] === \"string\") {\n    return node[0];\n  }\n\n  return undefined;\n}\n","import * as React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { isBrowser, useIsomorphicLayoutEffect } from \"../react-utils\";\n\ntype Queries = { [name: string]: string };\n\nconst listeners: Array<() => void> = [];\nconst queries: Queries = {};\n\nfunction matchScreenVariants() {\n  if (!isBrowser) {\n    return [];\n  }\n  return Object.entries(queries)\n    .filter(([, query]) => window.matchMedia(query).matches)\n    .map(([name]) => name);\n}\n\n// undefined if screen variants have never been calculated\nlet curScreenVariants: string[] | undefined = undefined;\n\nfunction recalculateScreenVariants() {\n  const screenVariant = matchScreenVariants();\n  if (\n    !curScreenVariants ||\n    screenVariant.join(\"\") !== curScreenVariants.join(\"\")\n  ) {\n    curScreenVariants = screenVariant;\n    ReactDOM.unstable_batchedUpdates(() =>\n      listeners.forEach((listener) => listener())\n    );\n  }\n}\n\nfunction ensureInitCurScreenVariants() {\n  // Initializes curScreenVariants if it hadn't been before. Note that this must\n  // be called from within an effect.\n  if (curScreenVariants === undefined) {\n    curScreenVariants = matchScreenVariants();\n  }\n}\n\nif (isBrowser) {\n  window.addEventListener(\"resize\", recalculateScreenVariants);\n}\n\nexport function createUseScreenVariants(\n  isMulti: boolean,\n  screenQueries: Queries\n) {\n  Object.assign(queries, screenQueries);\n  curScreenVariants = undefined;\n\n  return function () {\n    // It is important that upon first render, we return [] or undefined, because\n    // that is what SSR will use, and the client must match.  In an effect (which\n    // only happens on the client), we then actually ask for the real screen variant\n    // and, if different from [] or undefined, forces a re-render.\n\n    const [, updateState] = React.useState<{}>();\n    const lastScreenVariantsRef = React.useRef<string[]>(\n      curScreenVariants || []\n    );\n\n    // We do useLayoutEffect instead of useEffect to immediately\n    // register our forceUpdate. This ensures that if there was\n    // a window resize event between render and effects, that the\n    // listener will be registered in time\n    useIsomorphicLayoutEffect(() => {\n      const updateIfChanged = () => {\n        if (\n          curScreenVariants &&\n          lastScreenVariantsRef.current.join(\"\") !== curScreenVariants.join(\"\")\n        ) {\n          lastScreenVariantsRef.current = curScreenVariants;\n          // Force update\n          updateState({});\n        }\n      };\n\n      // Listeners are invoked whenever the window is resized\n      listeners.push(updateIfChanged);\n\n      // Initialize the curScreenVariants for the first time.  We don't need\n      // to invoke the listeners here because all components will already\n      // have this effect running and will re-render if the real screen\n      // variant is non-empty.\n      ensureInitCurScreenVariants();\n\n      // Now, if the curScreenVariants differs from what we returned last,\n      // then force a re-render.\n      updateIfChanged();\n      return () => {\n        // Remove our listener on unmount\n        listeners.splice(listeners.indexOf(updateIfChanged), 1);\n      };\n    }, []);\n\n    if (isMulti) {\n      return curScreenVariants || [];\n    } else if (curScreenVariants) {\n      return curScreenVariants[curScreenVariants.length - 1];\n    } else {\n      return undefined;\n    }\n  };\n}\n","import { PlasmicDataSourceContextProvider } from \"@plasmicapp/data-sources-context\";\nimport { SSRProvider, useIsSSR as useAriaIsSSR } from \"@react-aria/ssr\";\nimport * as React from \"react\";\nimport { PlasmicHeadContext } from \"./PlasmicHead\";\nimport { PlasmicTranslator, PlasmicTranslatorContext } from \"./translation\";\n\nexport interface PlasmicRootContextValue {\n  platform?: \"nextjs\" | \"gatsby\";\n}\n\nconst PlasmicRootContext = React.createContext<\n  PlasmicRootContextValue | undefined\n>(undefined);\n\nexport interface PlasmicRootProviderProps {\n  platform?: \"nextjs\" | \"gatsby\";\n  children?: React.ReactNode;\n  translator?: PlasmicTranslator;\n  Head?: React.ComponentType<any>;\n}\n\nexport function PlasmicRootProvider(props: PlasmicRootProviderProps) {\n  const { platform, children, userAuthToken } = props as any;\n  const context = React.useMemo(\n    () => ({\n      platform,\n    }),\n    [platform]\n  );\n  const dataSourceContextValue = React.useMemo(\n    () => ({\n      userAuthToken,\n    }),\n    [userAuthToken]\n  );\n  return (\n    <PlasmicRootContext.Provider value={context}>\n      <SSRProvider>\n        <PlasmicDataSourceContextProvider value={dataSourceContextValue}>\n          <PlasmicTranslatorContext.Provider value={props.translator}>\n            <PlasmicHeadContext.Provider value={props.Head}>\n              {children}\n            </PlasmicHeadContext.Provider>\n          </PlasmicTranslatorContext.Provider>\n        </PlasmicDataSourceContextProvider>\n      </SSRProvider>\n    </PlasmicRootContext.Provider>\n  );\n}\n\nexport const useIsSSR = useAriaIsSSR;\n\nexport function useHasPlasmicRoot() {\n  return !!React.useContext(PlasmicRootContext);\n}\n\nlet hasWarnedSSR = false;\n/**\n * Warns the user if PlasmicRootProvider is not used\n */\nexport function useEnsureSSRProvider() {\n  const hasRoot = useHasPlasmicRoot();\n  if (hasRoot || hasWarnedSSR || process.env.NODE_ENV !== \"development\") {\n    return;\n  }\n\n  hasWarnedSSR = true;\n  console.warn(\n    `Plasmic: To ensure your components work correctly with server-side rendering, please use PlasmicRootProvider at the root of your application.  See https://docs.plasmic.app/learn/ssr`\n  );\n}\n","import * as React from \"react\";\nimport { useFocusRing as useAriaFocusRing } from \"@react-aria/focus\";\n\nfunction useFocused(opts: { isTextInput?: boolean }) {\n  const { isFocused, focusProps } = useAriaFocusRing({\n    within: false,\n    isTextInput: opts.isTextInput,\n  });\n\n  return [isFocused, focusProps];\n}\n\nfunction useFocusVisible(opts: { isTextInput?: boolean }) {\n  const { isFocusVisible, focusProps } = useAriaFocusRing({\n    within: false,\n    isTextInput: opts.isTextInput,\n  });\n\n  return [isFocusVisible, focusProps];\n}\n\nfunction useFocusedWithin(opts: { isTextInput?: boolean }) {\n  const { isFocused, focusProps } = useAriaFocusRing({\n    within: true,\n    isTextInput: opts.isTextInput,\n  });\n\n  return [isFocused, focusProps];\n}\n\nfunction useFocusVisibleWithin(opts: { isTextInput?: boolean }) {\n  const { isFocusVisible, focusProps } = useAriaFocusRing({\n    within: true,\n    isTextInput: opts.isTextInput,\n  });\n\n  return [isFocusVisible, focusProps];\n}\n\nfunction useHover() {\n  const [isHover, setHover] = React.useState(false);\n  return [\n    isHover,\n    {\n      onMouseEnter: () => setHover(true),\n      onMouseLeave: () => setHover(false),\n    },\n  ];\n}\n\nfunction usePressed() {\n  const [isPressed, setPressed] = React.useState(false);\n  return [\n    isPressed,\n    {\n      onMouseDown: () => setPressed(true),\n      onMouseUp: () => setPressed(false),\n    },\n  ];\n}\n\nconst TRIGGER_TO_HOOK = {\n  useHover,\n  useFocused,\n  useFocusVisible,\n  useFocusedWithin,\n  useFocusVisibleWithin,\n  usePressed,\n} as const;\n\ntype TriggerType = keyof typeof TRIGGER_TO_HOOK;\n\ninterface TriggerOpts {\n  isTextInput?: boolean;\n}\n\n/**\n * Installs argment trigger. All the useTrigger calls must use hardcoded `trigger` arg,\n * as it's not valid to install variable React hooks!\n */\nexport function useTrigger(trigger: TriggerType, opts: TriggerOpts) {\n  return TRIGGER_TO_HOOK[trigger](opts) as [\n    boolean,\n    React.HTMLAttributes<HTMLElement>\n  ];\n}\n","// Utilities used by generated code\nimport _classNames from \"classnames\";\nexport const classNames = _classNames;\nexport { omit, pick } from \"./common\";\nexport { HTMLElementRefOf, StrictProps } from \"./react-utils\";\nexport {\n  createPlasmicElementProxy,\n  deriveRenderOpts,\n  Flex,\n  hasVariant,\n  makeFragment,\n  mergeVariantsWithStates,\n  MultiChoiceArg,\n  SingleBooleanChoiceArg,\n  SingleChoiceArg,\n  wrapWithClassName,\n} from \"./render/elements\";\nexport { ensureGlobalVariants } from \"./render/global-variants\";\nexport { PlasmicHead, plasmicHeadMeta } from \"./render/PlasmicHead\";\nexport { PlasmicIcon } from \"./render/PlasmicIcon\";\nexport { PlasmicImg } from \"./render/PlasmicImg\";\nexport { PlasmicLink } from \"./render/PlasmicLink\";\nexport { PlasmicSlot, renderPlasmicSlot } from \"./render/PlasmicSlot\";\nexport { createUseScreenVariants } from \"./render/screen-variants\";\nexport { PlasmicRootProvider, useIsSSR } from \"./render/ssr\";\nexport { Stack } from \"./render/Stack\";\nexport { genTranslatableString, Trans } from \"./render/translation\";\nexport { useTrigger } from \"./render/triggers\";\n","import * as React from \"react\";\nimport { groupBy, mapValues } from \"../common\";\nimport { SingleChoiceArg } from \"../render/elements\";\n\nexport let PLUME_STRICT_MODE = true;\n\nexport function setPlumeStrictMode(mode: boolean) {\n  PLUME_STRICT_MODE = mode;\n}\n\ntype VariantArgChoices<T> = T extends (infer M)[]\n  ? M\n  : T extends SingleChoiceArg<infer M>\n  ? M\n  : never;\ntype VariantArgsChoices<V> = { [k in keyof V]-?: VariantArgChoices<V[k]> };\ntype DictValues<V extends Record<string, any>> = V[keyof V];\ntype DictTuples<V extends Record<string, any>> = DictValues<\n  { [K in keyof V]: [K, V[K]] }\n>;\nexport type VariantDefTuple<V> = DictTuples<VariantArgsChoices<V>>;\n\ntype DistributeTuple<T> = T extends [infer T1, infer T2]\n  ? { group: T1; variant: T2 }\n  : never;\n\nexport type VariantDef<V> = DistributeTuple<VariantDefTuple<V>>;\n\nexport type PlasmicClass<\n  V extends Record<string, any>,\n  A extends Record<string, any>,\n  O extends Record<string, any>\n> = {\n  (props: { variants?: V; args?: A; overrides?: O }): React.ReactElement | null;\n  internalVariantProps: (keyof V)[];\n  internalArgProps: (keyof A)[];\n};\n\nexport type AnyPlasmicClass = PlasmicClass<any, any, any>;\n\nexport type PlasmicClassVariants<\n  C extends AnyPlasmicClass\n> = C extends PlasmicClass<infer V, any, any> ? V : unknown;\nexport type PlasmicClassArgs<\n  C extends AnyPlasmicClass\n> = C extends PlasmicClass<any, infer A, any> ? A : unknown;\nexport type PlasmicClassOverrides<\n  C extends AnyPlasmicClass\n> = C extends PlasmicClass<any, any, infer O> ? O : unknown;\n\ntype BooleanLike = boolean | undefined | null;\n\nexport function mergeVariantToggles<V>(\n  ...toggles: { def?: VariantDef<V>; active: BooleanLike }[]\n) {\n  const definedToggles = toggles.filter((x) => !!x.def) as {\n    def: VariantDef<V>;\n    active: BooleanLike;\n  }[];\n  const grouped = groupBy(definedToggles, ({ def }) => def.group as string);\n  return mapValues(grouped, (subToggles) => {\n    return Object.fromEntries(\n      subToggles.map(({ def, active }) => [def.variant, !!active])\n    );\n  });\n}\n\nexport function noOutline() {\n  return { outline: \"none\" };\n}\n\nexport function getPlumeType(child: React.ReactChild): string | undefined {\n  if (!React.isValidElement(child)) {\n    return undefined;\n  }\n  const childType = child.type as any;\n  return (childType.__plumeType || childType.getPlumeType?.(child.props)) as\n    | string\n    | undefined;\n}\n","import * as React from \"react\";\nimport { pick, pickBy } from \"../common\";\nimport {\n  AnyPlasmicClass,\n  PlasmicClassArgs,\n  PlasmicClassOverrides,\n  PlasmicClassVariants,\n} from \"./plume-utils\";\n\nexport interface StyleProps {\n  className?: string;\n  style?: React.CSSProperties;\n}\n\nexport function getStyleProps<P extends StyleProps>(props: P): StyleProps {\n  return pick(props, \"className\", \"style\");\n}\n\nexport function getDefaultPlasmicProps<C extends AnyPlasmicClass>(\n  plasmicClass: C,\n  props: Record<string, any>\n) {\n  return {\n    plasmicProps: {\n      variants: pick(\n        props,\n        ...plasmicClass.internalVariantProps\n      ) as PlasmicClassVariants<C>,\n      args: pick(\n        props,\n        ...plasmicClass.internalArgProps\n      ) as PlasmicClassArgs<C>,\n      overrides: {} as PlasmicClassOverrides<C>,\n    },\n  };\n}\n\nconst RE_DATA_PROP = /^(data-.*)$/;\n\nexport function getDataProps(props: Record<string, any>) {\n  return pickBy(props, (k) => RE_DATA_PROP.test(k));\n}\n","/**\n * In general, we try not to expose react-aria's Collections API to Plume users.\n * The Collections API is how react-aria users pass data about collections of\n * things using the built-in Item and Section components, which are abstract,\n * metadata-only components that don't render anything but only serve to specify\n * data.  For example, here's how you would use react-spectrum's Picker:\n *\n *   <Picker>\n *     <Section title=\"Asia\">\n *       <Item key=\"taiwan\">Taiwan</Item>\n *       <Item key=\"japan\">Japan</Item>\n *       <Item key=\"china\">China</Item>\n *     </Section>\n *     <Section title=\"Europe\">\n *       <Item key=\"germany\">Germany</Item>\n *       <Item key=\"france\">France</Item>\n *     </Section>\n *   </Picker>\n *\n * You would re-use this same Item/Section components to pass similar things to\n * Menu, Tabs, etc.\n *\n * For Plasmic, this API is too abstract.  The user has explicitly designed components\n * like Select.Option and Select.OptionGroup, and it is weird that they don't actually\n * use these components. It is more natural to do:\n *\n *   <Select>\n *     <Select.OptionGroup title=\"Asia\">\n *       <Select.Option key=\"taiwan\">Taiwan</Select>\n *     </Select.OptionGroup>\n *   </Select>\n *\n * For Plume, we let users directly use the components they designed, both to collect\n * information and to perform actual rendering.  For example, for Plume,\n * you'd use Select.Option instead of Item, and Select.OptionGroup instead of Section.\n * This means that the Select.Option props will collect the same information Item\n * does.\n *\n * A component like Select.Option then serves two purposes:\n *\n * 1. Allow users to specify the collection of data, like in the above example\n *    Here, we're mainly interested in the props in those ReactElements so\n *    we can pass the Item/Section data onto react-aria's APIs.  We are not\n *    actually rendering these elements.\n * 2. Once react-aria's Collections API has gone through them and built\n *    Collection \"nodes\", we then create cloned versions of these elements\n *    with the corresponding node passed in as a secret prop.  These ReactElements\n *    are then actually used to _render_ the corresponding Option / OptionGroup.\n *\n * This file contains helper functions to help with implementing the above.\n *\n * Note also that most of the collections-based react-aria components expose\n * a parallel API that accepts a list of \"items\" and a render prop, instead\n * of list of Item/Section elements.  This is for efficiency, but we are opting\n * to only support the composite-component pattern for now for simplicity.\n */\n\nimport { Node } from \"@react-types/shared\";\nimport React from \"react\";\nimport { Item, Section } from \"@react-stately/collections\";\nimport { isString } from \"../common\";\nimport { getElementTypeName, toChildArray } from \"../react-utils\";\nimport { getPlumeType, PLUME_STRICT_MODE } from \"./plume-utils\";\n\nexport interface PlasmicLoaderProps<T> {\n  component: string;\n  componentProps: T;\n}\n\n/**\n * Props for a Plume component that corresponds to an Item\n */\nexport interface ItemLikeProps {\n  /**\n   * value key corresponding to this item. Not required if you use the\n   * `key` prop instead.\n   */\n  value?: string | null;\n\n  /**\n   * The text string value corresponding to this item. Used to support\n   * keyboard type-ahead.  If not specified, then will be derived from\n   * `children` if it is a string, or the `value` or `key`.\n   */\n  textValue?: string;\n\n  /**\n   * aria-label for this item.\n   */\n  \"aria-label\"?: string;\n\n  /**\n   * Primary content label for this item.\n   */\n  children?: React.ReactNode;\n\n  /**\n   * If true, this item will not be selectable.\n   */\n  isDisabled?: boolean;\n}\n\ntype LoaderAwareItemLikeProps =\n  | ItemLikeProps\n  | PlasmicLoaderProps<ItemLikeProps>;\n\n/**\n * Props for a Plume component that corresponds to a Section\n */\nexport interface SectionLikeProps {\n  /**\n   * Heading content of the title\n   */\n  title?: React.ReactNode;\n\n  /**\n   * aria-label for this section\n   */\n  \"aria-label\"?: string;\n\n  /**\n   * A list of items that belong in this group\n   */\n  children?: React.ReactNode;\n}\n\ntype LoaderAwareSectionLikeProps =\n  | SectionLikeProps\n  | PlasmicLoaderProps<SectionLikeProps>;\n\n/**\n * Given children of a component like Select or Menu, derive the items\n * that we will pass into the Collections API.  These will be\n * ReactElement<ItemLikeProps|SectionLikeProps>[].\n *\n * Will also assign keys to items by their index in the collection,\n * and collect the keys of disabled items.\n */\nexport function deriveItemsFromChildren<T extends React.ReactElement>(\n  children: React.ReactNode,\n  opts: {\n    itemPlumeType: string;\n    sectionPlumeType?: string;\n    invalidChildError?: string;\n    requireItemValue: boolean;\n  }\n) {\n  if (!children) {\n    return {\n      items: [] as T[],\n      disabledKeys: [] as React.Key[],\n    };\n  }\n\n  const { itemPlumeType, sectionPlumeType, invalidChildError } = opts;\n\n  // For Plume items without an explicit key, we assign a key as the index\n  // of the collection.\n  let itemCount = 0;\n  let sectionCount = 0;\n\n  const ensureValue = (element: React.ReactElement) => {\n    if (!propInChild(element, \"value\")) {\n      if (opts.requireItemValue && PLUME_STRICT_MODE) {\n        throw new Error(\n          `Must specify a \"value\" prop for ${getElementTypeName(element)}`\n        );\n      } else {\n        return cloneChild(element, { value: `${itemCount++}` });\n      }\n    } else {\n      // Still increment count even if key is present, so that the\n      // auto-assigned key really reflects the index\n      itemCount++;\n      return element;\n    }\n  };\n\n  const disabledKeys: React.Key[] = [];\n\n  const flattenedChildren = (\n    children: React.ReactNode\n  ): React.ReactElement[] => {\n    return toChildArray(children).flatMap((child) => {\n      if (React.isValidElement(child)) {\n        if (child.type === React.Fragment) {\n          return flattenedChildren(child.props.children);\n        }\n        const type = getPlumeType(child);\n        if (type === itemPlumeType) {\n          child = ensureValue(child);\n          const childKey = getItemLikeKey(child);\n          if (getChildProp(child, \"isDisabled\") && !!childKey) {\n            disabledKeys.push(childKey);\n          }\n          return [child];\n        }\n        if (type === sectionPlumeType) {\n          return [\n            cloneChild(child, {\n              // key of section doesn't actually matter, just needs\n              // to be unique\n              key: child.key ?? `section-${sectionCount++}`,\n              children: flattenedChildren(getChildProp(child, \"children\")),\n            }),\n          ];\n        }\n      }\n\n      if (PLUME_STRICT_MODE) {\n        throw new Error(invalidChildError ?? `Unexpected child`);\n      } else {\n        return [];\n      }\n    });\n  };\n\n  return { items: flattenedChildren(children) as T[], disabledKeys };\n}\n\nexport function useDerivedItemsFromChildren<T extends React.ReactElement>(\n  children: React.ReactNode,\n  opts: {\n    itemPlumeType: string;\n    sectionPlumeType?: string;\n    invalidChildError?: string;\n    requireItemValue: boolean;\n  }\n) {\n  const {\n    itemPlumeType,\n    sectionPlumeType,\n    invalidChildError,\n    requireItemValue,\n  } = opts;\n  return React.useMemo(() => {\n    return deriveItemsFromChildren<T>(children, {\n      itemPlumeType,\n      sectionPlumeType,\n      invalidChildError,\n      requireItemValue,\n    });\n  }, [\n    children,\n    itemPlumeType,\n    sectionPlumeType,\n    invalidChildError,\n    requireItemValue,\n  ]);\n}\n\n/**\n * Given a Collection node, create the React element that we should use\n * to render it.\n */\nexport function renderCollectionNode(node: Node<any>) {\n  // node.rendered should already have our item-like or section-like Plume\n  // component elements, so we just need to clone them with a secret\n  // _node prop that we use to render.\n  return cloneChild(node.rendered as React.ReactElement, {\n    _node: node,\n    key: node.key,\n  });\n}\n\n/**\n * Renders a item-like or section-like Plume component element into an\n * Item or a Section element.\n */\nexport function renderAsCollectionChild<\n  T extends React.ReactElement<\n    LoaderAwareItemLikeProps | LoaderAwareSectionLikeProps\n  >\n>(\n  child: T,\n  opts: {\n    itemPlumeType: string;\n    sectionPlumeType?: string;\n  }\n) {\n  const plumeType = getPlumeType(child);\n  if (plumeType === opts.itemPlumeType) {\n    const option = child as React.ReactElement<LoaderAwareItemLikeProps>;\n\n    // We look at the children passed to the item-like element, and derive key\n    // or textValue from it if it is a string\n    const content = getChildProp(option, \"children\");\n\n    // The children render prop needs to return an <Item/>\n    return (\n      <Item\n        // We use ItemLike.value if the user explicitly specified a value,\n        // and we fallback to key.  If the user specified neither, then\n        // the Collections API will generate a unique key for this item.\n        key={getItemLikeKey(option)}\n        // textValue is either explicitly specified by the user, or we\n        // try to derive it if `content` is a string.\n        textValue={\n          getChildProp(option, \"textValue\") ??\n          (isString(content)\n            ? content\n            : propInChild(option, \"value\")\n            ? getChildProp(option, \"value\")\n            : option.key)\n        }\n        aria-label={getChildProp(option, \"aria-label\")}\n      >\n        {\n          // Note that what we setting the item-like element as the children\n          // here, and not content; we want the entire item-like Plume element to\n          // end up as Node.rendered.\n        }\n        {option}\n      </Item>\n    );\n  } else {\n    const group = child as React.ReactElement<LoaderAwareSectionLikeProps>;\n    return (\n      <Section\n        // Note that we are using the whole section-like element as the title\n        // here, and not group.props.title; we want the entire section-like\n        // Plume element to end up as Node.rendered.\n        title={group}\n        aria-label={getChildProp(group, \"aria-label\")}\n        // We are flattening and deriving the descendant Options as items here.\n        // group.props.children should've already been cleaned up by\n        // deriveItemsFromChildren()\n        items={getChildProp(group, \"children\") as React.ReactElement[]}\n      >\n        {\n          // We use the same render function to turn descendent Options into Items\n        }\n        {(c: React.ReactElement) => renderAsCollectionChild(c, opts)}\n      </Section>\n    );\n  }\n}\n\nfunction getItemLikeKey(element: React.ReactElement<LoaderAwareItemLikeProps>) {\n  return getChildProp(element, \"value\") ?? element.key;\n}\n\n// PlasmicLoader-aware function to get prop from child.\nexport function getChildProp(child: React.ReactElement, prop: string) {\n  return \"componentProps\" in child.props\n    ? child.props.componentProps[prop]\n    : child.props[prop];\n}\n\n// PlasmicLoader-aware function to check `if (prop in element.props)`.\nfunction propInChild(child: React.ReactElement, prop: string): boolean {\n  return \"componentProps\" in child.props\n    ? prop in child.props.componentProps\n    : prop in child.props;\n}\n\n// PlasmicLoader-aware function to clone React element.\nfunction cloneChild(child: React.ReactElement, props: Record<string, any>) {\n  if ((child.type as any).getPlumeType) {\n    // If React element has getPlumeType(), assume that it is PlasmicLoader,\n    // so add nodeProps to componentProps instead of element props.\n    return React.cloneElement(child, {\n      componentProps: {\n        ...child.props.componentProps,\n        ...props,\n      },\n      ...(props.key ? { key: props.key } : {}),\n    });\n  }\n\n  return React.cloneElement(child, props);\n}\n","import type { Placement } from \"@react-types/overlays\";\nimport type { FocusStrategy } from \"@react-types/shared\";\nimport * as React from \"react\";\nimport type { OverlayTriggerState } from \"@react-stately/overlays\";\n\nexport interface TriggeredOverlayContextValue {\n  triggerRef: React.RefObject<HTMLElement>;\n  state: OverlayTriggerState;\n  autoFocus?: boolean | FocusStrategy;\n\n  placement?: Placement;\n  overlayMatchTriggerWidth?: boolean;\n  overlayMinTriggerWidth?: boolean;\n  overlayWidth?: number;\n}\n\nexport const TriggeredOverlayContext = React.createContext<\n  TriggeredOverlayContextValue | undefined\n>(undefined);\n","import * as React from \"react\";\nimport type { TreeState } from \"@react-stately/tree\";\nimport type { BaseMenuProps } from \"./menu\";\n\nexport interface MenuContextValue {\n  menuProps: BaseMenuProps;\n  state: TreeState<any>;\n}\n\nexport const MenuContext = React.createContext<MenuContextValue | undefined>(\n  undefined\n);\n","import { AriaMenuProps } from \"@react-types/menu\";\nimport { AriaLabelingProps, DOMProps } from \"@react-types/shared\";\nimport * as React from \"react\";\nimport { useMenu as useAriaMenu } from \"@react-aria/menu\";\nimport { useTreeState } from \"@react-stately/tree\";\nimport { pick } from \"../../common\";\nimport { mergeProps } from \"../../react-utils\";\nimport { Overrides } from \"../../render/elements\";\nimport { useEnsureSSRProvider } from \"../../render/ssr\";\nimport {\n  renderAsCollectionChild,\n  renderCollectionNode,\n  useDerivedItemsFromChildren,\n} from \"../collection-utils\";\nimport {\n  AnyPlasmicClass,\n  noOutline,\n  PlasmicClassArgs,\n  PlasmicClassOverrides,\n  PlasmicClassVariants,\n  VariantDef,\n} from \"../plume-utils\";\nimport { getStyleProps, StyleProps } from \"../props-utils\";\nimport { TriggeredOverlayContext } from \"../triggered-overlay/context\";\nimport { MenuContext } from \"./context\";\n\nexport interface BaseMenuProps extends DOMProps, AriaLabelingProps, StyleProps {\n  /**\n   * List of `Menu.Item`s or `Menu.Group`s that make up the menu\n   */\n  children?: React.ReactNode;\n\n  /**\n   * Called with the value of a `Menu.Item` when it is selected.\n   */\n  onAction?: (value: string) => void;\n}\n\nexport type MenuRef = React.Ref<MenuRefValue>;\nexport interface MenuRefValue extends MenuState {\n  getRoot: () => HTMLElement | null;\n}\n\nconst COLLECTION_OPTS = {\n  itemPlumeType: \"menu-item\",\n  sectionPlumeType: \"menu-group\",\n};\n\nexport interface MenuConfig<C extends AnyPlasmicClass> {\n  isPlacedTopVariant?: VariantDef<PlasmicClassVariants<C>>;\n  isPlacedBottomVariant?: VariantDef<PlasmicClassVariants<C>>;\n  isPlacedLeftVariant?: VariantDef<PlasmicClassVariants<C>>;\n  isPlacedRightVariant?: VariantDef<PlasmicClassVariants<C>>;\n\n  itemsSlot: keyof PlasmicClassArgs<C>;\n  itemsContainer: keyof PlasmicClassOverrides<C>;\n  root: keyof PlasmicClassOverrides<C>;\n}\n\n/**\n * Converts props from BaseMenuProps to react-aria's useMenu() props.\n */\nfunction asAriaMenuProps(props: BaseMenuProps) {\n  const { children, ...rest } = props;\n  const { items, disabledKeys } = useDerivedItemsFromChildren(children, {\n    ...COLLECTION_OPTS,\n    invalidChildError: `Can only use Menu.Item and Menu.Group as children to Menu`,\n    requireItemValue: false,\n  });\n\n  const collectionChildRenderer = React.useCallback(\n    (child) => renderAsCollectionChild(child, COLLECTION_OPTS),\n    []\n  );\n\n  return {\n    ariaProps: {\n      ...rest,\n      children: collectionChildRenderer,\n      items,\n      disabledKeys,\n    } as AriaMenuProps<any>,\n  };\n}\n\nexport interface MenuState {\n  getFocusedValue: () => string | null;\n  setFocusedValue: (value: string) => void;\n}\n\nexport function useMenu<P extends BaseMenuProps, C extends AnyPlasmicClass>(\n  plasmicClass: C,\n  props: P,\n  config: MenuConfig<C>,\n  ref: MenuRef = null\n) {\n  useEnsureSSRProvider();\n  const { ariaProps } = asAriaMenuProps(props);\n  const triggerContext = React.useContext(TriggeredOverlayContext);\n  const rootRef = React.useRef<HTMLElement>(null);\n\n  const state = useTreeState(ariaProps);\n\n  const menuListRef = React.useRef<HTMLUListElement>(null);\n\n  const { menuProps } = useAriaMenu(\n    {\n      ...ariaProps,\n      autoFocus: triggerContext?.autoFocus,\n    },\n    state,\n    menuListRef\n  );\n\n  const contextValue = React.useMemo(\n    () => ({ state, menuProps: props }),\n    [state, props]\n  );\n\n  const variants = {\n    ...pick(props, ...plasmicClass.internalVariantProps),\n  };\n\n  const overrides: Overrides = {\n    [config.root]: {\n      props: mergeProps(getStyleProps(props), {\n        ref: rootRef,\n      }),\n    },\n    [config.itemsContainer]: {\n      as: \"ul\",\n      props: mergeProps(menuProps, {\n        ref: menuListRef,\n        style: {\n          ...noOutline(),\n        },\n      }),\n    },\n  };\n\n  const args = {\n    ...pick(props, ...plasmicClass.internalArgProps),\n    [config.itemsSlot]: (\n      <MenuContext.Provider value={contextValue}>\n        {Array.from(state.collection).map((node) => renderCollectionNode(node))}\n      </MenuContext.Provider>\n    ),\n  };\n\n  const plumeState: MenuState = React.useMemo(\n    () => ({\n      getFocusedValue: () => state.selectionManager.focusedKey as string | null,\n      setFocusedValue: (value: string) =>\n        state.selectionManager.setFocusedKey(value),\n    }),\n    [state]\n  );\n\n  React.useImperativeHandle(\n    ref,\n    () => ({\n      getRoot: () => rootRef.current,\n      getFocusedValue: () => plumeState.getFocusedValue(),\n      setFocusedValue: (key) => plumeState.setFocusedValue(key),\n    }),\n    [rootRef, plumeState]\n  );\n\n  return {\n    plasmicProps: {\n      variants: variants as PlasmicClassVariants<C>,\n      args: args as PlasmicClassArgs<C>,\n      overrides: overrides as PlasmicClassOverrides<C>,\n    },\n    state: plumeState,\n  };\n}\n","import { Placement } from \"@react-types/overlays\";\nimport * as React from \"react\";\nimport { useMenuTrigger as useAriaMenuTrigger } from \"@react-aria/menu\";\nimport { usePress } from \"@react-aria/interactions\";\nimport { MenuTriggerState } from \"@react-stately/menu\";\nimport { mergeProps } from \"../../react-utils\";\nimport { BaseMenuProps } from \"../menu/menu\";\nimport { getPlumeType, PLUME_STRICT_MODE } from \"../plume-utils\";\nimport { TriggeredOverlayContextValue } from \"../triggered-overlay/context\";\n\n/**\n * A menu trigger hook that combines react-aria's useMenuTrigger, useAriaMenuTrigger,\n * useOverlayPosition, useOverlay, and usePress\n */\nexport function useMenuTrigger(\n  opts: {\n    isDisabled?: boolean;\n    triggerRef: React.RefObject<HTMLElement>;\n    placement?: Placement;\n    menuMatchTriggerWidth?: boolean;\n    menuWidth?: number;\n    menu:\n      | React.ReactElement<BaseMenuProps>\n      | (() => React.ReactElement<BaseMenuProps>);\n  },\n  state: MenuTriggerState\n) {\n  const {\n    triggerRef,\n    isDisabled,\n    placement,\n    menuMatchTriggerWidth,\n    menuWidth,\n    menu,\n  } = opts;\n\n  const { menuTriggerProps: triggerPressProps, menuProps } = useAriaMenuTrigger(\n    {\n      type: \"menu\",\n      isDisabled,\n    },\n    state,\n    triggerRef\n  );\n\n  const { pressProps: triggerProps } = usePress({\n    ...triggerPressProps,\n    isDisabled,\n  });\n\n  const makeMenu = () => {\n    let realMenu = typeof menu === \"function\" ? menu() : menu;\n    if (!realMenu) {\n      return null;\n    }\n    if (getPlumeType(realMenu) !== \"menu\") {\n      if (PLUME_STRICT_MODE) {\n        throw new Error(`Must use an instance of the Menu component.`);\n      }\n      return null;\n    }\n\n    return React.cloneElement(realMenu, mergeProps(realMenu.props, menuProps));\n  };\n\n  const triggerContext: TriggeredOverlayContextValue = React.useMemo(\n    () => ({\n      triggerRef,\n      state,\n      autoFocus: state.focusStrategy ?? true,\n      placement,\n      overlayMatchTriggerWidth: menuMatchTriggerWidth,\n      overlayMinTriggerWidth: true,\n      overlayWidth: menuWidth,\n    }),\n    [triggerRef, state, placement, menuMatchTriggerWidth, menuWidth]\n  );\n\n  return {\n    triggerProps,\n    makeMenu,\n    triggerContext,\n  };\n}\n","import * as React from \"react\";\nimport type { ListState } from \"@react-stately/list\";\n\nexport const SelectContext = React.createContext<ListState<any> | undefined>(\n  undefined\n);\n","import { Placement } from \"@react-types/overlays\";\nimport { AriaSelectProps } from \"@react-types/select\";\nimport {\n  AriaLabelingProps,\n  DOMProps,\n  FocusableDOMProps,\n  FocusableProps,\n  InputBase,\n} from \"@react-types/shared\";\nimport * as React from \"react\";\nimport {\n  HiddenSelect,\n  useSelect as useAriaSelect,\n} from \"@react-aria/select\";\nimport {\n  useListBox\n} from \"@react-aria/listbox\";\nimport {\n  usePress\n} from \"@react-aria/interactions\";\nimport {\n  SelectState as AriaSelectState,\n  useSelectState as useAriaSelectState,\n} from \"@react-stately/select\";\nimport { pick } from \"../../common\";\nimport { mergeProps } from \"../../react-utils\";\nimport { Overrides } from \"../../render/elements\";\nimport { useEnsureSSRProvider } from \"../../render/ssr\";\nimport {\n  getChildProp,\n  renderAsCollectionChild,\n  renderCollectionNode,\n  useDerivedItemsFromChildren,\n} from \"../collection-utils\";\nimport {\n  AnyPlasmicClass,\n  mergeVariantToggles,\n  noOutline,\n  PlasmicClassArgs,\n  PlasmicClassOverrides,\n  PlasmicClassVariants,\n  VariantDef,\n} from \"../plume-utils\";\nimport { getStyleProps, StyleProps } from \"../props-utils\";\nimport {\n  TriggeredOverlayContext,\n  TriggeredOverlayContextValue,\n} from \"../triggered-overlay/context\";\nimport { SelectContext } from \"./context\";\nimport { BaseSelectOptionProps } from \"./select-option\";\nimport { BaseSelectOptionGroupProps } from \"./select-option-group\";\n\nexport interface BaseSelectProps\n  extends DOMProps,\n    AriaLabelingProps,\n    FocusableDOMProps,\n    InputBase,\n    FocusableProps,\n    StyleProps {\n  /**\n   * Key of the currently selected value\n   */\n  value?: string | null;\n\n  /**\n   * Event handler fired when currently selected value changes\n   */\n  onChange?: (value: string | null) => void;\n\n  /**\n   * Uncontrolled key of the default selected value\n   */\n  defaultValue?: string;\n\n  /**\n   * List of Select.Options\n   */\n  children?: React.ReactNode;\n\n  /**\n   * Whether the Select is currently open\n   */\n  isOpen?: boolean;\n\n  /**\n   * Event handler fired when Select's open state changes\n   */\n  onOpenChange?: (isOpen: boolean) => void;\n\n  /**\n   * Uncontrolled default open state\n   */\n  defaultOpen?: boolean;\n\n  /**\n   * Form name of the select element\n   */\n  name?: string;\n\n  /**\n   * By default, Select will render whatever is in Select.Option as the\n   * content in the trigger button when it is selected.  You can override\n   * what content by passing in `selectedContent` here.\n   */\n  selectedContent?: React.ReactNode;\n\n  /**\n   * Desired placement location of the Select dropdown\n   */\n  placement?: Placement;\n\n  /**\n   * If true, menu width will always match the trigger button width.\n   * If false, then menu width will have min-width matching the\n   * trigger button width.\n   */\n  menuMatchTriggerWidth?: boolean;\n\n  /**\n   * If set, menu width will be exactly this width, overriding\n   * menuMatchTriggerWidth.\n   */\n  menuWidth?: number;\n\n  /**\n   * Content to display when nothing is selected.\n   */\n  placeholder?: React.ReactNode;\n}\n\nconst COLLECTION_OPTS = {\n  itemPlumeType: \"select-option\",\n  sectionPlumeType: \"select-option-group\",\n};\n\ntype AriaOptionType = React.ReactElement<BaseSelectOptionProps>;\ntype AriaGroupType = React.ReactElement<BaseSelectOptionGroupProps>;\ntype AriaSelectItemType = AriaOptionType | AriaGroupType;\n\n/**\n * Converts props in our BaseSelectProps into props that react-aria's\n * useSelect() understands.\n *\n * Because we're not exposing the Collections API (see ./index.tsx),\n * we are converting our own API into props for useSelect.\n *\n * Specifically, in Plume's API,\n * - `children` flattens to a list of ReactElements of type Select.Option\n *   or Select.OptionGroup\n *\n * and we map it this way to the Collections API:\n * - `items` is a list of those flattened ReactElements from `children`!\n * - `children`, as a render prop, is supposed to take one of the `items`\n *   and return a `Section` or `Item` element. We take an Option/OptionGroup\n *   element, and use its props to render the appropriate `Section` or\n *   `Item`. The \"trick\" here is that we then stuff the Option element as\n *   `Item.children`, and the OptionGroup element as `Section.title`.\n *\n * When the Collections API does its work deriving `Node`s, the corresponding\n * Option/OptionGroup ReactElements will end up as `Node.rendered`.\n *\n * Then, when we are actually rendering the content of the dropdown, we\n * iterate through each collected `Node`, and renders\n * React.cloneElement(Node.rendered, {_node: node}).  This \"secretly\" passes\n * the derived collection `Node` as a prop to Option and OptionGroup, and they\n * can make use of the derived `Node.key` etc in their rendering functions.\n *\n * One thing to note here is that we never \"rendered\" the Option/OptionGroup\n * React elements that the user constructed; instead, we just looked at the\n * props used on those elements, and passed those onto the Collections API.\n * What gets rendered to the screen is the cloned version of these elements\n * with the secret derived `_node` prop.  That means Option and OptionGroup\n * render functions can assume that _node is passed in.\n */\nfunction useAriaSelectProps(props: BaseSelectProps) {\n  let {\n    value,\n    defaultValue,\n    children,\n    onChange,\n    placement,\n    menuMatchTriggerWidth,\n    menuWidth,\n    ...rest\n  } = props;\n\n  const { items, disabledKeys } = useDerivedItemsFromChildren(children, {\n    ...COLLECTION_OPTS,\n    invalidChildError: `Can only use Select.Option and Select.OptionGroup as children to Select`,\n    requireItemValue: true,\n  });\n\n  const collectionChildRenderer = React.useCallback(\n    (child) => renderAsCollectionChild(child, COLLECTION_OPTS),\n    []\n  );\n\n  const onSelectionChange = React.useMemo(() => {\n    if (onChange) {\n      return (val: string | null) =>\n        onChange!(\n          (val == null || val === \"null\" ? null : val) as string | null\n        );\n    } else {\n      return undefined;\n    }\n  }, [onChange]);\n\n  return {\n    ariaProps: {\n      ...rest,\n      children: collectionChildRenderer,\n      onSelectionChange,\n      items,\n      disabledKeys,\n      defaultSelectedKey: defaultValue,\n\n      // react-aria is picky about selectedKey; if it is null, it means \"no selection\";\n      // if it is undefined, it means \"uncontrolled\".  So here, if the user passes in a\n      // value prop, then we make sure selectedKey will be null and not undefined, so\n      // we don't accidentally enter uncontrolled mode.\n      ...(\"value\" in props && { selectedKey: value ?? null }),\n    } as AriaSelectProps<AriaSelectItemType>,\n  };\n}\n\nexport type SelectRef = React.Ref<SelectRefValue>;\n\nexport interface SelectRefValue extends SelectState {\n  getTrigger: () => HTMLElement | null;\n  getRoot: () => HTMLElement | null;\n  focus: () => void;\n  blur: () => void;\n}\n\ninterface SelectConfig<C extends AnyPlasmicClass> {\n  placeholderVariant?: VariantDef<PlasmicClassVariants<C>>;\n  isOpenVariant: VariantDef<PlasmicClassVariants<C>>;\n  isDisabledVariant?: VariantDef<PlasmicClassVariants<C>>;\n\n  triggerContentSlot: keyof PlasmicClassArgs<C>;\n  optionsSlot: keyof PlasmicClassArgs<C>;\n  placeholderSlot: keyof PlasmicClassArgs<C>;\n\n  root: keyof PlasmicClassOverrides<C>;\n  trigger: keyof PlasmicClassOverrides<C>;\n  overlay: keyof PlasmicClassOverrides<C>;\n  optionsContainer: keyof PlasmicClassOverrides<C>;\n}\n\ninterface SelectState {\n  open: () => void;\n  close: () => void;\n  isOpen: () => boolean;\n  getSelectedValue: () => string | null;\n  setSelectedValue: (value: string | null) => void;\n}\n\nexport function useSelect<P extends BaseSelectProps, C extends AnyPlasmicClass>(\n  plasmicClass: C,\n  props: P,\n  config: SelectConfig<C>,\n  ref: React.Ref<SelectRefValue> = null\n) {\n  useEnsureSSRProvider();\n  const { ariaProps } = useAriaSelectProps(props);\n  const { placement } = props;\n  const state = useAriaSelectState<AriaSelectItemType>(ariaProps);\n  const triggerRef = React.useRef<HTMLButtonElement>(null);\n  const rootRef = React.useRef<HTMLElement>(null);\n\n  const {\n    isDisabled,\n    name,\n    menuWidth,\n    menuMatchTriggerWidth,\n    autoFocus,\n    placeholder,\n    selectedContent,\n  } = props;\n\n  const { triggerProps: triggerPressProps, menuProps } = useAriaSelect(\n    ariaProps,\n    state,\n    triggerRef\n  );\n\n  const { pressProps: triggerProps } = usePress({\n    ...triggerPressProps,\n    isDisabled,\n  });\n\n  const triggerContent = state.selectedItem\n    ? selectedContent ?? getChildProp(state.selectedItem.value, \"children\")\n    : null;\n\n  const variants = {\n    ...pick(props, ...plasmicClass.internalVariantProps),\n    ...mergeVariantToggles(\n      { def: config.isOpenVariant, active: state.isOpen },\n      { def: config.placeholderVariant, active: !state.selectedItem },\n      { def: config.isDisabledVariant, active: isDisabled }\n    ),\n  };\n\n  const triggerContext: TriggeredOverlayContextValue = React.useMemo(\n    () => ({\n      triggerRef,\n      state,\n      placement,\n      overlayMatchTriggerWidth: menuMatchTriggerWidth,\n      overlayMinTriggerWidth: true,\n      overlayWidth: menuWidth,\n    }),\n    [triggerRef, state, placement, menuMatchTriggerWidth, menuWidth]\n  );\n\n  const overrides: Overrides = {\n    [config.root]: {\n      props: mergeProps(getStyleProps(props), {\n        ref: rootRef,\n      }),\n      wrapChildren: (children) => (\n        <>\n          <HiddenSelect\n            state={state}\n            triggerRef={triggerRef}\n            name={name}\n            isDisabled={isDisabled}\n          />\n          {children}\n        </>\n      ),\n    },\n    [config.trigger]: {\n      props: mergeProps(triggerProps, {\n        ref: triggerRef,\n        autoFocus,\n        disabled: !!isDisabled,\n        // Don't trigger form submission!\n        type: \"button\",\n      }),\n    },\n    [config.overlay]: {\n      wrap: (content) => (\n        <TriggeredOverlayContext.Provider value={triggerContext}>\n          {content}\n        </TriggeredOverlayContext.Provider>\n      ),\n    },\n    [config.optionsContainer]: {\n      wrap: (content) => (\n        <ListBoxWrapper state={state} menuProps={menuProps}>\n          {content as React.ReactElement}\n        </ListBoxWrapper>\n      ),\n    },\n  };\n\n  const args = {\n    ...pick(props, ...plasmicClass.internalArgProps),\n    [config.triggerContentSlot]: triggerContent,\n    [config.placeholderSlot]: placeholder,\n    [config.optionsSlot]: (\n      <SelectContext.Provider value={state}>\n        {Array.from(state.collection).map((node) => renderCollectionNode(node))}\n      </SelectContext.Provider>\n    ),\n  };\n\n  const plumeState: SelectState = React.useMemo(\n    () => ({\n      open: () => state.open(),\n      close: () => state.close(),\n      isOpen: () => state.isOpen,\n      getSelectedValue: () =>\n        state.selectedKey ? `${state.selectedKey}` : null,\n      setSelectedValue: (key) => state.setSelectedKey(key as any),\n    }),\n    [state]\n  );\n\n  React.useImperativeHandle(\n    ref,\n    () => ({\n      getRoot: () => rootRef.current,\n      getTrigger: () => triggerRef.current,\n      focus: () => triggerRef.current?.focus(),\n      blur: () => triggerRef.current?.blur(),\n      open: () => plumeState.open(),\n      close: () => plumeState.close(),\n      isOpen: () => plumeState.isOpen(),\n      getSelectedValue: () => plumeState.getSelectedValue(),\n      setSelectedValue: (key) => plumeState.setSelectedValue(key),\n    }),\n    [rootRef, triggerRef, plumeState]\n  );\n\n  return {\n    plasmicProps: {\n      variants: variants as PlasmicClassVariants<C>,\n      args: args as PlasmicClassArgs<C>,\n      overrides: overrides as PlasmicClassOverrides<C>,\n    },\n    state: plumeState,\n  };\n}\n\nfunction ListBoxWrapper(props: {\n  state: AriaSelectState<any>;\n  menuProps: React.HTMLAttributes<Element>;\n  children: React.ReactElement;\n}) {\n  const { state, menuProps, children } = props;\n\n  const ref = React.useRef<HTMLElement>(null);\n\n  const { listBoxProps } = useListBox(\n    {\n      ...menuProps,\n      isVirtualized: false,\n      autoFocus: state.focusStrategy || true,\n      disallowEmptySelection: true,\n    },\n    state,\n    ref\n  );\n\n  return React.cloneElement(\n    children,\n    mergeProps(children.props, listBoxProps, { style: noOutline(), ref })\n  );\n}\n","import get from \"dlv\";\nimport { $State } from \".\";\n\nexport function generateStateOnChangeProp(\n  $state: $State,\n  stateName: string,\n  dataReps: number[]\n): (val: any, path: (string | number)[]) => void {\n  return (val, path) => set($state, [stateName, ...dataReps, ...path], val);\n}\n\n/**\n * This function generate the state value prop for repeated states\n * Example:\n *   - parent[][].counter[].count\n * We need to pass `parent[index1][index2].counter to the child component\n */\nexport function generateStateValueProp(\n  $state: $State,\n  path: (string | number)[] // [\"parent\", 0, 1, \"counter\"]\n) {\n  return get($state, path);\n}\n\n/**\n * Forked from https://github.com/lukeed/dset\n * Changes: fixed setting a deep value to a proxy object\n */\nexport function set(obj: any, keys: any, val: any) {\n  keys = keys.split ? keys.split(\".\") : keys;\n  var i = 0,\n    l = keys.length,\n    t = obj,\n    x,\n    k;\n  while (i < l) {\n    k = keys[i++];\n    if (k === \"__proto__\" || k === \"constructor\" || k === \"prototype\") break;\n    if (i === l) {\n      t[k] = val;\n      t = t[k];\n    } else {\n      if (typeof (x = t[k]) === typeof keys) {\n        t = t[k] = x;\n      } else if (keys[i] * 0 !== 0 || !!~(\"\" + keys[i]).indexOf(\".\")) {\n        t[k] = {};\n        t = t[k];\n      } else {\n        t[k] = [];\n        t = t[k];\n      }\n    }\n  }\n}\n","import get from \"dlv\";\nimport deepEqual from \"fast-deep-equal\";\nimport React from \"react\";\nimport { proxy as createValtioProxy, ref, useSnapshot } from \"valtio\";\nimport { subscribeKey } from \"valtio/utils\";\nimport { set } from \"./helpers\";\n\nconst mkUntrackedValue = (o: any) => (typeof o === \"object\" ? ref(o) : o);\n\ntype InitFunc<T> = (\n  $props: Record<string, any>,\n  $state: $State,\n  indexes: number[]\n) => T;\ntype ObjectPath = (string | number)[];\n\nexport interface $State {\n  [key: string]: any;\n  registerInitFunc?: (path: string, f: InitFunc<any>) => any;\n}\n\ninterface Internal$StateSpec<T> extends $StateSpec<T> {\n  isRepeated: boolean;\n  pathObj: ObjectPath;\n}\n\ninterface Internal$StateInstance {\n  path: ObjectPath; // [\"counter\", 0, \"count\"]\n  specKey: string;\n}\n\nexport interface $StateSpec<T> {\n  // path of the state, like `count` or `list.selectedIndex`\n  path: string;\n  // if initial value is defined by a js expression\n  initFunc?: InitFunc<T>;\n  // if initial value is a hard-coded value\n  initVal?: T;\n  // Whether this state is private, readonly, or writable in\n  // this component\n  type: \"private\" | \"readonly\" | \"writable\";\n\n  // If writable, there should be a valueProp that maps props[valueProp]\n  // to the value of the state\n  valueProp?: string;\n\n  // If writable or readonly, there should be an onChangeProp where\n  // props[onChangeProp] is invoked whenever the value changes\n  onChangeProp?: string;\n}\n\ninterface Internal$State {\n  stateValues: Record<string, any>;\n  initStateValues: Record<string, any>;\n  unsubscriptionsByState: Record<string, (() => void)[]>;\n  specsByKey: Record<string, Internal$StateSpec<any>>;\n  statesInstanceBySpec: Map<string, Internal$StateInstance[]>;\n  existingStates: Map<string, Internal$StateInstance>;\n  registrationsQueue: { pathStr: string; f: InitFunc<any> }[];\n  props: any;\n}\n\nconst transformPathStringToObj = (str: string) => {\n  const splitStatePathPart = (state: string): string[] =>\n    state.endsWith(\"[]\")\n      ? [...splitStatePathPart(state.slice(0, -2)), \"[]\"]\n      : [state];\n  return str.split(\".\").flatMap(splitStatePathPart);\n};\n\nfunction shallowEqual<T>(a1: T[], a2: T[]) {\n  if (a1.length !== a2.length) {\n    return false;\n  }\n  for (let i = 0; i < a1.length; i++) {\n    if (a1[i] !== a2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction isNum(value: string | number | symbol): value is number {\n  return typeof value === \"symbol\" ? false : !isNaN(+value);\n}\n\nfunction saveNewState<T>(\n  $$state: Internal$State,\n  path: ObjectPath,\n  spec: Internal$StateSpec<T>\n) {\n  const key = JSON.stringify(path);\n  $$state.existingStates.set(key, { path, specKey: spec.path });\n  if (!$$state.statesInstanceBySpec.has(spec.path)) {\n    $$state.statesInstanceBySpec.set(spec.path, []);\n  }\n  $$state.statesInstanceBySpec\n    .get(spec.path)!\n    .push({ path, specKey: spec.path });\n}\n\nfunction create$StateProxy(\n  $$state: Internal$State,\n  handlers: (\n    path: ObjectPath,\n    spec: Internal$StateSpec<any>\n  ) => ProxyHandler<any>\n) {\n  const getNextKeyToSpecMap = (currPath: ObjectPath) =>\n    new Map(\n      Object.entries(\n        Object.values($$state.specsByKey)\n          .filter((spec) =>\n            shallowEqual(\n              currPath.map((p) => (isNum(p) ? \"[]\" : p)),\n              spec.pathObj.slice(0, currPath.length)\n            )\n          )\n          .reduce((agg, spec) => {\n            const nextKey = spec.pathObj[currPath.length];\n            if (!(nextKey in agg)) {\n              agg[nextKey] = [];\n            }\n            agg[nextKey].push(spec);\n            return agg;\n          }, {} as Record<string, Internal$StateSpec<any>[]>)\n      )\n    );\n  const rec = (currPath: ObjectPath) => {\n    const nextKeyToSpecs = getNextKeyToSpecMap(currPath);\n    const getSpecForProperty = (property: string | number | symbol) => {\n      return nextKeyToSpecs.has(\"[]\") && isNum(property)\n        ? nextKeyToSpecs.get(\"[]\")?.[0]\n        : typeof property === \"string\" && nextKeyToSpecs.has(property)\n        ? nextKeyToSpecs.get(property)?.[0]\n        : undefined;\n    };\n    const getNextPath = (property: string | number | symbol) => [\n      ...currPath,\n      isNum(property) ? +property : (property as string),\n    ];\n\n    return new Proxy(nextKeyToSpecs.has(\"[]\") ? ([] as any) : ({} as any), {\n      deleteProperty(target, property) {\n        const prefixPath = getNextPath(property);\n        const specKeysToUpdate = new Set<string>();\n        $$state.existingStates.forEach(({ path, specKey }) => {\n          if (\n            path.length >= prefixPath.length &&\n            shallowEqual(path.slice(0, prefixPath.length), prefixPath)\n          ) {\n            deleteState($$state, path);\n            specKeysToUpdate.add(specKey);\n          }\n        });\n        specKeysToUpdate.forEach((specKey) => {\n          const spec = $$state.specsByKey[specKey];\n          if (spec.onChangeProp) {\n            $$state.props[spec.onChangeProp]?.(\n              get($$state.stateValues, currPath),\n              currPath\n            );\n          }\n        });\n        return Reflect.deleteProperty(target, property);\n      },\n      get(target, property, receiver) {\n        const spec = getSpecForProperty(property);\n        if (spec && typeof property !== \"symbol\") {\n          const nextPath = getNextPath(property);\n          if (spec.pathObj.length === currPath.length + 1) {\n            // reached the end of the spec\n            target[property] = handlers(nextPath, spec).get?.(\n              target,\n              property,\n              receiver\n            );\n          } else if (!(property in target)) {\n            target[property] = rec(nextPath);\n          }\n        }\n        return Reflect.get(target, property, receiver);\n      },\n      set(target, property, value, receiver) {\n        const spec = getSpecForProperty(property);\n        const nextPath = getNextPath(property);\n        if (spec && typeof property !== \"symbol\") {\n          if (spec.pathObj.length === currPath.length + 1) {\n            // reached the end of the spec\n            target[property] = handlers(nextPath, spec).set?.(\n              target,\n              property,\n              value,\n              receiver\n            );\n            return Reflect.set(target, property, value, receiver);\n          } else if (typeof value === \"object\") {\n            target[property] = rec(nextPath);\n            for (const key of Object.keys(value)) {\n              target[property][key] = value[key];\n            }\n            return true;\n          }\n        }\n        if (property === \"registerInitFunc\" && currPath.length === 0) {\n          return Reflect.set(target, property, value, receiver);\n        }\n        if (nextKeyToSpecs.has(\"[]\")) {\n          set($$state.stateValues, nextPath, value);\n          nextKeyToSpecs.get(\"[]\")?.forEach((spec) => {\n            if (spec?.onChangeProp) {\n              $$state.props[spec.onChangeProp]?.(value, nextPath);\n            }\n          });\n          return Reflect.set(target, property, value, receiver);\n        }\n        // invalid setting a value that doesn't make part of the spec\n        return false;\n      },\n    });\n  };\n\n  return rec([]);\n}\n\nconst deleteState = ($$state: Internal$State, path: ObjectPath) => {\n  const key = JSON.stringify(path);\n  $$state.unsubscriptionsByState[key]?.forEach((f: any) => f());\n  delete $$state.unsubscriptionsByState[key];\n  $$state.existingStates.delete(key);\n\n  // delete get($$state.stateValues, path.slice(-1))[path.slice(-1)[0]];\n  // delete get($$state.initStateValues, path.slice(-1))[path.slice(-1)[0]];\n};\n\nconst getIndexes = (path: ObjectPath, spec: Internal$StateSpec<any>) => {\n  const indexes = [];\n  if (path.length !== spec.pathObj.length) {\n    throw new Error(\n      \"Unexpected error: state path and spec path have different lengths\"\n    );\n  }\n  for (let i = 0; i < spec.pathObj.length; i++) {\n    if (spec.pathObj[i] === \"[]\") {\n      indexes.push(path[i] as number);\n    }\n  }\n  return indexes;\n};\n\nfunction initializeStateValue(\n  $$state: Internal$State,\n  initialStatePath: ObjectPath,\n  initialSpec: Internal$StateSpec<any>\n) {\n  const initialStateKey = JSON.stringify(initialStatePath);\n  const stateAccess: Set<{\n    path: ObjectPath;\n    spec: Internal$StateSpec<any>;\n  }> = new Set();\n  const $state = create$StateProxy($$state, (path, spec) => ({\n    get() {\n      const key = JSON.stringify(path);\n      stateAccess.add({ path, spec });\n      if (spec.valueProp) {\n        return !spec.isRepeated\n          ? $$state.props[spec.valueProp]\n          : get($$state.props[spec.valueProp], path.slice(1));\n      }\n      if ($$state.existingStates.has(key)) {\n        // is already initialized\n        return get($$state.stateValues, path);\n      } else if (spec.initFunc) {\n        initializeStateValue($$state, path, spec);\n      }\n      return get($$state.stateValues, path);\n    },\n    set() {\n      throw new Error(`Cannot update state values during initialization`);\n    },\n  }));\n\n  $$state.unsubscriptionsByState[initialStateKey]?.forEach((f: any) => f());\n  $$state.unsubscriptionsByState[initialStateKey] = [];\n  stateAccess.forEach(({ path, spec }) => {\n    const unsubscribe = subscribeKey(\n      get($$state.stateValues, path.slice(-1)),\n      path.slice(-1)[0],\n      () =>\n        set(\n          $$state.stateValues,\n          initialStatePath,\n          mkUntrackedValue(\n            initialSpec.initFunc!($$state.props, $state, getIndexes(path, spec))\n          )\n        )\n    );\n    $$state.unsubscriptionsByState[initialStateKey].push(unsubscribe);\n  });\n\n  const untrackedInitialValue = mkUntrackedValue(\n    initialSpec.initFunc!(\n      $$state.props,\n      $state,\n      getIndexes(initialStatePath, initialSpec)\n    )\n  );\n  set($$state.initStateValues, initialStatePath, untrackedInitialValue);\n  set($$state.stateValues, initialStatePath, untrackedInitialValue);\n  return untrackedInitialValue;\n}\n\nexport function useDollarState(\n  specs: $StateSpec<any>[],\n  props: Record<string, any>\n) {\n  const $$state = React.useRef(\n    createValtioProxy<Internal$State>({\n      stateValues: {},\n      initStateValues: {},\n      specsByKey: Object.fromEntries(\n        specs.map((spec) => [\n          spec.path,\n          {\n            ...spec,\n            pathObj: transformPathStringToObj(spec.path),\n            isRepeated: spec.path\n              .split(\".\")\n              .some((part) => part.endsWith(\"[]\")),\n          },\n        ])\n      ),\n      statesInstanceBySpec: new Map<string, Internal$StateInstance[]>(),\n      existingStates: new Map<string, Internal$StateInstance>(),\n      unsubscriptionsByState: {},\n      props: undefined,\n      registrationsQueue: [],\n    })\n  ).current;\n  $$state.props = mkUntrackedValue(props);\n\n  const $state = React.useRef(\n    Object.assign(\n      create$StateProxy($$state, (path, spec) => {\n        const key = JSON.stringify(path);\n        if (!$$state.existingStates.has(key)) {\n          saveNewState($$state, path, spec);\n          const untrackedValue = !spec.initFunc\n            ? mkUntrackedValue(spec.initVal ?? undefined)\n            : initializeStateValue($$state, path, spec);\n          set($$state.stateValues, path, untrackedValue);\n          set($$state.initStateValues, path, untrackedValue);\n        }\n        return {\n          get() {\n            if (spec.valueProp) {\n              const value = !spec.isRepeated\n                ? $$state.props[spec.valueProp]\n                : get($$state.props[spec.valueProp], path.slice(1));\n              return value;\n            } else {\n              return get($$state.stateValues, path);\n            }\n          },\n          set(_t, _p, value) {\n            set($$state.stateValues, path, mkUntrackedValue(value));\n            if (spec.onChangeProp) {\n              $$state.props[spec.onChangeProp]?.(value, path);\n            }\n            return true;\n          },\n        };\n      }),\n      {\n        registerInitFunc: function <T>(pathStr: string, f: InitFunc<T>) {\n          if (\n            $$state.statesInstanceBySpec\n              .get(pathStr)\n              ?.some(\n                ({ path, specKey }) =>\n                  !deepEqual(\n                    get($$state.initStateValues, path),\n                    f(\n                      props,\n                      $state,\n                      getIndexes(path, $$state.specsByKey[specKey])\n                    )\n                  )\n              )\n          ) {\n            $$state.registrationsQueue.push({ pathStr, f });\n          }\n        },\n      }\n    )\n  ).current;\n\n  // For each spec with an initFunc, evaluate it and see if\n  // the init value has changed. If so, reset its state.\n  const resetSpecs: { path: ObjectPath; spec: Internal$StateSpec<any> }[] = [];\n  $$state.existingStates.forEach(({ path, specKey }) => {\n    const spec = $$state.specsByKey[specKey];\n    if (spec.initFunc) {\n      const newInit = spec.initFunc(props, $state, getIndexes(path, spec));\n      if (!deepEqual(newInit, get($$state.initStateValues, path))) {\n        resetSpecs.push({ path, spec });\n      }\n    }\n  });\n  React.useLayoutEffect(() => {\n    resetSpecs.forEach(({ path, spec }) => {\n      const newInit = initializeStateValue($$state, path, spec);\n      if (spec.onChangeProp) {\n        $$state.props[spec.onChangeProp]?.(newInit, path);\n      }\n    });\n  }, [props, resetSpecs]);\n  React.useLayoutEffect(() => {\n    $$state.registrationsQueue.forEach(({ f, pathStr }) => {\n      $$state.specsByKey[pathStr].initFunc = f;\n    });\n    $$state.registrationsQueue = [];\n  }, [$$state.registrationsQueue]);\n\n  // Re-render if any value changed in one of these objects\n  useSnapshot($$state.stateValues, { sync: true });\n  useSnapshot($$state.specsByKey, { sync: true });\n\n  return $state;\n}\n\nexport default useDollarState;\n\n// Simple version of $state useDollarState for read-only\nexport function useCanvasDollarState(\n  specs: $StateSpec<any>[],\n  props: Record<string, any>\n) {\n  const $$state = createValtioProxy<Internal$State>({\n    stateValues: {},\n    initStateValues: {},\n    specsByKey: Object.fromEntries(\n      specs.map((spec) => [\n        spec.path,\n        {\n          ...spec,\n          pathObj: transformPathStringToObj(spec.path),\n          isRepeated: spec.path.split(\".\").some((part) => part.endsWith(\"[]\")),\n        },\n      ])\n    ),\n    statesInstanceBySpec: new Map<string, Internal$StateInstance[]>(),\n    existingStates: new Map<string, Internal$StateInstance>(),\n    unsubscriptionsByState: {},\n    props: undefined,\n    registrationsQueue: [],\n  });\n  $$state.props = mkUntrackedValue(props);\n\n  const $state = create$StateProxy($$state, (path, spec) => {\n    return {\n      get() {\n        return get($$state.stateValues, path);\n      },\n      set(_t, _p, value) {\n        set($$state.stateValues, path, mkUntrackedValue(value));\n        if (spec.onChangeProp) {\n          $$state.props[spec.onChangeProp]?.(value, path);\n        }\n        return true;\n      },\n    };\n  });\n  for (const spec of specs) {\n    const path = transformPathStringToObj(spec.path);\n    const init = spec.valueProp\n      ? $$state.props[spec.valueProp]\n      : spec.initVal\n      ? spec.initVal\n      : spec.initFunc\n      ? initializeStateValue($$state, path, $$state.specsByKey[spec.path])\n      : undefined;\n    set($state, path, init);\n  }\n  return $state;\n}\n","import { Placement } from \"@react-types/overlays\";\nimport * as React from \"react\";\nimport { useMenuTriggerState } from \"@react-stately/menu\";\nimport { mergeProps } from \"../../react-utils\";\nimport { BaseMenuProps } from \"../menu/menu\";\nimport { TriggeredOverlayContext } from \"../triggered-overlay/context\";\nimport { useMenuTrigger } from \"./menu-trigger\";\n\nexport interface DropdownMenuProps {\n  /**\n   * A ReactElement that takes in a `ref` as well as the usual mouse and\n   * pointer events. The dropdown menu will be positioned relative to this\n   * trigger.\n   */\n  children: React.ReactElement;\n\n  /**\n   * The menu to show; must be either a ReactElement of Menu type, or\n   * a function that creates one if you prefer to delay creating it until\n   * the menu has been triggered.\n   */\n  menu:\n    | React.ReactElement<BaseMenuProps>\n    | (() => React.ReactElement<BaseMenuProps>);\n\n  /**\n   * Where to place the menu relative to the trigger.\n   */\n  placement?: Placement;\n\n  /**\n   * Whether the menu is currently shown.\n   */\n  isOpen?: boolean;\n\n  /**\n   * Uncontrolled open state.\n   */\n  defaultOpen?: boolean;\n\n  /**\n   * Event handler fired when Menu's open state changes\n   */\n  onOpenChange?: (isOpen: boolean) => void;\n}\n\nexport function DropdownMenu(props: DropdownMenuProps) {\n  const {\n    isOpen,\n    defaultOpen,\n    onOpenChange,\n    children,\n    placement,\n    menu,\n  } = props;\n\n  const triggerRef = React.useRef<HTMLElement>(null);\n\n  const state = useMenuTriggerState({\n    isOpen,\n    defaultOpen,\n    onOpenChange,\n    shouldFlip: true,\n  });\n\n  const { triggerProps, makeMenu, triggerContext } = useMenuTrigger(\n    {\n      triggerRef,\n      placement,\n      menu,\n    },\n    state\n  );\n\n  return (\n    <TriggeredOverlayContext.Provider value={triggerContext}>\n      {React.cloneElement(\n        children,\n        mergeProps(children.props, triggerProps, { ref: triggerRef })\n      )}\n      {state.isOpen && makeMenu()}\n    </TriggeredOverlayContext.Provider>\n  );\n}\n","import * as React from \"react\";\n\nexport function PlasmicIcon(\n  props: React.ComponentProps<\"svg\"> & {\n    PlasmicIconType: React.ComponentType;\n  }\n) {\n  const { PlasmicIconType, ...rest } = props;\n  return <PlasmicIconType {...rest} />;\n}\n","const isDefaultValue = (val: string) => val === \"PLEASE_RENDER_INSIDE_PROVIDER\";\nconst seenDefaultVariants: Record<string, boolean> = {};\nexport function ensureGlobalVariants<T extends Record<string, any>>(\n  globalVariantValues: T\n) {\n  Object.entries(globalVariantValues)\n    .filter(([_, value]) => isDefaultValue(value))\n    .forEach(([key, _]) => {\n      (globalVariantValues as any)[key] = undefined;\n\n      if (!seenDefaultVariants[key] && process.env.NODE_ENV === \"development\") {\n        seenDefaultVariants[key] = true;\n        const providerName = `${key[0].toUpperCase()}${key.substring(\n          1\n        )}Context.Provider`;\n        console.warn(\n          `Plasmic context value for global variant \"${key}\" was not provided; please use ${providerName} at the root of your React app. Learn More: https://www.plasmic.app/learn/other-assets/#global-variants`\n        );\n      }\n    });\n  return globalVariantValues;\n}\n","import * as React from \"react\";\nimport { omit, pick } from \"../../common\";\nimport { Overrides } from \"../../render/elements\";\nimport {\n  AnyPlasmicClass,\n  mergeVariantToggles,\n  PlasmicClassArgs,\n  PlasmicClassOverrides,\n  PlasmicClassVariants,\n  VariantDef,\n} from \"../plume-utils\";\n\ninterface CommonProps {\n  showStartIcon?: boolean;\n  showEndIcon?: boolean;\n  startIcon?: React.ReactNode;\n  endIcon?: React.ReactNode;\n  children?: React.ReactNode;\n  isDisabled?: boolean;\n}\n\ninterface HtmlButtonProps\n  extends Omit<React.ComponentProps<\"button\">, \"ref\" | \"disabled\"> {}\n\ninterface HtmlAnchorProps\n  extends Omit<React.ComponentProps<\"a\">, \"ref\" | \"href\"> {\n  link?: string;\n}\n\nexport type BaseButtonProps = CommonProps & HtmlButtonProps & HtmlAnchorProps;\n\nexport type HtmlAnchorOnlyProps = Exclude<\n  keyof HtmlAnchorProps,\n  keyof HtmlButtonProps\n>;\nexport type HtmlButtonOnlyProps = Exclude<\n  keyof HtmlButtonProps,\n  keyof HtmlAnchorProps\n>;\n\nexport type ButtonRef = React.Ref<HTMLButtonElement | HTMLAnchorElement>;\n\ninterface ButtonConfig<C extends AnyPlasmicClass> {\n  showStartIconVariant: VariantDef<PlasmicClassVariants<C>>;\n  showEndIconVariant?: VariantDef<PlasmicClassVariants<C>>;\n  isDisabledVariant?: VariantDef<PlasmicClassVariants<C>>;\n  startIconSlot?: keyof PlasmicClassArgs<C>;\n  endIconSlot?: keyof PlasmicClassArgs<C>;\n  contentSlot: keyof PlasmicClassArgs<C>;\n  root: keyof PlasmicClassOverrides<C>;\n}\n\nexport function useButton<P extends BaseButtonProps, C extends AnyPlasmicClass>(\n  plasmicClass: C,\n  props: P,\n  config: ButtonConfig<C>,\n  ref: ButtonRef = null\n) {\n  const {\n    link,\n    isDisabled,\n    startIcon,\n    endIcon,\n    showStartIcon,\n    showEndIcon,\n    children,\n    ...rest\n  } = props;\n  const variants = {\n    ...pick(props, ...plasmicClass.internalVariantProps),\n    ...mergeVariantToggles(\n      { def: config.showStartIconVariant, active: showStartIcon },\n      { def: config.showEndIconVariant, active: showEndIcon },\n      { def: config.isDisabledVariant, active: isDisabled }\n    ),\n  };\n\n  const args = {\n    ...pick(props, ...plasmicClass.internalArgProps),\n    ...(config.startIconSlot && { [config.startIconSlot]: startIcon }),\n    ...(config.endIconSlot && { [config.endIconSlot]: endIcon }),\n    [config.contentSlot]: children,\n  };\n\n  const overrides: Overrides = {\n    [config.root]: {\n      as: !!link ? \"a\" : \"button\",\n      props: {\n        ...omit(\n          rest as any,\n          ...plasmicClass.internalArgProps,\n          ...plasmicClass.internalVariantProps\n        ),\n        ref: ref,\n        disabled: isDisabled,\n        ...(!!link && { href: link }),\n      },\n    },\n  };\n\n  return {\n    plasmicProps: {\n      variants: variants as PlasmicClassVariants<C>,\n      args: args as PlasmicClassArgs<C>,\n      overrides: overrides as PlasmicClassOverrides<C>,\n    },\n  };\n}\n","import { AriaCheckboxProps } from \"@react-types/checkbox\";\nimport * as React from \"react\";\nimport { useCheckbox as useAriaCheckbox } from \"@react-aria/checkbox\";\nimport { VisuallyHidden } from \"@react-aria/visually-hidden\";\nimport { useToggleState } from \"@react-stately/toggle\";\nimport { pick } from \"../../common\";\nimport { mergeProps } from \"../../react-utils\";\nimport { Overrides } from \"../../render/elements\";\nimport { useEnsureSSRProvider } from \"../../render/ssr\";\nimport {\n  AnyPlasmicClass,\n  mergeVariantToggles,\n  PlasmicClassArgs,\n  PlasmicClassOverrides,\n  PlasmicClassVariants,\n  VariantDef,\n} from \"../plume-utils\";\nimport { getStyleProps, StyleProps } from \"../props-utils\";\n\nexport type CheckboxRef = React.Ref<CheckboxRefValue>;\nexport interface CheckboxRefValue extends CheckboxState {\n  getRoot: () => HTMLElement | null;\n  focus: () => void;\n  blur: () => void;\n}\n\ninterface CheckboxState {\n  setChecked: (checked: boolean) => void;\n}\n\nexport interface CheckboxProps\n  extends Omit<AriaCheckboxProps, \"isSelected\" | \"defaultSelected\">,\n    StyleProps {\n  /**\n   * Whether the Checkbox is checked or not; controlled\n   */\n  isChecked?: boolean;\n\n  /**\n   * Whether the Checkbox is checked by default; uncontrolled\n   */\n  defaultChecked?: boolean;\n\n  /**\n   * Whether the Checkbox is in an \"indeterminate\" state; this usually\n   * refers to a \"check all\" that is used to check / uncheck many other\n   * checkboxes, and is visually indeterminate if some of its controlled\n   * checkboxes are checked and some are not.\n   */\n  isIndeterminate?: boolean;\n}\n\nfunction asAriaCheckboxProps(props: CheckboxProps) {\n  const ariaProps = {\n    ...props,\n    isSelected: props.isChecked,\n    defaultSelected: props.defaultChecked,\n  };\n  delete ariaProps[\"isChecked\"];\n  delete ariaProps[\"defaultChecked\"];\n  return ariaProps;\n}\n\ninterface CheckboxConfig<C extends AnyPlasmicClass> {\n  isCheckedVariant: VariantDef<PlasmicClassVariants<C>>;\n  isIndeterminateVariant?: VariantDef<PlasmicClassVariants<C>>;\n  isDisabledVariant?: VariantDef<PlasmicClassVariants<C>>;\n  noLabelVariant?: VariantDef<PlasmicClassVariants<C>>;\n  labelSlot?: keyof PlasmicClassArgs<C>;\n  root: keyof PlasmicClassOverrides<C>;\n}\n\nexport function useCheckbox<P extends CheckboxProps, C extends AnyPlasmicClass>(\n  plasmicClass: C,\n  props: P,\n  config: CheckboxConfig<C>,\n  ref: CheckboxRef = null\n) {\n  const { children, isDisabled, isIndeterminate } = props;\n  useEnsureSSRProvider();\n  const inputRef = React.useRef<HTMLInputElement>(null);\n  const rootRef = React.useRef<HTMLElement>(null);\n  const ariaProps = asAriaCheckboxProps(props);\n  const state = useToggleState(ariaProps);\n  const { inputProps } = useAriaCheckbox(ariaProps, state, inputRef);\n  const variants = {\n    ...pick(props, ...plasmicClass.internalVariantProps),\n    ...mergeVariantToggles(\n      {\n        def: config.isDisabledVariant,\n        active: isDisabled,\n      },\n      {\n        def: config.isCheckedVariant,\n        active: state.isSelected,\n      },\n      {\n        def: config.isIndeterminateVariant,\n        active: isIndeterminate,\n      },\n      {\n        def: config.noLabelVariant,\n        active: !children,\n      }\n    ),\n  };\n  const overrides: Overrides = {\n    [config.root]: {\n      as: \"label\",\n      props: mergeProps(getStyleProps(props), {\n        ref: rootRef,\n      }),\n      wrapChildren: (children) => (\n        <>\n          <VisuallyHidden isFocusable>\n            <input {...inputProps} ref={inputRef} />\n          </VisuallyHidden>\n          {children}\n        </>\n      ),\n    },\n  };\n  const args = {\n    ...pick(props, ...plasmicClass.internalArgProps),\n    ...(config.labelSlot ? { [config.labelSlot]: children } : {}),\n  };\n\n  const plumeState: CheckboxState = React.useMemo(\n    () => ({\n      setChecked: (checked: boolean) => state.setSelected(checked),\n    }),\n    [state]\n  );\n\n  React.useImperativeHandle(\n    ref,\n    () => ({\n      getRoot: () => rootRef.current,\n      focus: () => inputRef.current?.focus(),\n      blur: () => inputRef.current?.blur(),\n      setChecked: (checked) => plumeState.setChecked(checked),\n    }),\n    [rootRef, inputRef, plumeState]\n  );\n\n  return {\n    plasmicProps: {\n      variants: variants as PlasmicClassVariants<C>,\n      overrides: overrides as PlasmicClassOverrides<C>,\n      args: args as PlasmicClassArgs<C>,\n    },\n    state: plumeState,\n  };\n}\n","import { Placement } from \"@react-types/overlays\";\nimport { DOMProps, FocusableProps } from \"@react-types/shared\";\nimport * as React from \"react\";\nimport { useFocusable } from \"@react-aria/focus\";\nimport { useMenuTriggerState } from \"@react-stately/menu\";\nimport { pick } from \"../../common\";\nimport { mergeProps } from \"../../react-utils\";\nimport { Overrides } from \"../../render/elements\";\nimport { useEnsureSSRProvider } from \"../../render/ssr\";\nimport { BaseMenuProps } from \"../menu/menu\";\nimport {\n  AnyPlasmicClass,\n  mergeVariantToggles,\n  PlasmicClassArgs,\n  PlasmicClassOverrides,\n  PlasmicClassVariants,\n  VariantDef,\n} from \"../plume-utils\";\nimport { getStyleProps, StyleProps } from \"../props-utils\";\nimport { TriggeredOverlayContext } from \"../triggered-overlay/context\";\nimport { useMenuTrigger } from \"./menu-trigger\";\n\nexport interface BaseMenuButtonProps\n  extends DOMProps,\n    FocusableProps,\n    StyleProps,\n    Pick<React.ComponentProps<\"button\">, \"title\"> {\n  /**\n   * The menu to show; can either be a Menu instance, or a function that returns a Menu\n   * instance if you want to defer creating the instance till when it's opened.\n   */\n  menu:\n    | React.ReactElement<BaseMenuProps>\n    | (() => React.ReactElement<BaseMenuProps>);\n\n  /**\n   * Whether the button is disabled\n   */\n  isDisabled?: boolean;\n\n  /**\n   * Whether the menu is currently shown.\n   */\n  isOpen?: boolean;\n\n  /**\n   * Uncontrolled open state\n   */\n  defaultOpen?: boolean;\n\n  /**\n   * Event handler fired when Menu's open state changes\n   */\n  onOpenChange?: (isOpen: boolean) => void;\n\n  /**\n   * Desired placement location of the Select dropdown\n   */\n  placement?: Placement;\n  /**\n   * If true, menu width will always match the trigger button width.\n   * If false, then menu width will have min-width matching the\n   * trigger button width.\n   */\n  menuMatchTriggerWidth?: boolean;\n\n  /**\n   * If set, menu width will be exactly this width, overriding\n   * menuMatchTriggerWidth.\n   */\n  menuWidth?: number;\n}\n\nexport interface MenuButtonConfig<C extends AnyPlasmicClass> {\n  isOpenVariant: VariantDef<PlasmicClassVariants<C>>;\n  isDisabledVariant?: VariantDef<PlasmicClassVariants<C>>;\n\n  menuSlot: keyof PlasmicClassArgs<C>;\n\n  root: keyof PlasmicClassOverrides<C>;\n  trigger: keyof PlasmicClassOverrides<C>;\n}\n\ninterface MenuButtonState {\n  open: () => void;\n  close: () => void;\n  isOpen: () => boolean;\n}\n\nexport type MenuButtonRef = React.Ref<MenuButtonRefValue>;\n\nexport interface MenuButtonRefValue extends MenuButtonState {\n  getRoot: () => HTMLElement | null;\n  getTrigger: () => HTMLElement | null;\n  focus: () => void;\n  blur: () => void;\n}\n\nexport function useMenuButton<\n  P extends BaseMenuButtonProps,\n  C extends AnyPlasmicClass\n>(\n  plasmicClass: C,\n  props: P,\n  config: MenuButtonConfig<C>,\n  outerRef: MenuButtonRef = null\n) {\n  const {\n    placement,\n    isOpen,\n    defaultOpen,\n    onOpenChange,\n    isDisabled,\n    menu,\n    autoFocus,\n    menuMatchTriggerWidth,\n    menuWidth,\n  } = props;\n\n  useEnsureSSRProvider();\n  const rootRef = React.useRef<HTMLElement>(null);\n  const triggerRef = React.useRef<HTMLButtonElement>(null);\n\n  const state = useMenuTriggerState({\n    isOpen,\n    defaultOpen,\n    onOpenChange,\n    shouldFlip: true,\n  });\n\n  const { triggerProps, makeMenu, triggerContext } = useMenuTrigger(\n    {\n      isDisabled,\n      triggerRef,\n      placement,\n      menuMatchTriggerWidth,\n      menuWidth,\n      menu,\n    },\n    state\n  );\n\n  const { focusableProps: triggerFocusProps } = useFocusable(props, triggerRef);\n\n  const variants = {\n    ...pick(props, ...plasmicClass.internalVariantProps),\n    ...mergeVariantToggles(\n      { def: config.isOpenVariant, active: state.isOpen },\n      { def: config.isDisabledVariant, active: isDisabled }\n    ),\n  };\n\n  const args = {\n    ...pick(props, ...plasmicClass.internalArgProps),\n    [config.menuSlot]: state.isOpen ? makeMenu() : undefined,\n  };\n\n  const overrides: Overrides = {\n    [config.root]: {\n      wrapChildren: (children) => (\n        <TriggeredOverlayContext.Provider value={triggerContext}>\n          {children}\n        </TriggeredOverlayContext.Provider>\n      ),\n      props: {\n        ref: rootRef,\n      },\n    },\n    [config.trigger]: {\n      props: mergeProps(\n        triggerProps,\n        triggerFocusProps,\n        getStyleProps(props),\n        pick(props, \"title\"),\n        {\n          ref: triggerRef,\n          autoFocus,\n          disabled: !!isDisabled,\n          // Make sure this button is not interpreted as submit\n          type: \"button\",\n        }\n      ),\n    },\n  };\n\n  const plumeState: MenuButtonState = React.useMemo(\n    () => ({\n      open: () => state.open(),\n      close: () => state.close(),\n      isOpen: () => state.isOpen,\n    }),\n    [state]\n  );\n\n  React.useImperativeHandle(\n    outerRef,\n    () => ({\n      getRoot: () => rootRef.current,\n      getTrigger: () => triggerRef.current,\n      focus: () => triggerRef.current && triggerRef.current.focus(),\n      blur: () => triggerRef.current && triggerRef.current.blur(),\n      open: plumeState.open,\n      close: plumeState.close,\n      isOpen: plumeState.isOpen,\n    }),\n    [rootRef, triggerRef, plumeState]\n  );\n\n  return {\n    plasmicProps: {\n      variants: variants as PlasmicClassVariants<C>,\n      args: args as PlasmicClassArgs<C>,\n      overrides: overrides as PlasmicClassOverrides<C>,\n    },\n    state: plumeState,\n  };\n}\n","import { Node } from \"@react-types/shared\";\nimport * as React from \"react\";\nimport { useMenuSection } from \"@react-aria/menu\";\nimport { useSeparator } from \"@react-aria/separator\";\nimport { pick } from \"../../common\";\nimport { Overrides } from \"../../render/elements\";\nimport { renderCollectionNode, SectionLikeProps } from \"../collection-utils\";\nimport {\n  AnyPlasmicClass,\n  mergeVariantToggles,\n  PlasmicClassArgs,\n  PlasmicClassOverrides,\n  PlasmicClassVariants,\n  PLUME_STRICT_MODE,\n} from \"../plume-utils\";\nimport {\n  getDefaultPlasmicProps,\n  getStyleProps,\n  StyleProps,\n} from \"../props-utils\";\nimport { MenuContext } from \"./context\";\n\nexport interface BaseMenuGroupProps extends SectionLikeProps, StyleProps {}\n\ninterface MenuGroupConfig<C extends AnyPlasmicClass> {\n  noTitleVariant: PlasmicClassVariants<C>;\n  isFirstVariant: PlasmicClassVariants<C>;\n\n  itemsSlot: keyof PlasmicClassArgs<C>;\n  titleSlot: keyof PlasmicClassArgs<C>;\n\n  root: keyof PlasmicClassOverrides<C>;\n  separator: keyof PlasmicClassOverrides<C>;\n  titleContainer: keyof PlasmicClassOverrides<C>;\n  itemsContainer: keyof PlasmicClassOverrides<C>;\n}\n\nexport function useMenuGroup<\n  P extends BaseMenuGroupProps,\n  C extends AnyPlasmicClass\n>(plasmicClass: C, props: P, config: MenuGroupConfig<C>) {\n  const context = React.useContext(MenuContext);\n\n  const node = (props as any)._node as\n    | Node<React.ReactElement<BaseMenuGroupProps>>\n    | undefined;\n\n  if (!context || !node) {\n    if (PLUME_STRICT_MODE) {\n      throw new Error(\"You can only use a Menu.Group within a Menu component.\");\n    }\n    return getDefaultPlasmicProps(plasmicClass, props);\n  }\n\n  const { headingProps, groupProps } = useMenuSection({\n    heading: props.title,\n    \"aria-label\": props[\"aria-label\"],\n  });\n\n  const { separatorProps } = useSeparator({\n    elementType: \"li\",\n  });\n\n  const variants = {\n    ...pick(props, ...plasmicClass.internalVariantProps),\n    ...mergeVariantToggles(\n      { def: config.noTitleVariant, active: !props.title },\n      {\n        def: config.isFirstVariant,\n        active: context.state.collection.getFirstKey() === node.key,\n      }\n    ),\n  };\n\n  const args = {\n    ...pick(props, ...plasmicClass.internalArgProps),\n    [config.titleSlot]: props.title,\n    [config.itemsSlot]: Array.from(node.childNodes).map((childNode) =>\n      renderCollectionNode(childNode)\n    ),\n  };\n\n  const overrides: Overrides = {\n    [config.root]: {\n      props: getStyleProps(props),\n    },\n    [config.separator]: {\n      props: {\n        ...separatorProps,\n      },\n      as: \"li\",\n    },\n    [config.titleContainer]: {\n      props: {\n        role: \"presentation\",\n        ...headingProps,\n      },\n      ...(!props.title && {\n        render: () => null,\n      }),\n    },\n    [config.itemsContainer]: {\n      props: {\n        ...groupProps,\n      },\n      as: \"ul\",\n    },\n  };\n\n  return {\n    plasmicProps: {\n      variants: variants as PlasmicClassVariants<C>,\n      args: args as PlasmicClassArgs<C>,\n      overrides: overrides as PlasmicClassOverrides<C>,\n    },\n  };\n}\n","import { Node } from \"@react-types/shared\";\nimport * as React from \"react\";\nimport { useMenuItem as useAriaMenuItem } from \"@react-aria/menu\";\nimport { pick } from \"../../common\";\nimport { mergeProps } from \"../../react-utils\";\nimport { Overrides } from \"../../render/elements\";\nimport { ItemLikeProps } from \"../collection-utils\";\nimport {\n  AnyPlasmicClass,\n  mergeVariantToggles,\n  noOutline,\n  PlasmicClassArgs,\n  PlasmicClassOverrides,\n  PlasmicClassVariants,\n  PLUME_STRICT_MODE,\n  VariantDef,\n} from \"../plume-utils\";\nimport { getDefaultPlasmicProps } from \"../props-utils\";\nimport { TriggeredOverlayContext } from \"../triggered-overlay/context\";\nimport { MenuContext } from \"./context\";\n\nexport interface BaseMenuItemProps extends ItemLikeProps {\n  /**\n   * Called when this item is selected\n   */\n  onAction?: (key: string) => void;\n}\n\ninterface MenuItemConfig<C extends AnyPlasmicClass> {\n  isDisabledVariant?: VariantDef<PlasmicClassVariants<C>>;\n  isHighlightedVariant?: VariantDef<PlasmicClassVariants<C>>;\n\n  labelSlot: keyof PlasmicClassArgs<C>;\n\n  root: keyof PlasmicClassOverrides<C>;\n  labelContainer: keyof PlasmicClassOverrides<C>;\n}\n\nexport function useMenuItem<\n  P extends BaseMenuItemProps,\n  C extends AnyPlasmicClass\n>(plasmicClass: C, props: P, config: MenuItemConfig<C>) {\n  const menuContext = React.useContext(MenuContext);\n  const triggerContext = React.useContext(TriggeredOverlayContext);\n\n  if (!menuContext) {\n    if (PLUME_STRICT_MODE) {\n      throw new Error(\"You can only use a Menu.Item within a Menu component.\");\n    }\n\n    return getDefaultPlasmicProps(plasmicClass, props);\n  }\n\n  const { children, onAction } = props;\n\n  const { state, menuProps } = menuContext;\n\n  // We pass in the Node secretly as an undocumented prop from <Select />\n  const node = (props as any)._node as Node<\n    React.ReactElement<BaseMenuItemProps>\n  >;\n\n  const isDisabled = state.disabledKeys.has(node.key);\n  const isHighlighted =\n    state.selectionManager.isFocused &&\n    state.selectionManager.focusedKey === node.key;\n\n  const ref = React.useRef<HTMLLIElement>(null);\n\n  const { menuItemProps, labelProps } = useAriaMenuItem(\n    mergeProps(\n      {\n        // We need to merge both the onAction on MenuItem and the onAction\n        // on Menu\n        onAction,\n      },\n      {\n        onAction: menuProps.onAction,\n        onClose: triggerContext?.state.close,\n      },\n      {\n        isDisabled,\n        \"aria-label\": node && node[\"aria-label\"],\n        key: node.key,\n        isVirtualized: false,\n        closeOnSelect: true,\n      }\n    ),\n    state,\n    ref\n  );\n\n  const variants = {\n    ...pick(props, ...plasmicClass.internalVariantProps),\n    ...mergeVariantToggles(\n      { def: config.isDisabledVariant, active: isDisabled },\n      { def: config.isHighlightedVariant, active: isHighlighted }\n    ),\n  };\n\n  const args = {\n    ...pick(props, ...plasmicClass.internalArgProps),\n    [config.labelSlot]: children,\n  };\n\n  const overrides: Overrides = {\n    [config.root]: {\n      as: \"li\",\n      props: mergeProps(menuItemProps, { ref, style: noOutline() }),\n    },\n    [config.labelContainer]: {\n      props: { ...labelProps },\n    },\n  };\n\n  return {\n    plasmicProps: {\n      variants: variants as PlasmicClassVariants<C>,\n      args: args as PlasmicClassArgs<C>,\n      overrides: overrides as PlasmicClassOverrides<C>,\n    },\n  };\n}\n","import { Node } from \"@react-types/shared\";\nimport * as React from \"react\";\nimport { useOption as useAriaOption } from \"@react-aria/listbox\";\nimport { pick } from \"../../common\";\nimport { mergeProps, mergeRefs } from \"../../react-utils\";\nimport { Overrides } from \"../../render/elements\";\nimport { ItemLikeProps } from \"../collection-utils\";\nimport {\n  AnyPlasmicClass,\n  mergeVariantToggles,\n  noOutline,\n  PlasmicClassArgs,\n  PlasmicClassOverrides,\n  PlasmicClassVariants,\n  PLUME_STRICT_MODE,\n  VariantDef,\n} from \"../plume-utils\";\nimport {\n  getDefaultPlasmicProps,\n  getStyleProps,\n  StyleProps,\n} from \"../props-utils\";\nimport { SelectContext } from \"./context\";\n\nexport interface BaseSelectOptionProps extends ItemLikeProps, StyleProps {}\n\ninterface SelectOptionConfig<C extends AnyPlasmicClass> {\n  isSelectedVariant: VariantDef<PlasmicClassVariants<C>>;\n  isDisabledVariant?: VariantDef<PlasmicClassVariants<C>>;\n  isHighlightedVariant?: VariantDef<PlasmicClassVariants<C>>;\n\n  labelSlot: keyof PlasmicClassArgs<C>;\n\n  root: keyof PlasmicClassOverrides<C>;\n  labelContainer: keyof PlasmicClassOverrides<C>;\n}\n\nexport type SelectOptionRef = React.Ref<HTMLElement>;\n\nexport function useSelectOption<\n  P extends BaseSelectOptionProps,\n  C extends AnyPlasmicClass\n>(\n  plasmicClass: C,\n  props: P,\n  config: SelectOptionConfig<C>,\n  outerRef: SelectOptionRef = null\n) {\n  const state = React.useContext(SelectContext);\n\n  if (!state) {\n    // If no context, then we are being incorrectly used.  Complain or just don't\n    // bother installing any hooks.  It's okay to violate rules of hooks here\n    // because this instance won't suddenly be used correctly in another render.\n    if (PLUME_STRICT_MODE) {\n      throw new Error(\n        \"You can only use a Select.Option within a Select component.\"\n      );\n    }\n\n    return getDefaultPlasmicProps(plasmicClass, props);\n  }\n\n  const { children } = props;\n\n  const rootRef = React.useRef<HTMLElement>(null);\n  const onRef = mergeRefs(rootRef, outerRef);\n\n  // We pass in the Node secretly as an undocumented prop from <Select />\n  const node = (props as any)._node as Node<\n    React.ReactElement<BaseSelectOptionProps>\n  >;\n\n  const isSelected = state.selectionManager.isSelected(node.key);\n  const isDisabled = state.disabledKeys.has(node.key);\n  const isHighlighted =\n    state.selectionManager.isFocused &&\n    state.selectionManager.focusedKey === node.key;\n\n  const { optionProps, labelProps } = useAriaOption(\n    {\n      isSelected,\n      isDisabled,\n      \"aria-label\": node && node[\"aria-label\"],\n      key: node.key,\n      shouldSelectOnPressUp: true,\n      shouldFocusOnHover: true,\n      isVirtualized: false,\n    },\n    state,\n    rootRef\n  );\n\n  const variants = {\n    ...pick(props, ...plasmicClass.internalVariantProps),\n    ...mergeVariantToggles(\n      { def: config.isSelectedVariant, active: isSelected },\n      { def: config.isDisabledVariant, active: isDisabled },\n      { def: config.isHighlightedVariant, active: isHighlighted }\n    ),\n  };\n\n  const args = {\n    ...pick(props, ...plasmicClass.internalArgProps),\n    [config.labelSlot]: children,\n  };\n\n  const overrides: Overrides = {\n    [config.root]: {\n      props: mergeProps(optionProps, getStyleProps(props), {\n        ref: onRef,\n        style: noOutline(),\n      }),\n    },\n    [config.labelContainer]: {\n      props: labelProps,\n    },\n  };\n\n  return {\n    plasmicProps: {\n      variants: variants as PlasmicClassVariants<C>,\n      args: args as PlasmicClassArgs<C>,\n      overrides: overrides as PlasmicClassOverrides<C>,\n    },\n  };\n}\n","import { Node } from \"@react-types/shared\";\nimport * as React from \"react\";\nimport { useListBoxSection } from \"@react-aria/listbox\";\nimport { useSeparator } from \"@react-aria/separator\";\nimport { pick } from \"../../common\";\nimport { Overrides } from \"../../render/elements\";\nimport { renderCollectionNode, SectionLikeProps } from \"../collection-utils\";\nimport {\n  AnyPlasmicClass,\n  mergeVariantToggles,\n  PlasmicClassArgs,\n  PlasmicClassOverrides,\n  PlasmicClassVariants,\n  PLUME_STRICT_MODE,\n} from \"../plume-utils\";\nimport {\n  getDefaultPlasmicProps,\n  getStyleProps,\n  StyleProps,\n} from \"../props-utils\";\nimport { SelectContext } from \"./context\";\n\nexport interface BaseSelectOptionGroupProps\n  extends SectionLikeProps,\n    StyleProps {}\n\ninterface SelectOptionGroupConfig<C extends AnyPlasmicClass> {\n  noTitleVariant: PlasmicClassVariants<C>;\n  isFirstVariant: PlasmicClassVariants<C>;\n\n  optionsSlot: keyof PlasmicClassArgs<C>;\n  titleSlot: keyof PlasmicClassArgs<C>;\n\n  root: keyof PlasmicClassOverrides<C>;\n  separator: keyof PlasmicClassOverrides<C>;\n  titleContainer: keyof PlasmicClassOverrides<C>;\n  optionsContainer: keyof PlasmicClassOverrides<C>;\n}\n\nexport function useSelectOptionGroup<\n  P extends BaseSelectOptionGroupProps,\n  C extends AnyPlasmicClass\n>(plasmicClass: C, props: P, config: SelectOptionGroupConfig<C>) {\n  const state = React.useContext(SelectContext);\n\n  // `node` should exist if the OptionGroup was instantiated properly\n  // within a Select\n  const node = (props as any)._node as\n    | Node<React.ReactElement<BaseSelectOptionGroupProps>>\n    | undefined;\n\n  if (!state || !node) {\n    if (PLUME_STRICT_MODE) {\n      throw new Error(\n        \"You can only use a Select.OptionGroup within a Select component.\"\n      );\n    }\n    return getDefaultPlasmicProps(plasmicClass, props);\n  }\n\n  const { headingProps, groupProps } = useListBoxSection({\n    heading: props.title,\n    \"aria-label\": props[\"aria-label\"],\n  });\n\n  const { separatorProps } = useSeparator({\n    elementType: \"li\",\n  });\n\n  const variants = {\n    ...pick(props, ...plasmicClass.internalVariantProps),\n    ...mergeVariantToggles(\n      { def: config.noTitleVariant, active: !props.title },\n      {\n        def: config.isFirstVariant,\n        active: state.collection.getFirstKey() === node.key,\n      }\n    ),\n  };\n\n  const args = {\n    ...pick(props, ...plasmicClass.internalArgProps),\n    [config.titleSlot]: props.title,\n    [config.optionsSlot]: Array.from(node.childNodes).map((childNode) =>\n      renderCollectionNode(childNode)\n    ),\n  };\n\n  const overrides: Overrides = {\n    [config.root]: {\n      props: getStyleProps(props),\n    },\n    [config.separator]: {\n      props: {\n        ...separatorProps,\n      },\n    },\n    [config.titleContainer]: {\n      props: {\n        role: \"presentation\",\n        ...headingProps,\n      },\n      ...(!props.title && {\n        render: () => null,\n      }),\n    },\n    [config.optionsContainer]: {\n      props: {\n        ...groupProps,\n      },\n    },\n  };\n\n  return {\n    plasmicProps: {\n      variants: variants as PlasmicClassVariants<C>,\n      args: args as PlasmicClassArgs<C>,\n      overrides: overrides as PlasmicClassOverrides<C>,\n    },\n  };\n}\n","import { AriaSwitchProps } from \"@react-types/switch\";\nimport * as React from \"react\";\nimport { useSwitch as useAriaSwitch } from \"@react-aria/switch\";\nimport { VisuallyHidden } from \"@react-aria/visually-hidden\";\nimport { useToggleState } from \"@react-stately/toggle\";\nimport { pick } from \"../../common\";\nimport { mergeProps } from \"../../react-utils\";\nimport { Overrides } from \"../../render/elements\";\nimport { useEnsureSSRProvider } from \"../../render/ssr\";\nimport {\n  AnyPlasmicClass,\n  mergeVariantToggles,\n  PlasmicClassArgs,\n  PlasmicClassOverrides,\n  PlasmicClassVariants,\n  VariantDef,\n} from \"../plume-utils\";\nimport { getStyleProps, StyleProps } from \"../props-utils\";\n\nexport type SwitchRef = React.Ref<SwitchRefValue>;\nexport interface SwitchRefValue extends SwitchState {\n  getRoot: () => HTMLElement | null;\n  focus: () => void;\n  blur: () => void;\n}\n\ninterface SwitchState {\n  setChecked: (checked: boolean) => void;\n}\n\nexport interface SwitchProps\n  extends Omit<AriaSwitchProps, \"isSelected\" | \"defaultSelected\">,\n    StyleProps {\n  /**\n   * Whether the Switch is checked or not; controlled\n   */\n  isChecked?: boolean;\n\n  /**\n   * Whether the Switch is checked by default; uncontrolled\n   */\n  defaultChecked?: boolean;\n}\n\nfunction asAriaSwitchProps(props: SwitchProps) {\n  const ariaProps = {\n    ...props,\n    isSelected: props.isChecked,\n    defaultSelected: props.defaultChecked,\n  };\n  delete ariaProps[\"isChecked\"];\n  delete ariaProps[\"defaultChecked\"];\n  return ariaProps;\n}\n\ninterface SwitchConfig<C extends AnyPlasmicClass> {\n  isCheckedVariant: VariantDef<PlasmicClassVariants<C>>;\n  isDisabledVariant?: VariantDef<PlasmicClassVariants<C>>;\n  noLabelVariant?: VariantDef<PlasmicClassVariants<C>>;\n  labelSlot?: keyof PlasmicClassArgs<C>;\n  root: keyof PlasmicClassOverrides<C>;\n}\n\nexport function useSwitch<P extends SwitchProps, C extends AnyPlasmicClass>(\n  plasmicClass: C,\n  props: P,\n  config: SwitchConfig<C>,\n  ref: SwitchRef = null\n) {\n  const { children, isDisabled } = props;\n  useEnsureSSRProvider();\n  const inputRef = React.useRef<HTMLInputElement>(null);\n  const rootRef = React.useRef<HTMLElement>(null);\n  const ariaProps = asAriaSwitchProps(props);\n  const state = useToggleState(ariaProps);\n  const { inputProps } = useAriaSwitch(ariaProps, state, inputRef);\n  const variants = {\n    ...pick(props, ...plasmicClass.internalVariantProps),\n    ...mergeVariantToggles(\n      {\n        def: config.isDisabledVariant,\n        active: isDisabled,\n      },\n      {\n        def: config.isCheckedVariant,\n        active: state.isSelected,\n      },\n      {\n        def: config.noLabelVariant,\n        active: !children,\n      }\n    ),\n  };\n  const overrides: Overrides = {\n    [config.root]: {\n      as: \"label\",\n      props: mergeProps(getStyleProps(props), {\n        ref: rootRef,\n      }),\n      wrapChildren: (children) => (\n        <>\n          <VisuallyHidden isFocusable>\n            <input {...inputProps} ref={inputRef} />\n          </VisuallyHidden>\n          {children}\n        </>\n      ),\n    },\n  };\n  const args = {\n    ...pick(props, ...plasmicClass.internalArgProps),\n    ...(config.labelSlot ? { [config.labelSlot]: children } : {}),\n  };\n\n  const plumeState: SwitchState = React.useMemo(\n    () => ({\n      setChecked: (checked: boolean) => state.setSelected(checked),\n    }),\n    [state]\n  );\n\n  React.useImperativeHandle(\n    ref,\n    () => ({\n      getRoot: () => rootRef.current,\n      focus: () => inputRef.current?.focus(),\n      blur: () => inputRef.current?.blur(),\n      setChecked: (checked) => plumeState.setChecked(checked),\n    }),\n    [rootRef, inputRef, plumeState]\n  );\n\n  return {\n    plasmicProps: {\n      variants: variants as PlasmicClassVariants<C>,\n      overrides: overrides as PlasmicClassOverrides<C>,\n      args: args as PlasmicClassArgs<C>,\n    },\n    state: plumeState,\n  };\n}\n","import * as React from \"react\";\nimport { omit, pick } from \"../../common\";\nimport { Overrides } from \"../../render/elements\";\nimport {\n  AnyPlasmicClass,\n  mergeVariantToggles,\n  PlasmicClassArgs,\n  PlasmicClassOverrides,\n  PlasmicClassVariants,\n  VariantDef,\n} from \"../plume-utils\";\n\nexport interface BaseTextInputProps\n  extends Omit<React.ComponentProps<\"input\">, \"type\" | \"disabled\"> {\n  showStartIcon?: boolean;\n  showEndIcon?: boolean;\n  startIcon?: React.ReactNode;\n  endIcon?: React.ReactNode;\n  isDisabled?: boolean;\n  type?: \"text\" | \"password\" | \"email\" | \"url\" | string;\n  inputClassName?: string;\n  inputStyle?: React.CSSProperties;\n}\n\nexport interface TextInputRefValue {\n  focus: () => void;\n  blur: () => void;\n  getRoot: () => HTMLElement | null;\n  getInput: () => HTMLInputElement | null;\n}\n\nexport type TextInputRef = React.Ref<TextInputRefValue>;\n\ninterface TextInputConfig<C extends AnyPlasmicClass> {\n  showStartIconVariant: VariantDef<PlasmicClassVariants<C>>;\n  showEndIconVariant?: VariantDef<PlasmicClassVariants<C>>;\n  isDisabledVariant?: VariantDef<PlasmicClassVariants<C>>;\n  startIconSlot?: keyof PlasmicClassArgs<C>;\n  endIconSlot?: keyof PlasmicClassArgs<C>;\n  root: keyof PlasmicClassOverrides<C>;\n  input: keyof PlasmicClassOverrides<C>;\n}\n\nexport function useTextInput<\n  P extends BaseTextInputProps,\n  C extends AnyPlasmicClass\n>(\n  plasmicClass: C,\n  props: P,\n  config: TextInputConfig<C>,\n  ref: TextInputRef = null\n) {\n  const {\n    isDisabled,\n    startIcon,\n    endIcon,\n    showStartIcon,\n    showEndIcon,\n    className,\n    style,\n    inputClassName,\n    inputStyle,\n    ...rest\n  } = props;\n  const rootRef = React.useRef<HTMLElement>(null);\n  const inputRef = React.useRef<HTMLInputElement>(null);\n\n  React.useImperativeHandle(\n    ref,\n    () => ({\n      focus() {\n        inputRef.current?.focus();\n      },\n      blur() {\n        inputRef.current?.blur();\n      },\n      getRoot() {\n        return rootRef.current;\n      },\n      getInput() {\n        return inputRef.current;\n      },\n    }),\n    [rootRef, inputRef]\n  );\n\n  const variants = {\n    ...pick(props, ...plasmicClass.internalVariantProps),\n    ...mergeVariantToggles(\n      { def: config.showStartIconVariant, active: showStartIcon },\n      { def: config.showEndIconVariant, active: showEndIcon },\n      { def: config.isDisabledVariant, active: isDisabled }\n    ),\n  };\n\n  const args = {\n    ...pick(props, ...plasmicClass.internalArgProps),\n    ...(config.startIconSlot && { [config.startIconSlot]: startIcon }),\n    ...(config.endIconSlot && { [config.endIconSlot]: endIcon }),\n  };\n\n  const overrides: Overrides = {\n    [config.root]: {\n      props: {\n        ref: rootRef,\n        className,\n        style,\n      },\n    },\n    [config.input]: {\n      props: {\n        ...omit(\n          rest as any,\n          // We need to remove `required` from the list of internalArgProps to\n          // be omitted in the props being passed through because Plume pkg\n          // <= 19.1.1 had a bug: input[required] was not linked to the\n          // `required` arg as it should.\n          ...plasmicClass.internalArgProps.filter(\n            (prop) => prop !== \"required\"\n          ),\n          ...plasmicClass.internalVariantProps\n        ),\n        disabled: isDisabled,\n        ref: inputRef,\n        className: inputClassName,\n        style: inputStyle,\n      },\n    },\n  };\n\n  return {\n    plasmicProps: {\n      variants: variants as PlasmicClassVariants<C>,\n      args: args as PlasmicClassArgs<C>,\n      overrides: overrides as PlasmicClassOverrides<C>,\n    },\n  };\n}\n","import { DOMProps } from \"@react-types/shared\";\nimport * as React from \"react\";\nimport {\n  DismissButton,\n  useOverlay,\n  useOverlayPosition,\n} from \"@react-aria/overlays\";\nimport { FocusScope } from \"@react-aria/focus\";\nimport * as ReactDOM from \"react-dom\";\nimport { pick } from \"../../common\";\nimport {\n  mergeProps,\n  mergeRefs,\n  useIsomorphicLayoutEffect,\n} from \"../../react-utils\";\nimport { Overrides } from \"../../render/elements\";\nimport {\n  AnyPlasmicClass,\n  mergeVariantToggles,\n  PlasmicClassArgs,\n  PlasmicClassOverrides,\n  PlasmicClassVariants,\n  PLUME_STRICT_MODE,\n  VariantDef,\n} from \"../plume-utils\";\nimport {\n  getDefaultPlasmicProps,\n  getStyleProps,\n  StyleProps,\n} from \"../props-utils\";\nimport { TriggeredOverlayContext } from \"./context\";\n\nexport interface BaseTriggeredOverlayProps extends StyleProps, DOMProps {\n  children?: React.ReactNode;\n}\n\nexport interface TriggeredOverlayConfig<C extends AnyPlasmicClass> {\n  isPlacedTopVariant?: VariantDef<PlasmicClassVariants<C>>;\n  isPlacedBottomVariant?: VariantDef<PlasmicClassVariants<C>>;\n  isPlacedLeftVariant?: VariantDef<PlasmicClassVariants<C>>;\n  isPlacedRightVariant?: VariantDef<PlasmicClassVariants<C>>;\n\n  contentSlot: keyof PlasmicClassArgs<C>;\n  root: keyof PlasmicClassOverrides<C>;\n  contentContainer: keyof PlasmicClassOverrides<C>;\n}\n\nexport type TriggeredOverlayRef = React.Ref<HTMLElement>;\n\nexport function useTriggeredOverlay<\n  P extends BaseTriggeredOverlayProps,\n  C extends AnyPlasmicClass\n>(\n  plasmicClass: C,\n  props: P,\n  config: TriggeredOverlayConfig<C>,\n  outerRef: TriggeredOverlayRef = null,\n  isDismissable = true\n) {\n  const overlayRef = React.useRef<HTMLElement>(null);\n  const onOverlayRef = mergeRefs(overlayRef, outerRef);\n\n  const context = React.useContext(TriggeredOverlayContext);\n\n  if (!context) {\n    // If no context, then we are not being correctly used.  Either complain, or\n    // exit early.  It's okay to exit early and break the rules of React hooks\n    // because we won't suddenly have the appropriate context anyway for this instance.\n    if (PLUME_STRICT_MODE) {\n      throw new Error(\n        \"You can only use a triggered overlay with a TriggeredOverlayContext\"\n      );\n    }\n    return getDefaultPlasmicProps(plasmicClass, props);\n  }\n\n  const { children } = props;\n  const {\n    triggerRef,\n    placement,\n    overlayMatchTriggerWidth,\n    overlayMinTriggerWidth,\n    overlayWidth,\n    state,\n  } = context;\n\n  // Measure the width of the trigger to inform the width of the menu (below).\n  const [isRendered, setRendered] = React.useState(false);\n  const triggerWidth =\n    triggerRef.current && (overlayMatchTriggerWidth || overlayMinTriggerWidth)\n      ? triggerRef.current.offsetWidth\n      : undefined;\n\n  useIsomorphicLayoutEffect(() => {\n    if (\n      !isRendered &&\n      triggerRef.current &&\n      (overlayMatchTriggerWidth || overlayMinTriggerWidth)\n    ) {\n      setRendered(true);\n    }\n  }, [\n    triggerRef,\n    isRendered,\n    overlayMatchTriggerWidth,\n    overlayMinTriggerWidth,\n  ]);\n\n  const { overlayProps: overlayAriaProps } = useOverlay(\n    {\n      isOpen: state.isOpen,\n      onClose: state.close,\n      isDismissable,\n      shouldCloseOnBlur: true,\n    },\n    overlayRef\n  );\n\n  const {\n    overlayProps: overlayPositionProps,\n    updatePosition,\n    placement: placementAxis,\n  } = useOverlayPosition({\n    targetRef: triggerRef,\n    overlayRef,\n    placement: placement ?? \"bottom left\",\n    shouldFlip: true,\n    isOpen: state.isOpen,\n    onClose: state.close,\n    containerPadding: 0,\n  });\n\n  useIsomorphicLayoutEffect(() => {\n    if (state.isOpen) {\n      requestAnimationFrame(() => {\n        updatePosition();\n      });\n    }\n  }, [state.isOpen, updatePosition]);\n\n  const overlayProps = mergeProps(\n    {\n      style: {\n        left: \"auto\",\n        right: \"auto\",\n        top: \"auto\",\n        bottom: \"auto\",\n        position: \"absolute\",\n        width:\n          overlayWidth ?? (overlayMatchTriggerWidth ? triggerWidth : \"auto\"),\n        minWidth: overlayMinTriggerWidth ? triggerWidth : \"auto\",\n      },\n    },\n    overlayAriaProps,\n    overlayPositionProps\n  );\n\n  const variants = {\n    ...pick(props, ...plasmicClass.internalVariantProps),\n    ...mergeVariantToggles(\n      { def: config.isPlacedTopVariant, active: placementAxis === \"top\" },\n      { def: config.isPlacedBottomVariant, active: placementAxis === \"bottom\" },\n      { def: config.isPlacedLeftVariant, active: placementAxis === \"left\" },\n      { def: config.isPlacedRightVariant, active: placementAxis === \"right\" }\n    ),\n  };\n\n  const args = {\n    ...pick(props, ...plasmicClass.internalArgProps),\n    [config.contentSlot]: (\n      <FocusScope restoreFocus>\n        <DismissButton onDismiss={state.close} />\n        {children}\n        {/* We don't use the DismissButton at the end because it ends up taking up 1px space :-/ */}\n        {/* <DismissButton onDismiss={state.close} /> */}\n      </FocusScope>\n    ),\n  };\n\n  const overrides: Overrides = {\n    [config.root]: {\n      props: mergeProps(overlayProps, getStyleProps(props), {\n        ref: onOverlayRef,\n      }),\n      wrap: (root) => {\n        if (typeof document !== \"undefined\") {\n          return ReactDOM.createPortal(root, document.body);\n        } else {\n          // Possibly being invoked on the server during SSR; no need to\n          // bother with a portal in that case.\n          return root;\n        }\n      },\n    },\n  };\n\n  return {\n    plasmicProps: {\n      variants: variants as PlasmicClassVariants<C>,\n      args: args as PlasmicClassArgs<C>,\n      overrides: overrides as PlasmicClassOverrides<C>,\n    },\n  };\n}\n"],"names":["notNil","x","pick","obj","Object","keys","length","res","key","omit","includes","chainSingleArgFuncs","funcs","arg","func","groupBy","collection","keyFunc","result","push","mapValues","mapper","isBrowser","window","NONE","Symbol","useIsomorphicLayoutEffect","React","useLayoutEffect","useEffect","createElementWithChildren","elementType","props","children","Array","isArray","createElement","toChildArray","isValidElement","child","isReactText","flatMap","mergeProps","restProps","every","rest","mergePropVals","updateRef","ref","value","isFrozen","current","mergeRefs","refs","name","val1","val2","classNames","startsWith","renderStack","as","hasGap","wrappedChildren","wrapFlexContainerChildren","FlexStack_","outerRef","makeStackImpl","Stack","assign","div","a","button","h1","h2","h3","h4","h5","h6","label","form","section","head","main","nav","className","createPlasmicElement","override","defaultRoot","defaultProps","wrapChildrenInFlex","override2","deriveOverride","mergeOverrideProps","type","render","root","wrapChildren","Fragment","ensureNotArray","wrap","seenElements","Map","createPlasmicElementFromJsx","defaultElement","wrapFlexChild","triggerProps","UNSET","defaults","overrides","defaultVal","overrideVal","isReactNode","a1","a2","Error","mergeFlexOverrides","o1","o2","merged","from","Set","mergeFlexOverride","fo1","fo2","filter","undefined","PlasmicHeadContext","DEVICE_SIZES","ALL_SIZES","PlasmicImg","forwardRef","src","displayWidth","displayHeight","displayMinWidth","displayMinHeight","displayMaxWidth","displayMaxHeight","quality","loader","imgRef","style","loading","imgProps","fullWidth","fullHeight","aspectRatio","srcStr","isSvg","computedDisplayWidth","getPixelLength","spacerWidth","spacerHeight","isFinite","DEFAULT_SVG_WIDTH","Math","round","width","extra","minWidth","pixelWidth","pixelMinWidth","widthDescs","getClosestPresetSize","max","desc","sizes","usefulSizes","size","map","getWidths","imageLoader","PLASMIC_IMAGE_LOADER","getImageLoader","spacerSvg","spacerSvgBase64","Buffer","toString","btoa","wrapperStyle","spacerStyle","maxWidth","height","minHeight","maxHeight","alt","opts","supportsUrl","srcSet","wd","transformUrl","format","join","decoding","makePicture","endsWith","nextBiggerIndex","findIndex","w","nextBigger","parsed","val","match","num","units","parseNumeric","params","PlasmicLink","platform","href","nextjsProps","component","test","to","PlasmicTranslatorContext","createContext","genTranslatableString","elt","components","componentsCount","str","getText","node","iterator","nodeChildren","hasKey","contents","Children","toArray","componentId","cloneElement","Trans","_t","useContext","hasWarned","console","warn","v","renderPlasmicSlot","defaultContents","content","maybeString","maybeAsString","p","listeners","queries","matchScreenVariants","entries","matchMedia","matches","curScreenVariants","addEventListener","screenVariant","ReactDOM","unstable_batchedUpdates","forEach","listener","PlasmicRootContext","useIsSSR","useAriaIsSSR","useEnsureSSRProvider","TRIGGER_TO_HOOK","useHover","setHover","onMouseEnter","onMouseLeave","useFocused","useAriaFocusRing","within","isTextInput","isFocused","focusProps","useFocusVisible","isFocusVisible","useFocusedWithin","useFocusVisibleWithin","usePressed","setPressed","onMouseDown","onMouseUp","_classNames","PLUME_STRICT_MODE","mergeVariantToggles","toggles","definedToggles","def","grouped","group","subToggles","fromEntries","variant","active","getPlumeType","childType","__plumeType","getStyleProps","getDefaultPlasmicProps","plasmicClass","plasmicProps","variants","internalVariantProps","args","internalArgProps","RE_DATA_PROP","useDerivedItemsFromChildren","itemPlumeType","sectionPlumeType","invalidChildError","requireItemValue","useMemo","items","disabledKeys","itemCount","sectionCount","flattenedChildren","childKey","getItemLikeKey","element","propInChild","comp","displayName","_comp$render","getElementTypeName","cloneChild","ensureValue","getChildProp","deriveItemsFromChildren","renderCollectionNode","rendered","_node","renderAsCollectionChild","option","Item","textValue","Section","title","c","prop","componentProps","TriggeredOverlayContext","MenuContext","COLLECTION_OPTS","useMenuTrigger","state","triggerRef","isDisabled","placement","menuMatchTriggerWidth","menuWidth","menu","useAriaMenuTrigger","menuProps","usePress","menuTriggerProps","pressProps","makeMenu","realMenu","triggerContext","autoFocus","focusStrategy","overlayMatchTriggerWidth","overlayMinTriggerWidth","overlayWidth","SelectContext","ListBoxWrapper","useListBox","isVirtualized","disallowEmptySelection","listBoxProps","outline","set","k","i","l","split","t","indexOf","mkUntrackedValue","o","transformPathStringToObj","splitStatePathPart","slice","shallowEqual","isNum","isNaN","create$StateProxy","$$state","handlers","rec","currPath","nextKeyToSpecs","values","specsByKey","spec","pathObj","reduce","agg","nextKey","getNextKeyToSpecMap","getSpecForProperty","property","has","get","_nextKeyToSpecs$get","_nextKeyToSpecs$get2","getNextPath","Proxy","deleteProperty","target","prefixPath","specKeysToUpdate","existingStates","path","specKey","deleteState","add","onChangeProp","stateValues","Reflect","receiver","nextPath","_handlers$get","_handlers$set","JSON","stringify","unsubscriptionsByState","f","getIndexes","indexes","initializeStateValue","initialStatePath","initialSpec","initialStateKey","stateAccess","$state","valueProp","isRepeated","initFunc","unsubscribe","subscribeKey","untrackedInitialValue","initStateValues","isOpen","defaultOpen","onOpenChange","useMenuTriggerState","shouldFlip","Provider","Head","image","description","canonical","PlasmicIconType","userAuthToken","context","dataSourceContextValue","SSRProvider","PlasmicDataSourceContextProvider","translator","isRoot","forNodeName","forNode","clear","isMulti","screenQueries","updateState","lastScreenVariantsRef","updateIfChanged","splice","config","v1","v2","descendantNames","internalVariantPropNames","internalArgPropNames","reservedPropNames","leftoverProps","globalVariantValues","stateName","dataReps","pickBy","groupName","groupVariants","linkedStates","variantGroup","statePath","importName","importPath","isRepeatable","styleSections","mode","link","startIcon","endIcon","showStartIcon","showEndIcon","showStartIconVariant","showEndIconVariant","isDisabledVariant","startIconSlot","endIconSlot","contentSlot","disabled","specs","createValtioProxy","some","part","statesInstanceBySpec","registrationsQueue","_p","initVal","isIndeterminate","inputRef","rootRef","ariaProps","isSelected","isChecked","defaultSelected","defaultChecked","asAriaCheckboxProps","useToggleState","inputProps","useAriaCheckbox","isCheckedVariant","isIndeterminateVariant","noLabelVariant","VisuallyHidden","isFocusable","labelSlot","plumeState","setChecked","checked","setSelected","getRoot","focus","_inputRef$current","blur","_inputRef$current2","useRef","saveNewState","untrackedValue","registerInitFunc","pathStr","_$$state$statesInstan","deepEqual","resetSpecs","newInit","useSnapshot","sync","asAriaMenuProps","useTreeState","menuListRef","useAriaMenu","contextValue","itemsContainer","itemsSlot","getFocusedValue","selectionManager","focusedKey","setFocusedValue","setFocusedKey","triggerFocusProps","useFocusable","focusableProps","isOpenVariant","menuSlot","trigger","open","close","getTrigger","useMenuSection","heading","headingProps","groupProps","separatorProps","useSeparator","noTitleVariant","isFirstVariant","getFirstKey","titleSlot","childNodes","childNode","separator","titleContainer","role","menuContext","onAction","isHighlighted","useAriaMenuItem","onClose","closeOnSelect","menuItemProps","labelProps","isHighlightedVariant","labelContainer","defaultValue","onChange","onSelectionChange","defaultSelectedKey","selectedKey","useAriaSelectProps","useAriaSelectState","placeholder","selectedContent","useAriaSelect","triggerContent","selectedItem","placeholderVariant","HiddenSelect","overlay","optionsContainer","triggerContentSlot","placeholderSlot","optionsSlot","getSelectedValue","setSelectedValue","setSelectedKey","_triggerRef$current","_triggerRef$current2","onRef","useAriaOption","shouldSelectOnPressUp","shouldFocusOnHover","optionProps","isSelectedVariant","useListBoxSection","asAriaSwitchProps","useAriaSwitch","inputClassName","inputStyle","getInput","input","isDismissable","overlayRef","onOverlayRef","isRendered","setRendered","triggerWidth","offsetWidth","overlayAriaProps","useOverlay","shouldCloseOnBlur","overlayProps","useOverlayPosition","targetRef","containerPadding","overlayPositionProps","updatePosition","placementAxis","requestAnimationFrame","left","right","top","bottom","position","isPlacedTopVariant","isPlacedBottomVariant","isPlacedLeftVariant","isPlacedRightVariant","FocusScope","restoreFocus","DismissButton","onDismiss","document","body","display"],"mappings":"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"}