import classNames from 'classnames';
import React__default from 'react';

const isBrowser = typeof window !== "undefined";
const NONE = Symbol("NONE");
const useIsomorphicLayoutEffect = isBrowser
    ? React__default.useLayoutEffect
    : React__default.useEffect;
function createElementWithChildren(elementType, props, children) {
    if (Array.isArray(children)) {
        return React__default.createElement(elementType, props, ...children);
    }
    else if (children || "children" in props) {
        // Only call React.createElement with `children` if there are actual children,
        // or if there was an explicit (albeit undefined) children passed via
        // props.  Otherwise, if you pass `undefined` as the children argument
        // to React.createElement, the created element will have prop {children: undefined}.
        // If the `root` is an PlasmicGeneratedComponent, and these props with {children: undefined}
        // are used, then it will be taken as a `children` override, and will thus blank out
        // everything under the root node.
        return React__default.createElement(elementType, props, children);
    }
    else {
        return React__default.createElement(elementType, props);
    }
}
function ensureNotArray(children) {
    if (Array.isArray(children)) {
        if (children.length === 1) {
            return children[0];
        }
        else {
            return React__default.createElement(React__default.Fragment, {}, ...children);
        }
    }
    else {
        return children;
    }
}
/**
 * Flattens ReactNode into an array of ReactChild, but does NOT replace
 * missing keys with array index, as React.Children.toArray() does.
 */
function toChildArray(children) {
    if (isReactChild(children)) {
        return [children];
    }
    else if (Array.isArray(children)) {
        return children.flatMap(toChildArray);
    }
    else {
        return [];
    }
}
function isReactText(child) {
    return typeof child === "string" || typeof child === "number";
}
function isReactChild(child) {
    return React__default.isValidElement(child) || isReactText(child);
}
function isReactNode(x) {
    return (typeof x === "string" || typeof x === "number" || React__default.isValidElement(x));
}
function mergeProps(props, ...restProps) {
    if (restProps.every((rest) => Object.keys(rest).length === 0)) {
        return props;
    }
    const result = { ...props };
    for (const rest of restProps) {
        for (const key of Object.keys(rest)) {
            result[key] = mergePropVals(key, result[key], rest[key]);
        }
    }
    return result;
}
function updateRef(ref, value) {
    if (!ref) {
        return;
    }
    if (typeof ref === "function") {
        ref(value);
    }
    else {
        if (!Object.isFrozen(ref)) {
            ref.current = value;
        }
    }
}
function mergeRefs(...refs) {
    return (value) => {
        for (const ref of refs) {
            updateRef(ref, value);
        }
    };
}
function mergePropVals(name, val1, val2) {
    if (val1 === NONE || val2 === NONE) {
        // The NONE sentinel always skips all merging and returns null
        return null;
    }
    else if (val1 == null) {
        // If either of them is nil, prefer the other
        return val2;
    }
    else if (val2 == null) {
        return val1;
    }
    else if (name === "className") {
        // Special case for className -- always combine both class names
        return classNames(val1, val2);
    }
    else if (name === "style") {
        // Special case for style -- always shallow-merge style dicts
        return { ...val1, ...val2 };
    }
    else if (name === "ref") {
        // Special case for ref
        return mergeRefs(val1, val2);
    }
    else if (typeof val1 !== typeof val2) {
        // If the type of the two values are different, then no way to merge them.
        // Prefer val2.
        return val2;
    }
    else if (name.startsWith("on") && typeof val1 === "function") {
        // Special case for event handlers -- always call both handlers
        return (...args) => {
            let res;
            if (typeof val1 === "function") {
                res = val1(...args);
            }
            if (typeof val2 === "function") {
                res = val2(...args);
            }
            return res;
        };
    }
    else {
        // For all else, prefer val2
        return val2;
    }
}
function getElementTypeName(element) {
    var _a, _b, _c, _d;
    if (typeof element.type === "string") {
        return element.type;
    }
    else {
        const comp = element.type;
        return (_d = (_b = (_a = comp.displayName) !== null && _a !== void 0 ? _a : comp.name) !== null && _b !== void 0 ? _b : (_c = comp.render) === null || _c === void 0 ? void 0 : _c.name) !== null && _d !== void 0 ? _d : "Component";
    }
}

export { NONE as N, mergePropVals as a, isBrowser as b, createElementWithChildren as c, mergeRefs as d, ensureNotArray as e, getElementTypeName as g, isReactNode as i, mergeProps as m, toChildArray as t, useIsomorphicLayoutEffect as u };
//# sourceMappingURL=react-utils-b5dc6320.js.map
