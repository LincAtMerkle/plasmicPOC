import * as React from 'react';
import React__default from 'react';
import { SSRProvider, useIsSSR as useIsSSR$1 } from '@react-aria/ssr';

const PlasmicTranslatorContext = React__default.createContext(undefined);
function isIterable(val) {
    return val != null && typeof val[Symbol.iterator] === "function";
}
function genTranslatableString(elt) {
    const components = {};
    let componentsCount = 0;
    const getText = (node) => {
        if (!node) {
            return "";
        }
        if (typeof node === "number" ||
            typeof node === "boolean" ||
            typeof node === "string") {
            return node.toString();
        }
        if (typeof node !== "object") {
            return "";
        }
        if (Array.isArray(node) || isIterable(node)) {
            return Array.from(node)
                .map((child) => getText(child))
                .filter((child) => !!child)
                .join("");
        }
        const nodeChildren = (hasKey(node, "props") &&
            hasKey(node.props, "children") &&
            node.props.children) ||
            (hasKey(node, "children") && node.children) ||
            [];
        const contents = `${React__default.Children.toArray(nodeChildren)
            .map((child) => getText(child))
            .filter((child) => !!child)
            .join("")}`;
        if (React__default.isValidElement(node) && node.type === React__default.Fragment) {
            return contents;
        }
        const componentId = componentsCount + 1;
        componentsCount++;
        components[componentId] = React__default.isValidElement(node)
            ? React__default.cloneElement(node, {
                key: componentId,
                children: undefined,
            })
            : node;
        return `<${componentId}>${contents}</${componentId}>`;
    };
    const str = getText(elt);
    return {
        str,
        components,
        componentsCount,
    };
}
function Trans({ children }) {
    const _t = React__default.useContext(PlasmicTranslatorContext);
    if (!_t) {
        warnNoTranslationFunctionAtMostOnce();
        return children;
    }
    const { str, components, componentsCount } = genTranslatableString(children);
    return _t(str, componentsCount > 0 ? { components } : undefined);
}
let hasWarned = false;
function warnNoTranslationFunctionAtMostOnce() {
    if (!hasWarned) {
        console.warn("Using Plasmic Translation but no translation function has been provided");
        hasWarned = true;
    }
}
function hasKey(v, key) {
    return typeof v === "object" && v !== null && key in v;
}

const PlasmicRootContext = React.createContext(undefined);
function PlasmicRootProvider(props) {
    const { platform, children } = props;
    const context = React.useMemo(() => ({
        platform,
    }), [platform]);
    return (React.createElement(PlasmicRootContext.Provider, { value: context },
        React.createElement(SSRProvider, null,
            React.createElement(PlasmicTranslatorContext.Provider, { value: props.translator }, children))));
}
const useIsSSR = useIsSSR$1;
function useHasPlasmicRoot() {
    return !!React.useContext(PlasmicRootContext);
}
let hasWarnedSSR = false;
/**
 * Warns the user if PlasmicRootProvider is not used
 */
function useEnsureSSRProvider() {
    const hasRoot = useHasPlasmicRoot();
    if (hasRoot || hasWarnedSSR || process.env.NODE_ENV !== "development") {
        return;
    }
    hasWarnedSSR = true;
    console.warn(`Plasmic: To ensure your components work correctly with server-side rendering, please use PlasmicRootProvider at the root of your application.  See https://docs.plasmic.app/learn/ssr`);
}

export { PlasmicRootProvider as P, Trans as T, useEnsureSSRProvider as a, genTranslatableString as g, useIsSSR as u };
//# sourceMappingURL=ssr-68913b60.js.map
